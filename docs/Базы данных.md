
#Sybase PowerDesigner

* [Проектирование БД](http://www.sql.ru/forum/483726/vse-voprosy-po-sybase-powerdesigner-pd-chast-3) 
**(** [PowerDesigner](https://www.sybase.ru/products/powerdesigner) **|** [novye_vozmozhnosti_pd_16_5](novye_vozmozhnosti_pd_16_5.pdf) **)**
* [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **(** [pd_bpm_29-06-2005](pd_bpm_29-06-2005.pdf) **)**
* [PowerDesigner Web](pdweb_ru.pdf)

#Spring Data
* `Spring Data JPA` — банковская система управления клиентами: **(** [Часть 1](http://devcolibri.com/3966) **|** [Часть 2](http://devcolibri.com/4149) **)**
* `Spring Data JPA` — [пример приложения Hello World](http://javastudy.ru/spring-data-jpa/spring-data-jpa-helloworld/) **(** [Hello World](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-Hello-World.rar) **|** [SQL](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-helloWorld-SQL.rar) **)**
* ***[CrudRepository](https://m.habrahabr.ru/post/139421)*** и ***JpaRepository***
* ***[@Transactional](http://www.gns34.ru/2015/09/01/использование-аннотации-transactional)***  **(** [транзакционные стратегии](http://www.k-press.ru/cs/2009/1/ts/ts.asp) **)**

---
######Доменный слой (ближе всего к базе)

	Этот слой находится на самом низком уровне, он обеспечивает конкретную реализацию соединения и работу с SQL-методами `на физическом уровне` согласно спецификации для каждного отдельного типа базы данных.
	(На уровне этого слоя можем делегировать обработку sql-транзакций в базу СУБД через JDBC-интерфейс)

######DAO слой (DAO/Repositories - для обеспечение доступа к данным)

	Это такой себе абстрактый слой, который (`независимо от типа базы данных `) позволяет одинаково использовать SQL-методы для всех баз данных...
	(На уровне этого слоя может использоваться ORM: `JPA`,`Hibernate`,`TopLink`;  JPQL: `@Query`;)

- **DAO** (Data Access Object) — это слой объектов которые обеспечивают доступ к данным.
- ( **EntityManager** - используется для реализации DAO и с его помощью мы работаем с нашей БД )
- **Repository** — *Spring Data* предоставляет набор готовых реализаций для создания DAO.

######Сервисный слой (Бизнес-Логика)

	(И Доменный-слой, и DAO-слой - реализовываются только для каждой отдельной, одной, таблицы)
	Сервисный слой используется для выполнения сожных транзакций, учитывая несколько операций и таблиц одновременно...
	И если что-то пошле не так - именно на этом уровне можно либо подтвердить либо отменить все транзакции (согласно плану бизнес-логики)
	(На уровне этого слоя может использоваться: `Criteria`, `@Transactional`...)


В `resources` есть файл **app.properties**
```properties
#DB properties:
db.driver=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost:3306/testdb
db.username=root
db.password=root
 
#Hibernate Configuration:
db.hibernate.dialect=org.hibernate.dialect.MySQLDialect
db.hibernate.show_sql=true
db.entitymanager.packages.to.scan=com.devcolibri.dataexam.entity
db.hibernate.hbm2ddl.auto = create
```

######Разберем аннотации:
```xml
<!--Have Spring servlet handle all static content-->
<mvc:annotation-driven/>

<!--Activates various annotations to be detected in bean classes: Spring's @Required and @Autowired and so on-->
<context:annotation-config/>

<!--@Transaction annotation support-->
<tx:annotation-driven transaction-manager="transactionManager"/>
```

> **@Configuration** — говорит, что данный класс является Spring конфигурацией;
> **@ComponentScan**("com.devcolibri.dataexam") — указываем Spring где нужно искать Entity, DAO, Service и т.п.;
> **@PropertySource**("classpath:app.properties") — подключаем файл свойств созданный выше;

- **@EnableTransactionManagement** — включает TransactionManager для управления транзакциями БД;
- **@EnableJpaRepositories**("com.devcolibri.dataexam.repository") — включаем возможность использования JPARepository и говорим, где их искать;
- **@Repository** — является абстракция репозитория Spring Data, представляет оболочку вокруг базового интерфейса JPA EntityManager и предлагает более широкие возможности для доступа к данным;
- **@Query** — которая позволяет создать SQL запрос (используется в Repository-слое);
- **@Transactional** — методы помеченные этой транзакцией автоматически выполняют *commit* или *rollback* по результату  (используется в сервисном-слое...)

---

- **CrudRepository** — центральный интерфейс из Spring Data. Наследовавшись от *org.springframework.data.repository.CrudRepository* вы получили возможность вызывать такие методы как (без необходимости реализовывать их имплементировать):

> save
>
> findOne
>
> exists
>
> findAll
>
> count
>
> delete
>
> deleteAll


######Общее соглашение об именовании
При выполнении требований по названию методов, Spring Data JPA самостоятельно создаст запрос на основании имени метода. Например:
```java
	public interface ContactRepository extends CrudRepository<ContactEntity, Integer>{
	
		List<ContactEntity> findByFirstName(String firstName);
		List<ContactEntity> findByFirstNameAndLastName(String firstName, String lastName);
		
	}
```

для
```java
	findByFirstName(String firstName)
```

будет создан запрос
```java
	select c from ContactEntity where c.firstName = :firstName
```



- **JpaRepository** — это интерфейс фреймворка Spring Data предоставляющий набор стандартных методов JPA для работы с БД.

> Для чего вам может понадобиться Spring Data JPA — если нужно быстро в проекте создать Repository-слой базируемый на JPA, предназначенный в основном для CRUD операций, и вы не хотите создавать абстрактные DAO, интерфейсы их реализации, то Spring Data — JPA это хороший выбор.

Кастомный метод в Spring Data
```java
	public interface BankRepository extends JpaRepository<Bank, Long> {
	 
		@Query("select b from Bank b where b.name = :name")
		Bank findByName(@Param("name") String name);
	 
	}
```

Spring Data на основе предоставленых данных в аннотациях сам предоставит реализацию этого метода
```java
	@Override
	public Bank getByName(String name) {
		return bankRepository.findByName(name);
	}
```


```java
   /**
    *      mappedBy - свойство в ContactTelDetailEntity, связанное с внешнем ключом в этой таблице
    *       cascade - операция обновления должна распространяться на дочерние записи
    * orphanRemoval - после обновления, записи которых больше нет в наборе должны быть удалены из БД
    */
    @OneToMany(mappedBy = "contact", cascade = CascadeType.ALL, orphanRemoval = true)
    public Set<ContactTelDetailEntity> getContactTelDetailEntities() {
        return contactTelDetailEntities;
    }
```

```java
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.MERGE, CascadeType.PERSIST})
    @JoinColumn(name = "client_id", nullable = false)
    private Client client;
```

```java
	@ManyToMany
	@JoinTable(name = "contact_hobby_detail",
			//foreign key for ContactEntity in contact_hobby_detail table
			joinColumns = @JoinColumn(name = "contact_id"),
			//key for other side - hobby table
			inverseJoinColumns = @JoinColumn(name = "hobby_id"))
	public Set<HobbyEntity> getHobbies() {
		//TODO
    }
```



- **@Transactional** — аннотация...

Для использования аннотации @Transactional в Spring нужно добавить следующую строку в файл конфигурации Spring:

```xml
    <tx:annotation-driven transaction-manager="transactionManager"/>
```

Использование аннотации @Transactional

```java
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      @Transactional
      public long insertTrade(TradeData trade) throws Exception
      {
        em.persist(trade);
        return trade.getTradeId();
      }
    }
```

Проблемы с флагом read-only аннотации @Transactiona

```java
    /**
     * Использование read-only с режимом распространения транзакций SUPPORTS / JDBC — ничего не делает, поскольку задан режим распространения транзакций SUPPORTS
     * Использование read-only с режимом распространения REQUIRED / JDBC — генерирует исключение "read-only connection"
     * Использование read-only с режимом распространения REQUIRED / JPA — корректно вставляется заказ в БД и сохраняет данные без ошибок (при использовании ORM-фреймворка флаг read-only – это только подсказка для СУБД и директива для ORM-фреймворка)
     * Использование флага read-only и режима распространения SUPPORTS при операциях выборки данных — лучше вовсе избегать использования аннотации @Transactional при операциях чтения
     */
    @Transactional(readOnly=true, propagation=Propagation.SUPPORTS, rollbackFor=Exception.class)
    public long insertTrade(TradeData trade) throws Exception
    {
       //JDBC Code...

       //JPA Code:
       em.persist(trade);
       return trade.getTradeId();
    }
```

EJB работает с откатом транзакций иначе чем Spring Framework

```java
    /**
     * Аннотация @TransactionAttribute из спецификации EJB управлят поведением отката, нужно использовать метод `SessionContext.setRollbackOnly()`, чтобы пометить транзакцию для отката
     */
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public TradeData placeTrade(TradeData trade) throws Exception
    {
       try {
          insertTrade(trade);
          updateAcct(trade);
          return trade;
       } catch (Exception up) {
          // запись ошибки в лог
          sessionCtx.setRollbackOnly();
          throw up;
       }
    }
```

***propagation*** — тип распространения транзакции ( *накштаут sql-блокировок только в Spring* )

|     | Атрибут        | Вызов вне транзакции             | Вызов внутри другой транзакции | Описание                                                                                                                    |
| --- | -------------- | -------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------- |
| 1.  | `Mandatory`    | (`TransactionRequiredException`) | Будет использовать             | (Атрибут используется в стратегии клиентского дирижирования)                                                                |
|     |                |                                  |                                | Метод вызывается только в области видимости ранее начатой транзакции                                                        |
|     |                |                                  |                                | Если метод вызывается вне контекста транзакции то будет выброшено исключение (`TransactionRequiredException`)               |
|     |                |                                  |                                |                                                                                                                             |
| 2.  | `Required`     | Начнется новая                   | Будет использовать             | (Являющийся атрибутом по умолчанию в EJB и Spring)                                                                          |
|     |                |                                  |                                | Метод вызывается в области видимости ранее начатой транзакции                                                               |
|     |                |                                  |                                | В противном случае метод начнет новую транзакцию                                                                            |
|     |                |                                  |                                | Если метод запустил новую транзакцию то она должна завершиться этим методом                                                 |
|     |                |                                  |                                |                                                                                                                             |
| 3.  | `RequiresNew`  | Начнется новая                   | Всегда новая                   | Если метод был вызван в контексте другой транзакции то она будет прервана и будет начата новая транзакция                   |
|     |                |                                  |                                | При завершении метода новая транзакция подтверждается/откатывается и после возобновляется выполнение старой транзакция      |
|     |                |                                  |                                |                                                                                                                             |
| 4.  | `Supports`     | Не запустить транзакцию          | Будет использовать             | (Атрибут используется для операций чтения данных из базы)                                                                   |
|     |                |                                  |                                | Применяется к методу который вызывается в области видимости существующей транзакции (будет выполнен внутри этой транзакции) |
|     |                |                                  |                                | Если метод вызывается вне контекста транзакции то транзакция не будет начата вовсе                                          |
|     |                |                                  |                                |                                                                                                                             |
| 5.  | `NotSupported` | Выполнение вне контекста транзацкии                               | Метод не должен выполняться внутри транзакции: ни новой, ни уже существующей                                                |
|     |                |                                  |                                |                                                                                                                             |
| 6.  | `Never`        | Не запустить транзакцию          | (`RemoteException`)            | (Позволяет легко/быстро проверить существования транзакции в момент вызова некоторого метода)                               |
|     |                |                                  |                                | Ведет себя так же как (`NotSupported`)                                                                                      |
|     |                |                                  |                                | Если метод, отмеченный данным атрибутом, вызывается в контексте транзакции то выбрасывается исключение                      |

***readOnly*** — флаг транзакции только для чтения

***rollbackForClassName*** | ***rollbackForClassName*** — флаг транзакции для отката


---

######Платформа Java поддерживает 3-модели транзакций:

1 ***Модель локальных транзакций*** — эта модель применима при использовании DAO или JDBC-фреймворков и хранимых процедур СУБД (вы управляете подключениями, а не транзакциями)

```java
    public class TradingServiceImpl
    {
      public void processTrade(TradeData trade) throws Exception
      {
        Connection dbConnection = null;
        try
        {
          DataSource ds = (DataSource)
            (new InitialContext()).lookup("jdbc/MasterDS");
          dbConnection = ds.getConnection();
          dbConnection.setAutoCommit(true);
            Statement sql = dbConnection.createStatement();
            String stmt = "insert into TRADE ...";
            sql.executeUpdate(stmt1);
        }
        finally
        {
          if (dbConnection != null)
            dbConnection.close();
        }
      }
    }
```


2 ***Модель программных транзакций*** — вы управляете транзакциями и изолированы от нижележащий подключений к БД

```java
    /**
     * Программные транзакции в EJB 3.0
     */
    @Stateless
    @TransactionManagement(TransactionManagementType.BEAN)
    public class TradingServiceImpl implements TradingService
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      public void processTrade(TradeData trade) throws Exception
      {
        InitialContext ctx = new InitialContext();
        UserTransaction txn = (UserTransaction)ctx.lookup("UserTransaction");
        try
        {
          txn.begin();
            em.persist(trade);
            AcctData acct = em.find(AcctData.class, trade.getAcctId());
            double tradeValue = trade.getPrice() * trade.getShares();
            double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
          txn.commit();
        }
        catch (Exception up)
        {
          txn.rollback();
          throw up;
        }
      }
    }
```

```java
    /**
     * Использование менеджера транзакций JPA в Spring
     */
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      JpaTransactionManager txnManager = null;
      public void setTxnManager(JpaTransactionManager mgr)
      {
        txnManager = mgr;
      }

      public void processTrade(TradeData trade) throws Exception
      {
        TransactionStatus status = txnManager.getTransaction(new DefaultTransactionDefinition());
        try
        {
          em.persist(trade);
          AcctData acct = em.find(AcctData.class, trade.getAcctId());
          double tradeValue = trade.getPrice() * trade.getShares();
          double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
          txnManager.commit(status);
        }
        catch (Exception up)
        {
          txnManager.rollback(status);
          throw up;
        }
      }
    }
```


3 ***Модель декларативных транзакций*** — CMT (Container Managed Transactions) транзакции управляемые контейнером

```java
    /**
     * в EJB 3.0
     */
    @Stateless
    public class TradingServiceImpl implements TradingService
    {
      @PersistenceContext(unitName="trading") EntityManager em;
      @Resource SessionContext ctx;

      @TransactionAttribute(TransactionAttributeType.REQUIRED)
      public void processTrade(TradeData trade) throws Exception
      {
        try
        {
          em.persist(trade);
          AcctData acct = em.find(AcctData.class, trade.getAcctId());
          double tradeValue = trade.getPrice() * trade.getShares();
          double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
        }
        catch (Exception up)
        {
          ctx.setRollbackOnly();
          throw up;
        }
      }
    }
```

```java
    /**
     * в Spring
     */
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      @Transactional(propagation=Propagation.REQUIRED,
        rollbackFor=Exception.class)
      public void processTrade(TradeData trade) throws Exception
      {
        em.persist(trade);
        AcctData acct = em.find(AcctData.class, trade.getAcctId());
        double tradeValue = trade.getPrice() * trade.getShares();
        double currentBalance = acct.getBalance();
        if (trade.getAction().equals("BUY"))
        {
          acct.setBalance(currentBalance - tradeValue);
        }
        else
        {
          acct.setBalance(currentBalance + tradeValue);
        }
      }
    }
```

