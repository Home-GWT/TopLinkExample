#Sybase PowerDesigner

* [Ключи и индексы в базе](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L384)
* [Проектирование БД](http://www.sql.ru/forum/483726/vse-voprosy-po-sybase-powerdesigner-pd-chast-3) 
**(** [PowerDesigner](https://www.sybase.ru/products/powerdesigner) **|** [novye_vozmozhnosti_pd_16_5](novye_vozmozhnosti_pd_16_5.pdf) **)**
* [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **(** [pd_bpm_29-06-2005](pd_bpm_29-06-2005.pdf) **)**
* [PowerDesigner Web](pdweb_ru.pdf)


#Ключи и индексы в базе

* [форум](http://www.sql.ru/forum/831362/pervichnyy-i-vneshniy-kluch)
* [первичный и внешний ключ](http://www.flenov.info/books.php?contentid=6)

***Первичный ключь*** не позволяет вносить в таблицу дублей (две записи должны гарантированно чем-то отличаться) — в этом ограничение для первичного ключа.

    кандидат в первичные ключи:
    1. это перечень полей по которому записи гарантированно отличаются (по автору/названию/издательству/году...)
       Потенциальный ключ (KEY)
       Уникальный ключ (UNIQUE)
    2. это поле-счетчик (может быть только один на всю таблицу)
       Первичный ключ (PRIMARY KEY)


```sql
    CREATE TABLE Guids
    (
     id INT(10) PRIMARY KEY NOT NULL auto increment,
     name CHAR(50)
    );
```

```sql
    CREATE TABLE Guids
    (
     id INT(10) NOT NULL auto increment,
     name CHAR(50),
     CONSTRAINT PK_id PRIMARY KEY (id)
    );
```

***Внешний ключь*** не позволяет чтобы в *подчиненной таблице* какие-то записи ссылались на несуществующие записи из *главной таблицы* (разные таблицы логически связаны друг с другом) — в этом ограничение для внешнего ключа.

    внешний ключь должен:
    — ссылаться на первичный ключь
    — ссылаться на перечень полей (этот перечень полей должен входить либо в первичный, либо в уникальный ключь)

Во время создания внешнего ключа можно указать: **ON DELETE CASCADE** или **ON UPDATE CASCADE** (`например: если удалить запись из таблицы *Names* или *изменить идентификатор*, тогда все записи в таблице *Phones*, связанные со строкой будут автоматически обновлены`).

Внешний ключ может ссылаться только на первичный ключ другой таблицы или на ограничение уникальности.
После ключевого слова **REFERENCES** должно быть *имя таблицы* и в скобках можно указывать только *первичный ключ* или *поле с ограничением UNIQUE*.
```sql
    CREATE TABLE Names
    (
     id INT(10) NOT NULL auto increment,
     name CHAR(50),
     CONSTRAINT PK_id PRIMARY KEY (id)
    );

    CREATE TABLE Phones
    (
     id INT(10) NOT NULL auto increment,
     id_name INT(10),
     phone CHAR(10),
     CONSTRAINT PK_id PRIMARY KEY (id),
     CONSTRAINT FK_id_name FOREIGN KEY (id_name) REFERENCES Names (id)
    );
```

Таблица с внутренней связью
```sql
    CREATE TABLE Positions
    (
     id INT(10) NOT NULL auto increment,
     id_parent INT(10),
     name CHAR(30),
     CONSTRAINT PK_id PRIMARY KEY (id),
     CONSTRAINT FK_id_parent FOREIGN KEY (id_parent) REFERENCES Positions (id)
    );
```

* **Отношение один к одному**

Две таблицы, у которых создана связь между *первичными ключами*
```sql
    CREATE TABLE Names
    (
     id_name INT(10) NOT NULL auto increment,
     name CHAR(50),
     CONSTRAINT PK_id_name PRIMARY KEY (id_name)
    );

    CREATE TABLE Phones
    (
     id_phone INT(10) NOT NULL auto increment,
     phone CHAR(10),
     CONSTRAINT PK_idPhone PRIMARY KEY (id_phone),
     CONSTRAINT FK_id_phone FOREIGN KEY (id_phone) REFERENCES Names (id_name)
    );
```

* **Многие ко многим**

Когда много записей из одной таблицы соответствует многим записям из другой таблицы (чтобы такое реализовать необходимо 3-и таблицы)
```sql
    CREATE TABLE Names
    (
     id INT(10) NOT NULL auto increment,
     name CHAR(50),
     CONSTRAINT PK_i PRIMARY KEY (id)
    );

    CREATE TABLE Phones
    (
     id INT(10) NOT NULL auto increment,
     phone CHAR(10),
     CONSTRAINT PK_id PRIMARY KEY (id)
    );

    CREATE TABLE LinkTable
    (
     id INT(10) NOT NULL auto increment,
     id_name INT(10),
     id_phone INT(10),
     CONSTRAINT PK_id PRIMARY KEY (id),
     CONSTRAINT FK_id_phone FOREIGN KEY (id_phone) REFERENCES Phones (id),
     CONSTRAINT FK_id_name FOREIGN KEY (id_name) REFERENCES Names (id)
    );
```


#Spring Data
* `Spring Data JPA` — банковская система управления клиентами: **(** [Часть 1](http://devcolibri.com/3966) **|** [Часть 2](http://devcolibri.com/4149) **)**
* `Spring Data JPA` — [пример приложения Hello World](http://javastudy.ru/spring-data-jpa/spring-data-jpa-helloworld/) **(** [Hello World](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-Hello-World.rar) **|** [SQL](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-helloWorld-SQL.rar) **)**
* `Spring Data JPA` — [разъяснение в конфигурации Spring+Hibernate(JPA)](https://toster.ru/q/293938)
* ***[CrudRepository](https://m.habrahabr.ru/post/139421)*** и ***JpaRepository***
* ***[@Transactional](http://www.gns34.ru/2015/09/01/использование-аннотации-transactional)***  **(** [транзакционные стратегии](http://www.k-press.ru/cs/2009/1/ts/ts.asp) **|** [распространенные ошибки](https://www.ibm.com/developerworks/ru/library/j-ts1) **)**
* ***[JPQL](http://javatalks.ru/topics/37094)***  **(** [JPQL](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L833) **|** [примеры запросов 1](http://docs.oracle.com/cd/E16764_01/apirefs.1111/e13046/ejb3_langref.html#ejb3_langref_Joins) **|** [примеры запросов 2](https://en.wikibooks.org/wiki/Java_Persistence/JPQL_BNF#Update) **|** [стратегии загрузки коллекций](https://dou.ua/lenta/articles/jpa-fetch-types/) **)**

---

######Доменный слой (ближе всего к базе)

	Этот слой находится на самом низком уровне, он обеспечивает конкретную реализацию соединения и работу с SQL-методами `на физическом уровне` согласно спецификации для каждного отдельного типа базы данных.
	(На уровне этого слоя можем делегировать обработку sql-транзакций в базу СУБД через JDBC-интерфейс)

######DAO слой (DAO/Repositories - для обеспечение доступа к данным)

	Это такой себе абстрактый слой, который (`независимо от типа базы данных `) позволяет одинаково использовать SQL-методы для всех баз данных...
	(На уровне этого слоя может использоваться ORM: `JPA`,`Hibernate`,`TopLink`;  JPQL: `@Query`;)

- **DAO** (Data Access Object) — это слой объектов которые обеспечивают доступ к данным.
- ( **EntityManager** - используется для реализации DAO и с его помощью мы работаем с нашей БД )
- **Repository** — *Spring Data* предоставляет набор готовых реализаций для создания DAO.

######Сервисный слой (Бизнес-Логика)

	(И Доменный-слой, и DAO-слой - реализовываются только для каждой отдельной, одной, таблицы)
	Сервисный слой используется для выполнения сожных транзакций, учитывая несколько операций и таблиц одновременно...
	И если что-то пошле не так - именно на этом уровне можно либо подтвердить либо отменить все транзакции (согласно плану бизнес-логики)
	(На уровне этого слоя может использоваться: `Criteria`, `@Transactional`...)


В `resources` есть файл **app.properties**
```properties
#DB properties:
db.driver=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost:3306/testdb
db.username=root
db.password=root
 
#Hibernate Configuration:
db.hibernate.dialect=org.hibernate.dialect.MySQLDialect
db.hibernate.show_sql=true
db.entitymanager.packages.to.scan=com.devcolibri.dataexam.entity
db.hibernate.hbm2ddl.auto = create
```

######Разберем аннотации:
```xml
<!--Have Spring servlet handle all static content-->
<mvc:annotation-driven/>

<!--Activates various annotations to be detected in bean classes: Spring's @Required and @Autowired and so on-->
<context:annotation-config/>

<!--@Transaction annotation support-->
<tx:annotation-driven transaction-manager="transactionManager"/>
```

> **@Configuration** — говорит, что данный класс является Spring конфигурацией;
> **@ComponentScan**("com.devcolibri.dataexam") — указываем Spring где нужно искать Entity, DAO, Service и т.п.;
> **@PropertySource**("classpath:app.properties") — подключаем файл свойств созданный выше;

- **@EnableTransactionManagement** — включает TransactionManager для управления транзакциями БД;
- **@EnableJpaRepositories**("com.devcolibri.dataexam.repository") — включаем возможность использования JPARepository и говорим, где их искать;
- **@Repository** — является абстракция репозитория Spring Data, представляет оболочку вокруг базового интерфейса JPA EntityManager и предлагает более широкие возможности для доступа к данным;
- **@Query** — которая позволяет создать SQL запрос (используется в Repository-слое);
- **@Transactional** — методы помеченные этой транзакцией автоматически выполняют *commit* или *rollback* по результату  (используется в сервисном-слое...)

---

- **CrudRepository** — центральный интерфейс из Spring Data. Наследовавшись от *org.springframework.data.repository.CrudRepository* вы получили возможность вызывать такие методы как (без необходимости реализовывать их имплементировать):

> save
>
> findOne
>
> exists
>
> findAll
>
> count
>
> delete
>
> deleteAll


######Общее соглашение об именовании
При выполнении требований по названию методов, Spring Data JPA самостоятельно создаст запрос на основании имени метода. Например:
```java
	public interface ContactRepository extends CrudRepository<ContactEntity, Integer>{
	
		List<ContactEntity> findByFirstName(String firstName);
		List<ContactEntity> findByFirstNameAndLastName(String firstName, String lastName);
		
	}
```

для
```java
	findByFirstName(String firstName)
```

будет создан запрос
```java
	select c from ContactEntity where c.firstName = :firstName
```



- **JpaRepository** — это интерфейс фреймворка Spring Data предоставляющий набор стандартных методов JPA для работы с БД.

> Для чего вам может понадобиться Spring Data JPA — если нужно быстро в проекте создать Repository-слой базируемый на JPA, предназначенный в основном для CRUD операций, и вы не хотите создавать абстрактные DAO, интерфейсы их реализации, то Spring Data — JPA это хороший выбор.

Кастомный метод в Spring Data
```java
	public interface BankRepository extends JpaRepository<Bank, Long> {
	 
		@Query("select b from Bank b where b.name = :name")
		Bank findByName(@Param("name") String name);
	 
	}
```

Spring Data на основе предоставленых данных в аннотациях сам предоставит реализацию этого метода
```java
	@Override
	public Bank getByName(String name) {
		return bankRepository.findByName(name);
	}
```


```java
   /**
    *      mappedBy - свойство в ContactTelDetailEntity, связанное с внешнем ключом в этой таблице
    *       cascade - операция обновления должна распространяться на дочерние записи
    * orphanRemoval - после обновления, записи которых больше нет в наборе должны быть удалены из БД
    */
    @OneToMany(mappedBy = "contact", cascade = CascadeType.ALL, orphanRemoval = true)
    public Set<ContactTelDetailEntity> getContactTelDetailEntities() {
        return contactTelDetailEntities;
    }
```

```java
    @ManyToOne(fetch = FetchType.LAZY, cascade = {CascadeType.MERGE, CascadeType.PERSIST})
    @JoinColumn(name = "client_id", nullable = false)
    private Client client;
```

```java
	@ManyToMany
	@JoinTable(name = "contact_hobby_detail",
			//foreign key for ContactEntity in contact_hobby_detail table
			joinColumns = @JoinColumn(name = "contact_id"),
			//key for other side - hobby table
			inverseJoinColumns = @JoinColumn(name = "hobby_id"))
	public Set<HobbyEntity> getHobbies() {
		//TODO
    }
```



- **@Transactional** — аннотация...

Для использования аннотации @Transactional в Spring нужно добавить следующую строку в файл конфигурации Spring:

```xml
    <tx:annotation-driven transaction-manager="transactionManager"/>
```

Использование аннотации @Transactional

```java
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      @Transactional
      public long insertTrade(TradeData trade) throws Exception
      {
        em.persist(trade);
        return trade.getTradeId();
      }
    }
```

Проблемы с флагом read-only аннотации @Transactiona

```java
    /**
     * Использование read-only с режимом распространения транзакций SUPPORTS / JDBC — ничего не делает, поскольку задан режим распространения транзакций SUPPORTS
     * Использование read-only с режимом распространения REQUIRED / JDBC — генерирует исключение "read-only connection"
     * Использование read-only с режимом распространения REQUIRED / JPA — корректно вставляется заказ в БД и сохраняет данные без ошибок (при использовании ORM-фреймворка флаг read-only – это только подсказка для СУБД и директива для ORM-фреймворка)
     * Использование флага read-only и режима распространения SUPPORTS при операциях выборки данных — лучше вовсе избегать использования аннотации @Transactional при операциях чтения
     */
    @Transactional(readOnly=true, propagation=Propagation.SUPPORTS, rollbackFor=Exception.class)
    public long insertTrade(TradeData trade) throws Exception
    {
       //JDBC Code...

       //JPA Code:
       em.persist(trade);
       return trade.getTradeId();
    }
```

EJB работает с откатом транзакций иначе чем Spring Framework

```java
    /**
     * Аннотация @TransactionAttribute из спецификации EJB управлят поведением отката, нужно использовать метод `SessionContext.setRollbackOnly()`, чтобы пометить транзакцию для отката
     */
    @TransactionAttribute(TransactionAttributeType.REQUIRED)
    public TradeData placeTrade(TradeData trade) throws Exception
    {
       try {
          insertTrade(trade);
          updateAcct(trade);
          return trade;
       } catch (Exception up) {
          // запись ошибки в лог
          sessionCtx.setRollbackOnly();
          throw up;
       }
    }
```

***propagation*** — тип распространения транзакции ( *накштаут sql-блокировок только в Spring* )

|     | Атрибут        | Вызов вне транзакции             | Вызов внутри другой транзакции | Описание                                                                                                                    |
| --- | -------------- | -------------------------------- | ------------------------------ | --------------------------------------------------------------------------------------------------------------------------- |
| 1.  | `Mandatory`    | (`TransactionRequiredException`) | Будет использовать             | (Атрибут используется в стратегии клиентского дирижирования)                                                                |
|     |                |                                  |                                | Метод вызывается только в области видимости ранее начатой транзакции                                                        |
|     |                |                                  |                                | Если метод вызывается вне контекста транзакции то будет выброшено исключение (`TransactionRequiredException`)               |
|     |                |                                  |                                |                                                                                                                             |
| 2.  | `Required`     | Начнется новая                   | Будет использовать             | (Являющийся атрибутом по умолчанию в EJB и Spring)                                                                          |
|     |                |                                  |                                | Метод вызывается в области видимости ранее начатой транзакции                                                               |
|     |                |                                  |                                | В противном случае метод начнет новую транзакцию                                                                            |
|     |                |                                  |                                | Если метод запустил новую транзакцию то она должна завершиться этим методом                                                 |
|     |                |                                  |                                |                                                                                                                             |
| 3.  | `RequiresNew`  | Начнется новая                   | Всегда новая                   | Если метод был вызван в контексте другой транзакции то она будет прервана и будет начата новая транзакция                   |
|     |                |                                  |                                | При завершении метода новая транзакция подтверждается/откатывается и после возобновляется выполнение старой транзакция      |
|     |                |                                  |                                |                                                                                                                             |
| 4.  | `Supports`     | Не запустить транзакцию          | Будет использовать             | (Атрибут используется для операций чтения данных из базы)                                                                   |
|     |                |                                  |                                | Применяется к методу который вызывается в области видимости существующей транзакции (будет выполнен внутри этой транзакции) |
|     |                |                                  |                                | Если метод вызывается вне контекста транзакции то транзакция не будет начата вовсе                                          |
|     |                |                                  |                                |                                                                                                                             |
| 5.  | `NotSupported` | Выполнение вне контекста транзацкии                               | Метод не должен выполняться внутри транзакции: ни новой, ни уже существующей                                                |
|     |                |                                  |                                |                                                                                                                             |
| 6.  | `Never`        | Не запустить транзакцию          | (`RemoteException`)            | (Позволяет легко/быстро проверить существования транзакции в момент вызова некоторого метода)                               |
|     |                |                                  |                                | Ведет себя так же как (`NotSupported`)                                                                                      |
|     |                |                                  |                                | Если метод, отмеченный данным атрибутом, вызывается в контексте транзакции то выбрасывается исключение                      |

***readOnly*** — флаг транзакции только для чтения

***rollbackFor*** | ***rollbackForClassName*** — флаг транзакции для отката


---

######Платформа Java поддерживает 3-модели транзакций:

1 ***Модель локальных транзакций*** — эта модель применима при использовании DAO или JDBC-фреймворков и хранимых процедур СУБД (вы управляете подключениями, а не транзакциями)

```java
    public class TradingServiceImpl
    {
      public void processTrade(TradeData trade) throws Exception
      {
        Connection dbConnection = null;
        try
        {
          DataSource ds = (DataSource)
            (new InitialContext()).lookup("jdbc/MasterDS");
          dbConnection = ds.getConnection();
          dbConnection.setAutoCommit(true);
            Statement sql = dbConnection.createStatement();
            String stmt = "insert into TRADE ...";
            sql.executeUpdate(stmt1);
        }
        finally
        {
          if (dbConnection != null)
            dbConnection.close();
        }
      }
    }
```


2 ***Модель программных транзакций*** — вы управляете транзакциями и изолированы от нижележащий подключений к БД

```java
    /**
     * Программные транзакции в EJB 3.0
     */
    @Stateless
    @TransactionManagement(TransactionManagementType.BEAN)
    public class TradingServiceImpl implements TradingService
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      public void processTrade(TradeData trade) throws Exception
      {
        InitialContext ctx = new InitialContext();
        UserTransaction txn = (UserTransaction)ctx.lookup("UserTransaction");
        try
        {
          txn.begin();
            em.persist(trade);
            AcctData acct = em.find(AcctData.class, trade.getAcctId());
            double tradeValue = trade.getPrice() * trade.getShares();
            double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
          txn.commit();
        }
        catch (Exception up)
        {
          txn.rollback();
          throw up;
        }
      }
    }
```

```java
    /**
     * Использование менеджера транзакций JPA в Spring
     */
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      JpaTransactionManager txnManager = null;
      public void setTxnManager(JpaTransactionManager mgr)
      {
        txnManager = mgr;
      }

      public void processTrade(TradeData trade) throws Exception
      {
        TransactionStatus status = txnManager.getTransaction(new DefaultTransactionDefinition());
        try
        {
          em.persist(trade);
          AcctData acct = em.find(AcctData.class, trade.getAcctId());
          double tradeValue = trade.getPrice() * trade.getShares();
          double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
          txnManager.commit(status);
        }
        catch (Exception up)
        {
          txnManager.rollback(status);
          throw up;
        }
      }
    }
```


3 ***Модель декларативных транзакций*** — CMT (Container Managed Transactions) транзакции управляемые контейнером

```java
    /**
     * в EJB 3.0
     */
    @Stateless
    public class TradingServiceImpl implements TradingService
    {
      @PersistenceContext(unitName="trading") EntityManager em;
      @Resource SessionContext ctx;

      @TransactionAttribute(TransactionAttributeType.REQUIRED)
      public void processTrade(TradeData trade) throws Exception
      {
        try
        {
          em.persist(trade);
          AcctData acct = em.find(AcctData.class, trade.getAcctId());
          double tradeValue = trade.getPrice() * trade.getShares();
          double currentBalance = acct.getBalance();
          if (trade.getAction().equals("BUY"))
          {
            acct.setBalance(currentBalance - tradeValue);
          }
          else
          {
            acct.setBalance(currentBalance + tradeValue);
          }
        }
        catch (Exception up)
        {
          ctx.setRollbackOnly();
          throw up;
        }
      }
    }
```

```java
    /**
     * в Spring
     */
    public class TradingServiceImpl
    {
      @PersistenceContext(unitName="trading") EntityManager em;

      @Transactional(propagation=Propagation.REQUIRED,
        rollbackFor=Exception.class)
      public void processTrade(TradeData trade) throws Exception
      {
        em.persist(trade);
        AcctData acct = em.find(AcctData.class, trade.getAcctId());
        double tradeValue = trade.getPrice() * trade.getShares();
        double currentBalance = acct.getBalance();
        if (trade.getAction().equals("BUY"))
        {
          acct.setBalance(currentBalance - tradeValue);
        }
        else
        {
          acct.setBalance(currentBalance + tradeValue);
        }
      }
    }
```

---

- **JPQL** — в *JPQL* запросах мы оперируем объектами (а не таблицей).
---
    Всё SQL запросы JPA провайдер формирует сам. Поэтому в JPQL запросах вы работаете с полями объектов.
    JOIN-ы там тоже есть, но не так часто нужны, потому что простые JOIN-ы JPA сделает сам.


Например - здесь выбирается полностью объект (вся запись) а не два поля,
в JPQL запросе вы не пишете JOIN, просто сравниваете свойство объекта `User` у которого есть `UserInfo` в котором указан искомый адрес

```sql
    SELECT u FROM User u WHERE u.info.email = 'mail.server.com'
```


