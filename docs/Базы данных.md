
#Sybase PowerDesigner

* [Проектирование БД](http://www.sql.ru/forum/483726/vse-voprosy-po-sybase-powerdesigner-pd-chast-3) 
**(** [PowerDesigner](https://www.sybase.ru/products/powerdesigner) **|** [novye_vozmozhnosti_pd_16_5](novye_vozmozhnosti_pd_16_5.pdf) **)**
* [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **(** [pd_bpm_29-06-2005](pd_bpm_29-06-2005.pdf) **)**
* [PowerDesigner Web](pdweb_ru.pdf)

#Spring Data
* `Spring Data JPA` — банковская система управления клиентами: **(** [Часть 1](http://devcolibri.com/3966) **|** [Часть 2](http://devcolibri.com/4149) **)**
* `Spring Data JPA` — [пример приложения Hello World](http://javastudy.ru/spring-data-jpa/spring-data-jpa-helloworld/) **(** [Hello World](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-Hello-World.rar) **|** [SQL](http://javastudy.ru/wp-content/uploads/2015/10/Spring-Data-JPA-helloWorld-SQL.rar) **)**
* [org.springframework.data.repository.CrudRepository](https://m.habrahabr.ru/post/139421)

---

- **DAO** (Data Access Object) — это слой объектов которые обеспечивают доступ к данным.
- ( **EntityManager** - используется для реализации DAO и с его помощью мы работаем с нашей БД )
- **Repository** — *Spring Data* предоставляет набор готовых реализаций для создания DAO.

######Доменный слой (ближе всего к базе)
Этот слой находится на самом низком уровне, он обеспечивает конкретную реализацию соединения и работу с SQL-методами `на физическом уровне` согласно спецификации для каждного отдельного типа базы данных.

######DAO слой (DAO/Repositories - для обеспечение доступа к данным)
Это такой себе абстрактый слой, который (`независимо от типа базы данных `) позволяет одинаково использовать SQL-методы для всех баз данных...

######Сервисный слой (Бизнес-Логика)
(И Доменный-слой, и DAO-слой - реализовываются только для каждой отдельной, одной, таблицы)
Сервисный слой используется для выполнения сожных транзакций, учитывая несколько операций и таблиц одновременно...
И если что-то пошле не так - именно на этом уровне можно либо подтвердить либо отменить все транзакции (согласно плану бизнес-логики)


В `resources` есть файл **app.properties**
```properties
#DB properties:
db.driver=com.mysql.jdbc.Driver
db.url=jdbc:mysql://localhost:3306/testdb
db.username=root
db.password=root
 
#Hibernate Configuration:
db.hibernate.dialect=org.hibernate.dialect.MySQLDialect
db.hibernate.show_sql=true
db.entitymanager.packages.to.scan=com.devcolibri.dataexam.entity
db.hibernate.hbm2ddl.auto = create
```

######Разберем аннотации:
> **@Configuration** — говорит, что данный класс является Spring конфигурацией;
> **@ComponentScan**("com.devcolibri.dataexam") — указываем Spring где нужно искать Entity, DAO, Service и т.п.;
> **@PropertySource**("classpath:app.properties") — подключаем файл свойств созданный выше;

- **@EnableTransactionManagement** — включает TransactionManager для управления транзакциями БД;
- **@EnableJpaRepositories**("com.devcolibri.dataexam.repository") — включаем возможность использования JPARepository и говорим, где их искать;
- **@Repository** — является абстракция репозитория Spring Data, представляет оболочку вокруг базового интерфейса JPA EntityManager и предлагает более широкие возможности для доступа к данным;
- **@Transactional** — методы помеченные этой транзакцией автоматически выполняют *commit* или *rollback* по результату...
- **@Query** — которая позволяет создать SQL запрос

<!-- Have Spring servlet handle all static content -->
<mvc:annotation-driven/>

<!--@Transaction annotation support -->
<tx:annotation-driven transaction-manager="transactionManager"/>

<!--Activates various annotations to be detected in bean classes: Spring's @Required and @Autowired and so on-->
<context:annotation-config/>

```java
   /**
    * mappedBy - свойство в ContactTelDetailEntity, связанное с внешнем ключом в этой таблице
    *  cascade - операция обновления должна распространяться на дочерние записи
    *  orphanRemoval - после обновления, записи которых больше нет в наборе должны быть удалены из БД
    */
    @OneToMany(mappedBy = "contact", cascade = CascadeType.ALL, orphanRemoval = true)
    public Set<ContactTelDetailEntity> getContactTelDetailEntities() {
        return contactTelDetailEntities;
    }
```

```java
	@ManyToOne
	@JoinTable(name = "contact_hobby_detail",
			//foreign key for ContactEntity in contact_hobby_detail table
			joinColumns = @JoinColumn(name = "contact_id"),
			//key for other side - hobby table
			inverseJoinColumns = @JoinColumn(name = "hobby_id"))
	public Set<HobbyEntity> getHobbies() {
		//TODO
    }
```


- **CrudRepository** — центральный интерфейс из Spring Data. Наследовавшись от *org.springframework.data.repository.CrudRepository* вы получили возможность вызывать такие методы как (без необходимости реализовывать их имплементировать):

> save
>
> findOne
>
> exists
>
> findAll
>
> count
>
> delete
>
> deleteAll


######Общее соглашение об именовании
При выполнении требований по названию методов, Spring Data JPA самостоятельно создаст запрос на основании имени метода. Например:
```java
	public interface ContactRepository extends CrudRepository<ContactEntity, Integer>{
	
		List<ContactEntity> findByFirstName(String firstName);
		List<ContactEntity> findByFirstNameAndLastName(String firstName, String lastName);
		
	}
```

для
```java
	findByFirstName(String firstName)
```

будет создан запрос
```java
	select c from ContactEntity where c.firstName = :firstName
```

- **JpaRepository** — это интерфейс фреймворка Spring Data предоставляющий набор стандартных методов JPA для работы с БД:
Кастомный метод в Spring Data
```java
	public interface BankRepository extends JpaRepository<Bank, Long> {
	 
		@Query("select b from Bank b where b.name = :name")
		Bank findByName(@Param("name") String name);
	 
	}
```

Spring Data на основе предоставленых данных в аннотациях сам предоставит реализацию этого метода
```java
	@Override
	public Bank getByName(String name) {
		return bankRepository.findByName(name);
	}
```






















