
Я разработчик ПО с четырех-летним стажем.
Я специализируюсь в области Java.
Мне приходилось разрабатывать разного рода приложения:
- десктопные Java приложения;
- мобильные Java приложения;
- веб приложения;
Я разрабатывал ПО с помощью следующих языков программирования: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS...

Моим первым местом работы была компания HostingMax.
Это было в 2007-2008 году.
Моими обязаностями являлось разработка мобильных игр для мобильных платформ (Nokia, Samsung, Simens, Alkatel, BlackBarry..).
Здесь я познакомился и изучил технологии J2ME, (Java Media Framework, Mobile Information Device Profile).
А также я разрабатывал мобильную службу SyncML для синхронизации и восстановления персональных данных в мобильных устройствах.

Последним моим местом работы является компания ПриватБанк.
Это было в 2012-1016 год.
Моими обязанотями являлось разработка веб-сервисов для банковских услуг.
Здесь применялись технологии: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
Использовались базы данных MySQL, IQ/ASE, Redis, MongoDB.
Я самостоятельно вел разработку одного отдельного проекта (это корпоративный проект).
И был участником в группе где разрабатывались разные веб-сервисы (это сервлеты, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
Программный код покрывался JUnit, JMock и DBUnit тестами.
Также для глобального тестирования применялись инструменты: SonarQube, SoapUI, JMeter.
В приложении было включено логирование (Log4j).

Кроме веб-сервисов я разрабатывал библиотечные классы (которые потом использовались этими веб-сервисами).
Все разработки велись на Linux системе.
В качестве сборщика использовал ANT, Meven.
Системы контроля версий SVN, GIT.

Более всего мне запомнился проект сервиса для платежной системы.
Здесь применялись технологии: Java-7, Spring-3 (Data/Security/MVC/REST), (ORM-framework) JPA/Hibernate-3
База данных IQ, PostgreSQL.
Этот сервис использовал LiqPay.
Требовалось разработать библиотечные классы для применнеия этим приложением.
Общение с сервисом внутри приложения выполнялось через SOAP-протокол.


+++++++++++++++++++
I'm a software developer with five-years of experience.
Have spent last four years I development my job skills to a bank systems and I was promoted to the strong middle level.
My first job was development of mobile applications for at HostingMax company.
I'm a team player and I can control a small team.
Although I love my current role, but I feel that now I'm ready for a more challenge assignment.

It is hard to speak about myself as only people surrounding me can see me objectively.
I can summarize my professional qualities:
- I'm hardworker;
- I'm quiet worker for some stress cases;
- I have an open mind about what will work best;
- I be attention to all details;
- I can successfully able to keep deadlines;
- I can fast-learner, I'm self-motivated and I'm determined;

I have my history stable of work.
I'm think that one of my greatest strengths is solve challenge for technical problems.
I have the ability to see some situation for different perspectives and I can get my work done even in the face of difficult obstacles.

Nobody is perfect.
I'm impatient to team members who are make mistakes or do wrong work.


+++++++++++++++++++
+++++++++++++++++++
I'm a software developer with five-years of experience.
My specialize is into area of Java/JavaScript and Scala.
I have development skills to different kinds of applications:
- The desktop Java applications;
- The mobile Java applications;
- And the web applications;
I use that programming languages: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS for some soft development.

My first job was the "HostingMax" company.
It was start in the twenty and seven, and finish twenty and eight year. (2007-2008)
My responsibility was development some mobile games for many mobile platforms (Nokia, Samsung, Simens, Alkatel, BlackBarry).
There I acquainted and learned J2ME technology, (Java Media Framework, Mobile Information Device Profile).
And I developed a SyncML mobile service for synchronization and restoration of a personal data into some mobile devices.

My last place of work was the "PrivatBank" company.
It was start in the twenty and twelf, and finish twenty and sixteen year. (2012-2016)
My responsibility was development of web-services for bank systems.
There used technologyies: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
We used few database: MySQL, IQ/ASE, Redis, MongoDB.
I was alone of independent developer of one project (this corporate project).
And I was a team member for developed various web services (It servlets, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
There is code has test cover JUnit, JMock and DBUnit tests.
Also used tools for global testing: SonarQube, SoapUI, JMeter.
Apps have got a logging system (it Log4j).

Addition I developed some library classes (which are then used by these web services).
All developments were on Linux system.
ANT and Maven was a builder-tools.
SVN and GIT was a version control systems.

It is hard to speak about myself as only people surrounding me can see me objectively.
I can summarize my professional qualities:
- I'm hardworking;
- I'm quiet working when stress cases;
- I have an open mind about what will work best;
- I be attention to all the details;
- I can successfully able to keep deadlines;
- I can fast-learner, I'm self-motivated and I'm determined;

I have a stable my history of work.
I'm think that one of my greatest strengths is solve challenge of technical problems.
I have the ability to see a situation from different perspectives and I can get my work done even in the face of difficult obstacles.

Nobody is perfect.
I'm impatient to team members who are make mistakes or do wrong work.

> Рассказать об одном из проектов который больше всех остальных мне запомнился ?
  Я принимал участвие в коммерческом проекте по публицированию объявлений.
  В частности я занимался разработкой системы авторизации + сыстемы оплаты + системы для резервирования заказов.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  Most of all I remember the service project for payment system.
  There used technologyies: Java-7, Spring-3 (Data/Security/MVC/REST), ORM-framework (JPA/Hibernate-3)
  Database: IQ, PostgreSQL, Redis.
  This service was use LiqPay.
  Was necessary develop library classes for use into this application.
  Data communication with the service performed within the application throus SOAP-protocol.
> Я занимаюсь автомобильным спортом.
  Участвую в соревнованиях на картингах на коротких и длинных дистанциях.
  Иногда мы собираемся с друзьями в команду и проводим соревнование между собой.
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  My hobby is auto sport.
  Some times I take part to mini auto racing
  Some times I take part to compete auto racing together vs my frends.
  Often we choose different tracks for the competition.
  Some times we are organize to competes on impassability of roads. For example on a mountains place.
  I think it is very intetesting and beautiful. The environment nature.
  We get a lot of impressions.
  And yet I am a subscriber to the magazine sports.
  I read and on find news in the world of auto sport.
> Tell me about polymorphism, encapsulation and inheritance in Java?
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  The paradigm of object oriented programming is based on three fundamental concepts: encapsulation, inheritance and polymorphism.
     ( Abstraction - this is the allocation of the main features, without going into details and details )
  1. Polymorphism - it is posybylyty for any one interface has various implementations.
     ( это возможность одного интерфейса иметь различные реализация )
	 ( Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding) )
  2. Encapsulation - 
     ( сокрытие реализации )
     ( Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов, доступные в соответствии модификаторов доступа )
	 ( Реализация методов недоступна )
  3. Inheritance - 
     ( возможность создавать обобьет на основании другого объекта )
	 ( Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя )
> Какие существуют области памяти в Java ?
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
    управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	стэковая память существует лиш на короткое время для работы отдельной под-программы
	стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	"java.lang.StackOverflowError" (если память стэка заполнена)
	"-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	всякий раз когда создается объект - он хранится в куче
	объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	память в куче живет с самого начала до самого конца работы программы
	"java.lang.OutOfMemoryError" (если память кучи заполнена)
	"-Xms" и "-Xmx" (опции JVM определить размер памяти кучи)
    -- "Perm-anent Gen-eration" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
	-- "Heap" (сама куча)
	   --- Новая куча
	       ---- "Eden Space" (молодое поколение - сюда попадают все новосозданные объекты)
		   ---- "Survivor Space" (сюда попадают выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
	   --- Старая куча
	       ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + 
> В русском языке можно оперировать окончаниями:

> В английском языке можно оперировать только (состоянием + порядок слов):
  + Есть | Является (внутренее состояние)
  + Имеет (владеть)
  + Быть (место - there is|are...; это не может быть - it can't be; это не еально - it's not really; но что есть реальность - but what is a really;) 
  + Делаю (Выполняется - в процессе) | Занимаюсь (мое хобби есть..., я есть IT-разработчик, ...) | Брать (принимать участие | брать уроки, ...)
  + Сделано (уже выполнено) | Получить
> Плюс такие себе союзы, чтобы связывать части сложного предложения:
  + and | of | for | from | in | that | what | to (into | out to) | even | ...
  
  
  age ............... возраст
  young ............. молодой
  old ............... старый
  edge .............. край
  space ............. пространство
  area .............. область (площадь)
  a young space - молодое поколение
  a old space - старое поколение
  
  yet | still ....... еще (все еще)
  already ........... уже
  live .............. живой
  still alive ....... еще живой
  survive ........... выживать
  
  state ............. состояние
  static ............ неподвижный
  stop (stoping) .... остонавливаться (прекращать)
  stand ............. стоять (на ногах)
  freeze ............ замерзать
  constant .......... постоянный
  ( static state - неподвижное состояние )
  
  middle ............ средний
  middleware ........ промежуточное ПО
  broker ............ посредник
  transit (transition) - переход (переходный период)
  
  current ........... текущий
  duration .......... продолжительность
  ( Персистентность — продолжительность сохранения, активности в окружающей среде )
  persistent - непрерывно возобновляющийся (persistent object - постоянный объект)
  
  fall .............. падать
  broke ............. ломать
  thought ........... через (сквозь)
  something that broke thought insite me (some broke throught for me) - что-то прорвалось во мне
  
  Быть
  ----
  > I can be... ..... находиться (пребывать) в каком-нибудь внутреннем состоянии
  > There is|are... . находиться (пребывать) в каком-нибудь физическом месте
  I can be a strong - Я могу быть сильным
  I will a strong (I'll a strong) - Я буду сильным
  I will become a strong (I'll become a strong) - Я стану сильным
  Now I in London (Now I'm in London) - сейчас я в Лондоне.
  But tomorrow I'll in Egypt - но завтра я буду в Египте

  

предмент / вещь ................ thing
какой-нибудь предмент / вещь ... something
кто-нибудь ..................... anybody
там ............................ there
себя ........................... myself
тебя ........................... yourself
его ............................ himself
иногда ......................... sometime
однажды ........................ one time
следующий раз .................. next time
+++++
anywhere ....................... нигде
somebody .......................  кто нибудь (много)
anyone, anybody ................ никто, любой (ниодин)
There is a great difference between her wishes and his possibilities   ( ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями )
  

> Например:
  + Я могу выполнять задачи вовремя даже в случае возникновения сложностей...
       I can give my work done even in the face difficult obstacles... (я могу получить свою работу успешно даже перед лицом сложных препятствий)
  + стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче
       стэк есть (является) областью памяти для локальных примитивных типов и ссылочных типов из области кучи
	   The stack is some memmory area for a locale of type primitive and a link type into at heap.
  + управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
       управление памятью использует схему LIFO (если первый является вошедшим - тогда он будет последним на выход)
	   The memmory control used a LIFO shema (if some first item is entered then his will last item for output)
  + стэковая память существует лиш на короткое время для работы отдельной под-программы
       стэковая память имеет (владеет) коротким временнем для отдельного процесса под-программы
	   The memmory area has the short time for separate of a programm process.
  + стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
       стэк имеет только один поток для запущенной программы (стэковая память не имеет доступ для других потоков)
	   The stack has only one thred for a runner programm (some area of stack memmory ish't available for another threads).

>> (Q&A: color VS caller VS collar (American Pronunciation)) https://www.youtube.com/watch?v=TgGvXPHGs1I
   (Bus or Boss? Luck or Lock? American English Pronunciation) https://www.youtube.com/watch?v=MqcCCFptaJk
   
>>> (Q&A: Sounds Animals make (in America!)) https://www.youtube.com/watch?v=tk9XVUyHDns&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D&index=115
>>> (Q&A: V and W sounds: They're VERY different!!) https://www.youtube.com/watch?v=0PkfYnDpdfA&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D&index=116
>>> (Q&A: isn't-idn't, wasn't-wadn't, hasn't-hadn't, doesn't-doedn't, business-bidness, tisn't-tidn't) https://www.youtube.com/watch?v=Ezi2D8Apjh4&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D&index=124
>>> (Q&A: R and L tongue exercise! Red lorry, Yellow lorry (a tongue twister)) https://www.youtube.com/watch?v=lmVLUxCO0DU&index=130&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D
>>> (Q&A: ing + ing: Pronunciation--brING+ING, sING+ING, etc.!!) https://www.youtube.com/watch?v=EDUVllYKmIc&index=136&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D
+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + 

+++++++++++++++++++
+++++++++++++++++++
+++++++++++++++++++
> I'm go for motor sports.
  I participate on sports events for karting in a short and long distances.
  Sometimes we're going with friends to the team and to hold competitions among themselves.
  Often competitions we choose different routes. And in this way the results of each new sorrevnovaniya become unpredictable.
  Once we collect the team for leisure tourism.
  There we arrange check-ATV on the road, on a hilly terrain.
  It is very interesting and very beautiful.
  Also we can observe different views on the nature.
  We get pleasure from these trips and share with each other svomi vpechetlenie.
> My hobby - collecting various car radio models.
  and one month and one year can be spent on the assembly of each model.
  It is often difficult to find a specific item for a specific car model.
  Sometimes you do this part yourself.
  It often happens that bad sdlelannaya car radio model breaks down on the road while driving.
  So I stock up on spare parts for each model of car.
  I like to collect traditional and classic car models with petrol engines.
  It is very delicate work and requires a lot of attention and precision execution. And patience for the long time spent on the creation of each model.
  But I like it a lot.
> I often watch TV programs on the organization of sports-car championships rolleynyh sorrevnovany between passenger and freight categories for short and long distances.
  And as I watch television and other auto shows, for example: Top Gear.
  I subscribe and read sports magazines Motorsport.


В последнее время я участвовал в разрабатке проекта электронного магазина.
Я сам выбирал технологии которые нужно было приемнить для реализации задач бизнеса.
В состав этого электронного магазина входили модули:
- оплата
- авторизации
- банкинг
- система резервации
- AngularJS (1)
-

> Рассказать об полиморфизме, инкапсуляции и наследованию в Java ?
  http://java-se-learning.blogspot.com/2013/07/blog-post_4.html
  Парадигмы объектно ориентированного программирования Java основаны на трёх основополагающих концепциях, называемых абстракция, инкапсуляция, наследование и полиморфизм.
  1. Абстракция - выделение важных особенностей, характеристик объекта, главным образом отличающего его от других объектов. Выделение главных особенностей, не вдаваясь в в подробности, не вдаваясь в детали.
  2. Полиморфизм - возможность одного интерфейса иметь различные реализация. Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Инкапсуляция - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Наследование - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
  --------------------------------------
  https://jsehelper.blogspot.com/2016/01/java-core-1.html
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
    управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	стэковая память существует лиш на короткое время для работы отдельной под-программы
	стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	"java.lang.StackOverflowError" (если память стэка заполнена)
	"-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	всякий раз когда создается объект - он хранится в куче
	объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	память в куче живет с самого начала до самого конца работы программы
	"java.lang.OutOfMemoryError" (если память кучи заполнена)
	"-Xms" и "-Xmx" (опции JVM определить размер памяти кучи)
    -- "Perm-anent Gen-eration" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
	-- "Heap" (сама куча)
	   --- Новая куча
	       ---- "Eden Space" (молодое поколение - сюда попадают все новосозданные объекты)
		   ---- "Survivor Space" (сюда попадают выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
	   --- Старая куча
	       ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
> Какие методы есть у класса Object?
  ---------------------------------
  https://jsehelper.blogspot.com/2016/01/java-core-2.html
  1. public final native Class getClass()
  2. public native int hashCode()
  3. public boolean equals(Object obj)
  4. protected native Object clone() throws CloneNotSupportedException
  5. public String toString()
  6. public final native void notify()
  7. public final native void notifyAll()
  8. public final native void wait(long timeout) throws InterruptedException
  9. public final void wait(long timeout, int nanos) throws InterruptedException
  10. public final void wait() throws InterruptedException
  11. protected void finalize() throws Throwable
> Исключения?
  ----------
  >> https://jsehelper.blogspot.com/2016/01/java-core-3.html
  >> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L1025
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	 * Исключения - это наследники класса 'Throwable':
	 *              Error (системные ошибки при работе виртуальной Java-машины... - StackOverFlowError, OutOfMemoryError) - такие ошибкиm безсмысленно обрабатывать
	 *              Exception >> 'Checked' (проверяемые исключения - FileNotFoundException, IOException, InterrupdetException) - такие исключения/ошибки НЕвозможно ранее предугадать в программе, поэтому их обизательно нужно обрабатывать
	 *              RuntimeException >> 'Unchecked' (НЕпроверяемые исключения - NullPointerException, ArrayIndexOutOfBundlesException, ConncurrentModificationException, ClassNotFoundException, IllegalTypeException, ClassCastException, ArithmeticException) - такие исключения/ошибки можно и нужно предугадать в программе (их нет нужды обрабатывать)
	 * сигнатура throws... - помечаем в момент описания/определения метода который может выбросить исключение
	 * try/catch/finally - используем в момент вызова метода (который может выбросить исключение) когда мы сами хотим обрабатывать это исключение
	 *
  >> D:\IdeaProjects\spring\SpringFileUpload_restore\3\SpringFileUpload\src\test\java\com\journaldev\spring\TryCatchFinaly.java
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	 * - сперва отработает блок-try, только до оператора 'return'
	 *   (если блок-try свалиться, тогда вместо него сперва отработает блок-catch, только до оператора 'return')
	 * - после этого выполнение перейдет к блоку-finally
	 *   (в любом случае первым будет вызван оператор 'return' который из блока-finally)
	 * - если оператор 'return' в блоке-finally отсутствует тогда, следующим может вызван оператор 'return' который из блока-try (или на случай когда блок-try свалиться, тогда вместо него следующим может вызван оператор 'return' из блока-catch)
	 * - если оператор 'return' в try/catch/finally отсутствует, только тогда последним будет вызван оператор 'return' который в конце тела функции
	 * try/catch/finally >>> иерархия вызова:
	 * * * * * * * * * * * * * * * * * *
	 * Здесь если в блоке 'try' будет выброшено исключение - тогда программа прервется и передаст выполнение в блок 'catch' - где условия программы ГАРАНТИРОВАННО будет выполнена...
	 * Если есть список блоков 'catch' - тогда выбран будет только один, первый подходящий catch из списка (больше ничего)
	 * Дальше выполниться блок 'finally'
	 * *********************************
	 * Если внутри блока 'catch' бросить исключение - тогда блок 'finally' никогда невыпониться (программа просто прервется...)
	 * Если блоки 'try/catch' будут вложены их будет много - тогда исключение перейдет к внешнему блоку 'catch'
	 * *********************************
	 * Если внутри блока 'finally' бросить исключение - тогда программа просто прервется...исключение перейдет к внешнему блоку 'catch'
	 * *********************************
	 * Множество 'catch' блоков - это такой себе список кейсов - из которого (по типу исключения) будет выбран только один (остальные НЕбудут выполнены)!
	 * Дальше будет выполнен блок 'finally' (если тактой есть)
> Рассказать об одном из проектов который больше всех остальных мне запомнился ?
  Я принимал участвие в коммерческом проекте по публицированию объявлений.
  В частности я занимался разработкой системы авторизации + сыстемы оплаты + системы для резервирования заказов.
> Я занимаюсь автомобильным спортом.
  Участвую в соревнованиях на картингах на коротких и длинных дистанциях.
  Иногда мы собираемся с друзьями в команду и проводим соревнование между собой.
  - - - - - - - - - - - - - - - - - - - - - - - - [ lot/many/any ]
  Some times I take part to mini auto racing

  My hobby is auto sport.
  I take part to mini auto racing.
  Some times I vs my frends, together to competes auto racing on track.
  Frequency we to choose various tracks for the compete.
  Some times we are organize to competes on impassability of roads. For example on a mountains place.
  I think it is very intetesting and beautiful. The environment nature.
  We get a lot of impressions.
  And yet I am a subscriber to the magazine sports.
  I read and on find news in the world of auto sport.

  Я беру участие в автомобильных соревнованиях вместе с моими друзъями.
  I take part to compete auto racing together vs my frends.
  - - - - - - - - - - - - - - - - - - - - - - - -





*   >>> http://lelang.ru/english/series/garri-potter-i-filosofskij-kamen-na-anglijskom-s-subtitrami/
>>      http://iloveenglish.ru/stories/view/pishem_interesnij_rasskaz_o_sebe_na_anglijskom
>> (EnglishLessons4U - Learn English with Ronnie) https://www.youtube.com/channel/UC4cmBAit8i_NJZE8qK8sfpA
*** >>> http://vasabi.tv/video/341-harry-potter-and-the-philosophers-stone/
        http://vasabi.tv/user/profile/admin/
		http://vasabi.tv/video/91-breaking-bad-sezon-1-epizod-1/
*   >>> (harry-potter-and-the-philosopher's-stone books) http://www2.sdfi.edu.cn/netclass/jiaoan/englit/download/Harry%20Potter%20and%20the%20Sorcerer's%20Stone.pdf
+ + + + + + + + + +
+ + + + + + + + + +
>> (5 простых правил порядка слов в английском) http://skyeng.ru/articles/5-prostyh-pravil-poryadka-slov-v-anglijskom
                                                https://www.native-english.ru/grammar/word-order
											  ( http://online-teacher.ru/study/english-predlogi-mesta )

|ОБСТОЯТЕЛЬСТВО МЕСТА-ВРЕМЕНИ| + [ПОДЛЕЖАЩЕЕ-СУЩЕСТВИТЕЛЬНОЕ] + [СКАЗУЕМОЕ-ГЛАГОЛ] + |ДОПОЛНЕНИЕ-ПРИЛАГАТЕЛЬНОЕ СУЩЕСТВИТЕЛЬНОЕ| + |ОБСТОЯТЕЛЬСТВО МЕСТА/ВРЕМЕНИ-ПРИЛАГАТЕЛЬНОЕ|

We (подлежащее) do (сказуемое) our work (дополнение) with pleasure (обстоятельство места и времени).
Мы [существительное] делаем [глагол] нашу работу [дополнение-существительное] с удовольствием [прилагательное].

At the moment I cannot talk.
В настоящий момент я не могу говорить.
В настоящий момент (дополнение-места/времени) ... я (кто?) не могу (дополнение) говорить (что делать?)

There is a great difference between her wishes and his possibilities.
ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
= = = = =
(что?) ... существует (что делает?) огромная (какая?) разница (дополнение-что?) ...





   Сами по себе слова, в английском языке, вообще ничего не обозначают:
   0. (Физический, неодушевленный) предмет
   .. Название предмета
      The <ЧТО>.

   .. Направленное (обращение к) действие
      To <ЧТО ДЕЛАЕТ>

   Именно структура предложения, в английском языке, описывает какое-то действие:
   1. (Иннициатор действия) кто-то / что-то
      <ПОДЛЕЖАЩЕЕ>
	  оно ................. it

   2. (Бытие) действие
      <СКАЗУЕМОЕ>
	  есть ................ is

   3. (Абстрактное, куда направленное действие: вещь-место-время) о чем либо / где-то / когда-то
	  вещь ................ thing
	  какая-нибудь вещь ... something
	  кто-нибудь .......... anybody
	  там ................. there
	  себя ................ myself
	  тебя ................ yourself
	  его ................. himself
	  иногда .............. sometime
	  однажды ............. one time
	  следующий раз ....... next time

   4. Форма простого предложения
      <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ> + <ДОПОЛНЕНИЕ>.
	  или
	  <ДОПОЛНЕНИЕ> + <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ>.
	  -----------------------------------------
	  <ИНИЦИАТОР: КТО> + <ДЕЙСТВИЕ: ЧТО ДЕЛАЕТ> + <ВЕЩЬ|МЕСТО|ВРЕМЯ: КУДА НАПРАВЛЕННО ДЕЙСТВИЕ>.
	  или
	  <ВЕЩЬ|МЕСТО|ВРЕМЯ: КУДА НАПРАВЛЕННО ДЕЙСТВИЕ> + <ИНИЦИАТОР: КТО> + <ДЕЙСТВИЕ: ЧТО ДЕЛАЕТ>.
      Я пишу книгу.
	  Кто-то есть там. (Там кто-то есть).

   5. Полная форма предложения
      (ОБСТ-ВО МЕСТА|ВРЕМЕНИ) + <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ> + <(ДОПОЛНЕНИЕ...) || (ОБСТ-ВО ДЕЙСТВИЯ|МЕСТА|ВРЕМЕНИ)>.
	  ------------------------------------------------------------------------------------------------------------
	  <КТО> + <ЧТО ДЕЛАЕТ> + <КУДА НАПРАВЛЕННО ДЕЙСТВИЕ> + <ДОПОЛНЕНИЕ>.

   ++++++++++
   6. Если, в английском языке, предложение неполное где нехватает либо ПОДЛЕЖАЩЕГО или СКАЗУЕМОГО или ДОПОЛНЕНИЯ
      - тогда в этом случае добавляем абстрактное и <ПОДЛЕЖАЩЕЕ> (иннициатора действия) и <СКАЗУЕМОЕ> (бытие действие):
   ---
   Я - Саша.
   Мое имя есть Саша.
   ---
   Позвольте представиться.
   (Позвольте мне представиться?) Позвольте мне информировать о себе?
   ---
   Сложно описать себя.
   Это есть сложно чтобы описать себя.
   ---
   Вообще-то говорить о себе много хороших слов не слишком-то скромно...
   <ДЕЙСТВИЕ ПО НАПРАВЛЕННОЮ К> говорить (много) хороших слов <УТОЧНЕНИЕ> о себе <СКАЗУЕМОЕ> является очень не скромно
   ---
   Самое сложное – это рассказать о себе что-то объективное...
   The most difficult thing is to tell something objective about myself...
   ---
   Кто-нибудь собирается послушать мою историю?
   (кто-то есть там | там кто-то есть) есть там кто-то?
     что-то собираться (сделать) послушать
	   (что...) моя история
   ---
   Непросто говорить о себе
   (непросто=сложно) это есть сложно
     (...делать для) говорить об

   ++++++++++
   ---
   Я - Саша.
   Меня зовут Саша.
   Мое имя есть Саша. == My name is Sasha.
   ---
   Позвольте представиться.
   (Позвольте мне представиться?)
   Вводить в курс oб / информировать...
   Позвольте мне ввести о себе. == Let me introduce myself.
   ---
   Сложно описать себя.
   Это есть сложно чтобы описать себя.
   It is difficult to describe myself.
   ---
   Вообще-то говорить о себе много хороших слов не слишком-то скромно...
   (ДЕЙСТВИЕ ПО НАПРАВЛЕННОЮ К) говорить (много) хороших слов (УТОЧНЕНИЕ) о себе  является очень не скромно == To tell many good words about yourself is not very modest...
   ---
   Самое сложное – это рассказать о себе что-то объективное...

   The most difficult thing is to tell something objective about myself...
   ---
   Кто-нибудь собирается послушать мою историю?
   (кто-то есть там | там кто-то есть) есть там кто-то?
     что-то собираться (сделать) послушать
	   (что...) моя история
   Is there anybody going to listen to my story?
   ---
   (собирается послушать = going to listen)
   ---
   Непросто говорить о себе
   (непросто=сложно) это есть сложно
     (...делать для) говорить об
   It is hard to speak about myself

   поскольку только люди со стороны могут видеть меня объективно
   (люди со стороны) окружающие меня люди
     видеть (могут видеть)
	   объективно (я объективный)
   people surrounding me can see me objectively

   Непросто говорить о себе, поскольку только люди со стороны могут видеть меня объективно.
   It is hard to speak about myself as only people surrounding me can see me objectively.
  - - - - - - - - - - - - - - - - - - - - - - - -
  Часто для соревнованиях мы выбираем разные трассы. И таким способом результаты каждого нового сорревнования становятся непредсказуемым.
  Еще мы собираем команду для туристического отдыха.
  Там мы устраиваем заезд на квадроциклах по бездорожью, по гористой местности.
  Это очень интересно и очень красиво.
  Также мы можем наблюдать разные пейзажи на природе.
  Мы получаем удовольствие из таких поездок и делимся между собой своми впечетлениями.
> Мое хобби - собирать разные радио-модели автомобилей.
  На сборку каждой модели можно потратить и один месяц и один год.
  Часто бывает сложно найти специфическую деталь для конкретной модели автомобиля.
  Иногда приходиться эту деталь делать самому.
  Часто бывает что плохо сдлеланная радио-модель автомобиля ломается на дороге во время езды.
  Поэтому я запасаюсь запасными деталями для каждой модели автомобиля.
  Я нравится собирать традиционные и классические автомобильные модели, с бензиновыми двигателями.
  Это очень тонкая работа и требует большого внимания и высокой точности выполнения. А также и терпение к длительному времени потраченому на создание каждой модели.
  Но мне это очень нравится.
> Я часто смотрю телепередачи о проведении спортивных чемпионатов авто-роллейных сорревнований между легковыми и грузовыми категориями, на коротких и длинных дистанциях.
  А также я смотрю и другие телевизионные авто-шоу, например: Топ-Гир.
  Подписываюсь и читаю спортивные журналы по автоспорту.
>
>
>
> Мне ненравиться когда нарушаются ранее оговоренные сроки выполнения заданий.......
  Когда срывается план работы из-за плохо спланированых действий......

> Tell me about polymorphism, encapsulation and inheritance in Java?
  Paradigm of object oriented programming is based on three fundamental concepts: encapsulation, inheritance and polymorphism.
  1. Abstraction - this is the allocation of the main features, without going into details and details.
  2. Polymorphism - это возможность одного интерфейса иметь различные реализация.     it is posybylyty for any one interface has various implementations.     Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Encapsulation - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Inheritance - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
> I am go in for motor sports.
  I participate on sports events for karting in a short and long distances...........................................
  Sometimes we're going with friends to the team and to hold competitions among themselves.
  Often competitions we choose different routes. And in this way the results of each new sorrevnovaniya become unpredictable.
  Once we collect the team for leisure tourism.
  There we arrange check-ATV on the road, on a hilly terrain.
  It is very interesting and very beautiful.
  Also we can observe different views on the nature.
  We get pleasure from these trips and share with each other svomi vpechetlenie.
> My hobby - collecting various car radio models.
  and one month and one year can be spent on the assembly of each model.
  It is often difficult to find a specific item for a specific car model.
  Sometimes you do this part yourself.
  It often happens that bad sdlelannaya car radio model breaks down on the road while driving.
  So I stock up on spare parts for each model of car.
  I like to collect traditional and classic car models with petrol engines.
  It is very delicate work and requires a lot of attention and precision execution. And patience for the long time spent on the creation of each model.
  But I like it a lot.
> I often watch TV programs on the organization of sports-car championships rolleynyh sorrevnovany between passenger and freight categories for short and long distances.
  And as I watch television and other auto shows, for example: Top Gear.
  I subscribe and read sports magazines Motorsport.
> 
  Я готовился целый год чтобы прийти к вам на беседу.
  Full year I have been preparing for I come to You for the chat.
  ( coming up === подходящий )
  ( prepared === подготовленный )

>> (Как успешно пройти собеседование на английском языке) http://englex.ru/how-to-pass-job-interview-successfully/
                                                          https://skyeng.ru/articles/gotovimsya-k-sobesedovaniyu-na-anglijskom-yazyke-top-50-voprosov-soiskatelyu?source_type=cpa&utm_source=admitad&admitad_uid=b17ec614a79587c11e699ec1fcfa9d53
   1. Tell me about yourself — Расскажите о себе
   
   Furthermore, I’m a better listener - that’s why I’ve always been able to be in agreement with different types of people.
   I have over six years of experience in java developer.
   -----------------------------------------------------
   Более того, я замечательный слушатель, поэтому я всегда был способен ладить с разными типами людей.
   У меня более шести лет опыта работы Java-разработчиком.
   
>> https://www.eduonix.com/blog/software-development/learn-use-functions-methods-scala/
>> http://bbcworldservice.radio.net/

   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Обычно, в разговорной речи, большая часть предложений являются абстрактными - те которые не имеют конкретного места и времени действия.
   Кроме этого, есть и такие абстрактные предложения в которых даже сами действия являются абстрактными.
      Таких предложений очень много в разговорной речи. Но такие можно предложения можно класифицировать и в большинстве случаев такие формы предложений очень похожи друг на друга!
   ------------------
   Возле вас свободно (здесь свободно) ?
   >> Скажите мне пожалуйста - это место есть свободное ?
   
   Открыта дверь и поэтому очень холодно.
   >> Там есть открытая дверь на улицу и поэтому здесь есть очень холодно.
   
   Я пойду на работу чтобы заработать деньги.
   >> Я планирую (в будущем) иметь роботу для того чтобы получать деньги.
   
   Но я найду хорошую работу и буду еще больше зарабатывать денег.
   >> Но я есть планирую (в будущем) найти для хорошую работу. И тогда я иметь получать больше денег.
   
   Мне тяжело работать. Сейчас сложный период и нам всем очень тяжело. Но потом будет легче.
   >> Сейчас я есть тяжело для работы.
      Этот период является очень сложным для нас. Это есть причина для нам всем очень тяжело сейчас.
	  Но нам будет легко.
	  
   Кто нибудь собирается слушать мою историю ?
   >> Там есть кто-нибудь для слушать (в будущем) мою историю ?
   
   Местро левобережная, выход на правую платформу.
   >> Левобережная станция с освобождением -> право
   
   Поезд киев-Москва прибывает на третью платформу.
   >> Внимание.
      Уважаемые пассажири, поезд Киев-Москва входит -> платформа №3.
	  Please attention.
	  Dear passenger, now the train Kiev-Moskow entrance to third platforms.
	  
   Нужно немного подождать и будет хорошо. А я пока буду подтягивать свой английский.
   >> Сейчас мы должны быть малость ожидать. Но сейчас я буду практиковать для английский язык.
   
   А помниш вопрос что будет когда 'return' внутри 'try/catch'
   >> 
   
>> (Утиные истории) http://lyricstranslate.com/ru/duck-tales-утиные-истории.html-1
    --------------
   > По правилам английского языка, начало любого предложения может строится только со слов:
     - есть, иметь, быть, делать + мочь, хотеть, там есть.
   > А в случае когда вопрос, тогда впереди должно стоять вопросительное слово:
     - что? кто? где? когда? сколько?
   > Самым первым должно стоять местоимение <слово-указатель> + <действие>:
     - Я, Он, Она, Мы, Они, <Имена> + <действие>
   > Все последующие слова - являются уточнением времени и места.
   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   > Перед всеми указательными словами (местоимениями) НЕнужны уточняющие предлоги:
     - Я, Он, Она, Мы, Они + <Имена>
   > Для всех остальных слов которые указывают на предмет или на существо Нужны уточняющие предлоги места и количества:
     - Этот <есть> человек, Там <есть> чужак, Здесь <есть> стулья...
	 + (в этом случае выражение полностью заменяет: <местоимение> + <действие>)
   = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
   > В английском языке слова-действия могут иметь только физическое значение (в английском языке Отсутствует переносный смысл для слов-действия):
     - Открывать дверь, Открывать конверт, Решать проблему, Делаю решение, Могу решать тайну, Смотреть поведение твое, ...
   + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
   > В русском языке (можно сказать просто):
     - "Чужак ищет тебя" (ПIДМЕТ + ПРИСУДОК + ДОДАТОК)
   > Но в английском языке есть направление действия, например (всегда нужно указывать место + направление действия):
     - Там есть чужак, снаружи -> ищет тебя (There is a stranger out to find you)
   
   Например:
   - Я смотрю телевизор = Я просто смотрю какой-то телевизор.
   - Я смотрю в окно = Я просто смотрю куда-нибудь в окно.
   Но:
   - Я ищу ключи = Я конкретно здесь ищу свои ключи.
   - Я ищу тебя = Я конкретно там ищу где-то во внешнем мире тебя.
   
 
   
   
   
(рассказать о себе на английском)
>> https://skyeng.ru/articles/gotovimsya-k-sobesedovaniyu-na-anglijskom-yazyke-rasskaz-o-sebe
>> http://enginform.com/article/about-myself
>> http://engblog.ru/about-myself
>> http://iloveenglish.ru/stories/view/pishem_interesnij_rasskaz_o_sebe_na_anglijskom
>> https://www.youtube.com/watch?v=AGiLUyWvLPI&list=PLKYJHW3dXOM7pXJOZVMb2rr15qg7-cL5D
   
за нами приедет автобус .... The bus will come for us

Приезжать .................. Come

Приедет .................... Will come

Автобус приезжает по нас ... The bus comes over us
Автобус приедет в нас ...... The bus will come to us
Автобус уже уехал прочь .... The bus has already left

Автобус едет по нас ........ The bus is going over us

Я делаю .................... I'm doing it
Я буду делать .............. I will do
Я уже сделал ............... I did it already

Они ищут тебя .............. They looking for you
Они поймают тебя ........... They will catch you




----------------------------------
less | more ......... меньше, больше
about ............... около
since ............... поскольку
is unlock account ... разблокировать аккаунт
lock ................ замок
then ................ тогда
where ............... где
memory leak ......... утечка памяти
timeout (time-out) .. короткий перерыв в работе
then account was after lock ...................... тогда учет был после блокировки
set timeout use the last try enter of password ... установить перерыв в работе использовать последнюю попытку ввода пароля

существительное:
---------------
check (verification) ... проверка
setting ................ настройка (художественное оформление)
setting up ............. настройка (создание, сборка)

----------------------------------
имя существительное | глагол:
-------------------
Pick .............. ковырять, нарвать, (подковыривать, расщипывать, сковыривать)
Pick up ........... нахвататься, подцепить, забрать
Show .............. показывать
Ever (любой) ...... когда-либо
Own ............... свой собственный
Need .............. необходимость, надобность, потребность

глагол:
------
Own ............... владеть
Need .............. нуждаться, иметь потребность
verify (check)  ... проверять
Customize ......... настроить

местоимение:
-----------
Each .... каждый (когда речь идет о 2-ух и более предметах или вещах)
Every ... каждый (когда речь идет о 3-ех и более предметах или вещах) || ever, everyone, everybody = каждый из..., anyone; anybody = никто из...;

abroad .......... за границу
approx .......... приблизительно
attempt ......... попытка
again ........... еще раз
try ............. стараться
test ............ испытание
trial ........... (испытательная версия)
incredible ...... неимоверный
heritage ........ наследие
involving ....... с привлечением
newest .......... новейший
opportunities ... возможности
benefits ........ выгоды
perform ......... выполнять
approaches ...... подходы
travel .......... путешествие
tour ............ экскурсия
scalability ..... масштабируемость
fault ........... придираться
inspire ......... внушать
passion ......... страсть
flexible ........ гибкий
explicit ........ явный
expression ...... выражение (техническое)
sentence ........ предложение (идея)
offer ........... предлагать (услуга)
even ............ даже
than ............ чем (сравнительно, менее или более чем...)
independent ..... независимо
standalone ...... автономный
section ......... раздел (секция)
gonna ........... собирается (буду)
find out ........ выяснять
suppose ......... предполагать
spot ............ определять
supplies ........ предметы снабжения
probably ........ вероятно
curve ........... кривая
trade ........... сделка
goal ............ цель
therefore ....... следовательно
often (frequency) часто, зачастую
instead ......... вместо
produce (producer) ........................ производить (производитель)
consume (consumer) ........................ потреблять (потребитель)
reproduction (reproducing) ................ воспроизведение (воспроизводящий)
mandatory (forced) ........................ обязательный (принудительный)
then (if|else) ............................ тогда (если|инначе)
sense (meaning|feeling) ................... смысл (смысл|чувство)
complex (complicate|intricate-entangle) ... сложный (усложнять|запутанный)
think (thought) ........................... думать (думал)
dummy (fictitious|stub|manikin) ........... фиктивный (заглушка|манекен)
trip (trips) .............................. поездка (поездки)
cruise (voyage) ........................... рейс
field of plants ...................... Поле растений
what have you offer to concrete me ... Что вы предлагаете мне конкретно
hey everybody else? .................. ей кто нибудь (любой|каждый) другой?
we are gonna find out ................ мы собираемся выяснить

https://bsnyderblog.blogspot.com/2010/02/using-spring-to-receive-jms-messages.html
Have you ever had a need to create your own JMS consumer?
Вам когда-нибудь приходилось создавать своего собственного JMS-потребителя?
+++++++
your own JMS consumer == своего собственного JMS-потребителя
to create == создавать для
ever had a need == когда-нибудь приходилось
Have you == (указывает на вопрос, типа - Вы имели <с чем-нибудь>)
some time ....... (в какое-то время, один раз...)
sometimes ....... (иногда, периодично...)
ever had ........ (были разы...)
+++++++
(some | every | any)
everything ... всякий
everyone ..... каждый
anything ..... ничто
something .... что-либо одно
(what | that | than | so)
how ............. как? (вопрос, "How much?" сколько...)
as .............. как (подобно этому, как...)
what ............ что? (вопрос, что|какой...)
that ............ что (тот фак, что...)
than ............ чем (сравнительно, менее или более чем...)
then ............ тогда (при условии, тогда...)
so .............. тогда (связка между предложениями для продолжения разговора, значит ну тогда...)

В английском языке слова употребляются с предлоги, которые уточняют роль этого слова внутри предложения.
Например, для существительных используются: 'a/the', 'a/an', 'in/on/at', 'some/every/any', 'than less/more' - чтобы уточнить время и количество...
Также и для глаголов - по умолчанию для таких слов используется приставка 'to' (в этом случае слово-глагол не несет никакой смысловой нагрузки внутри предложения).
Но чтобы указать на временный период действия внутри предложения - для глаголов используется специальные окончания: 'es', 'ed', 'ing', 'was/will', 'has/had'




public class TreeTest {

    class MyNode {
        int data;
        MyNode left;
        MyNode right;
        MyNode parent;
    }

    MyNode root;


    public static void main(String[] args) {
        TreeTest test = new TreeTest();

        test.root = test.insert(test.root, 2, null);
        test.root = test.insert(test.root, 1, null);
        test.root = test.insert(test.root, 3, null);

        test.traverse(test.root);
    }


    MyNode insert(MyNode current, int data, MyNode parent){
        if(current == null){
            current = new MyNode();
            current.left = null;
            current.right = null;
            current.parent = parent;
            current.data = data;
        } else if(data < current.data) {
            current.left = insert(current.left, data, current);
        } else {
            current.right = insert(current.right, data, current);
        }

        return current;
    }

    void traverse (MyNode current){
        if(current == null)
            return;

        traverse(current.left);
        traverse(current.right);
    }
}

  .......................................................................................
  >> (Java Collections – Performance (Time Complexity)) http://infotechgems.blogspot.com/2011/11/java-collections-performance-time.html
                                                        https://habrahabr.ru/company/inforion/blog/332460
      ------------------------------------------------
	 Аннотация (большое) 'O' ... описывает как время выполнения заданной задачи растет с размером данных.
	 На одном конце 'O(1)' ..... это "постоянная времени"; а на противоположном конце 'O(x^n)' ... это экспонента времени.
	 'h' ....................... означает емкость Хэш-таблицы.
	
List
---------------------+-------+----------+-------+------------+---------------------
                     |  Add  |  Remove  |  Get  |  Contains  |  Структура данных
---------------------+-------+----------+-------+------------+---------------------
ArrayList            | O(1)  | O(n)     | O(1)  | O(n)       | Array
LinkedList           | O(1)  | O(1)     | O(n)  | O(n)       | Linked List
CopyonWriteArrayList | O(n)  | O(n)     | O(1)  | O(n)       | Array
---------------------+-------+----------+-------+------------+---------------------

Map
------------------------+----------+---------------+----------+---------------------
                        |   Get    |  ContainsKey  |   Next   |  Структура данных
------------------------+----------+---------------+----------+---------------------
EnumMap                 | O(1)     | O(1)          | O(1)     | Array
HashMap                 | O(1)     | O(1)          | O(h / n) | Hash Table
ConcurrentHashMap       | O(1)     | O(1)          | O(h / n) | Hash Tables
TreeMap                 | O(log n) | O(log n)      | O(log n) | Red-black tree
ConcurrentSkipListMap   | O(log n) | O(log n)      | O(1)     | Skip List
LinkedHashMap           | O(1)     | O(1)          | O(1)     | Hash Table + Linked List
IdentityHashMap         | O(1)     | O(1)          | O(h / n) | Array
WeakHashMap             | O(1)     | O(1)          | O(h / n) | Hash Table
------------------------+----------+---------------+----------+---------------------

Set
---------------------+-----------+------------+----------+---------------------
                     |    Add    |  Contains  |   Next   |  Структура данных
---------------------+-----------+------------+----------+---------------------
EnumSet              | O(1)      | O(1)       | O(1)     | Bit Vector
HashSet              | O(1)      | O(1)       | O(h / n) | Hash Table
TreeSet              | O(log n)  | O(log n)   | O(log n) | Red-black tree
LinkedHashSet        | O(1)      | O(1)       | O(1)     | Hash Table + Linked List
CopyonWriteArraySet  | O(n)      | O(n)       | O(1)     | Array
ConcurrentSkipList   | O(log n)  | O(log n)   | O(1)     | Skip List
---------------------+-----------+------------+----------+---------------------

Queue
------------------------+----------+--------+----------+--------+---------------------
                        |  Offer   |  Peak  |   Poll   |  Size  |  Структура данных
------------------------+----------+--------+----------+--------+---------------------
PriorityQueue           | O(log n) | O(1)   | O(log n) | O(1)   | Priority Heap
LinkedList              | O(1)     | O(1)   | O(1)     | O(1)   | Array
ArrayDequeue            | O(1)     | O(1)   | O(1)     | O(1)   | Linked List
ConcurrentLinkedQueue   | O(1)     | O(1)   | O(1)     | O(n)   | Linked List
ArrayBlockingQueue      | O(1)     | O(1)   | O(1)     | O(1)   | Array
PriorirityBlockingQueue | O(log n) | O(1)   | O(log n) | O(1)   | Priority Heap
SynchronousQueue        | O(1)     | O(1)   | O(1)     | O(1)   | None!
DelayQueue              | O(log n) | O(1)   | O(log n) | O(1)   | Priority Heap
LinkedBlockingQueue     | O(1)     | O(1)   | O(1)     | O(1)   | Linked List
------------------------+----------+--------+----------+--------+---------------------


  .......................................................................................
  >> (Рекомендации по написанию неизменяемых классов) https://www.ibm.com/developerworks/ru/library/j-jtp02183/index.html

	 Класс будет неизменяемым, если верно следующее
     ----------------------------------------------
	 1. Класс объявляется как 'final'
	 2. Все его поля являются 'final'
	 3. Ссылка 'this' не должна пропасть во время конструирования
	 4. Любые поля, содержащие ссылки на изменяемые объекты, например массивы, совокупности или изменяемые классы, например Date:
        4.1 Являются приватными
        4.2 Никогда не возвращаются и никаким другим образом не становятся доступными вызывающим операторам
        4.3 Являются единственными ссылками на те объекты, на которые они ссылаются
        4.4 Не изменяют после конструирования состояние объектов, на которые они ссылаются
		
     Правильный и неправильный способы кодирования неизменяемых объектов
     -------------------------------------------------------------------
	class ImmutableArrayHolder {

	  private final int[] theArray;

	  // Right way to write a constructor -- copy the array
	  public ImmutableArrayHolder(int[] anArray) {
		this.theArray = (int[]) anArray.clone();
	  }

	  // Wrong way to write a constructor -- copy the reference
	  // The caller could change the array after the call to the constructor
	  public ImmutableArrayHolder(int[] anArray) {
		this.theArray = anArray;
	  }

	  // Right way to write an accessor -- don't expose the array reference
	  public int getArrayLength() { return theArray.length }
	  public int getArray(int n)  { return theArray[n]; }

	  // Right way to write an accessor -- use clone()
	  public int[] getArray()       { return (int[]) theArray.clone(); }

	  // Wrong way to write an accessor -- expose the array reference
	  // A caller could get the array reference and then change the contents
	  public int[] getArray()       { return theArray }
	}
  
Выполнив некоторые дополнительные действия, можно создать неизменяемые классы, которые используют некоторые неокончательные (non-final) поля (например, стандартная реализация String предполагает использование отложенного вычисления (lazy computation) значения hashCode), которое может работать лучше, чем строго окончательные классы. 
Если ваш класс представляет значение абстрактного типа, как, например, числовой тип или цвет, вам также понадобится реализовать методы hashcode() и equals(), для того, чтобы ваш объект работал хорошо в качестве ключа в HashMap или HashSet. 
Для поддержания безопасности потоков важно, чтобы ссылка this не выходила из конструктора.
  
  .......................................................................................
  >> (HQL и join-ы) http://javatalks.ru/topics/28747
  
  from User u join u.child1 where...
  
  .......................................................................................
   >> () https://forum.hibernate.org/viewtopic.php?f=1&t=1009553 >> https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies
   Вот важная вещь которую нужно знать о "join fetching":
   - fetch="join" использует "outer join" для пустых (nullable) "many-to-one" внешних ключей и коллекций
   - fetch="join" использует "inner join" для непустых (not-null) "many-to-one" внешних ключей
   fetch="join" используется только при получении данных через функции "get()" или "load()"
   
   А HQL-запросы не учитывают fetch="join" определенных в mapping-документе
   Если хотите чтобы HQL-запрос использовал "left outher join" тогда нужно явно написать его в своем запросе
  ............................................
   >> (JPA: Хранение перечислений в базе данных) https://habrahabr.ru/post/77982
   >> (Hibernate Annotations: использование Java ENUM в сущностях) http://internetka.in.ua/hibernate-annotations-enum
   >> (Как сохранить Enum в БД используя JPA) http://devcolibri.com/2647
   >> http://tomee.apache.org/examples-trunk/jpa-enumerated/README.html
   Какие различия между примитивными типами и их обвертками, например "int", "boolean" И "Integer", "Boolean":
   - в примитивных типах как "int", "boolean" допускаются только те значения которые предусмотрены этими типами (если "int" то 0,1,2,3,4,5,..., если "boolean" то true,false)
   - в типах-обвертках как "Integer", "Boolean" помимо их заведомо допустимых значений может присутствовать 'NULL'.
   Для того чтобы добавить Enum в Entity нам потребовалось просто проаннотировать атрибут enum аннотацией @Enumerated.
   Аннотация @Enumerated — принимает параметр типа EnumType:
   1. EnumType.STRING — это значит, что в базе будет хранится имя этого enum.
      (если мы зададим role = RoleEnum.ADMIN, то в БД в поле role будет хранится значение ADMIN)
   2. EnumType.ORDINAL — это значит, что в базе будет хранится ID этого enum. ID — это место расположение в списке перечисления начиная с 0.
      (если значение enum равно ADMIN, то в базе будет хранится число 2)
	  
public enum CommunicationStatus {
    VALID,
    INVALID,
    DONT_CONTACT,
    UNKNOWN;
}

@Entity
public class Account {

    @Id
    @GeneratedValue
    @Column(name = "id")
    protected Long id;

    @Column(columnDefinition = "boolean default false")
    private boolean isLocked;

    @Column(length = 32, columnDefinition = "varchar(32) default 'UNKNOWN'")
    @Enumerated(value = EnumType.STRING)
    private CommunicationStatus emailCommunicationStatus;

    PlayerAccount() {
        super();
    }
}
  ............................................
  >> (14 вопросов об индексах в SQL Server, которые вы стеснялись задать) https://habrahabr.ru/post/247373
  >> http://bourabai.ru/dbt/dbms/001.htm
  >> (SQL Server: использование индексов при настройке производительности) http://www.quizful.net/post/indices-sql-performance-tuning
                                                                           https://msdn.microsoft.com/ru-ru/library/jj835095(v=sql.120).aspx
																		   http://www.sql.ru/articles/mssql/03013101indexes.shtml
     Полезные индексы
	 ----------------
	 индексирование таблиц будет полезно при поиске записи в таблице с использованием инструкции 'WHERE'
	 например:
	 - запросы поиска диапазона значений;
	 - запросы точного сопоставления определенному значению;
	 - запросы осуществляющие слияние двух таблиц;
	 
	 Недостатки индексирования
	 -------------------------
     Индексы ухудшают производительность системы во время изменений записи
	 Базы данных с большим количеством транзакций для изменения данных будут нуждаться в небольшом количестве индексов для обеспечения более высокой пропускной способности
	 Индексы занимают дополнительное место на диске и в оперативной памяти
	 
	 Построение оптимального индекса
	 -------------------------------
	 (Для выбора оптимального количества индексов необходимо тестирование базы данных и наблюдение за ее производительностью)
	 
	 > Простой индекс – это индекс использующий значения одного поля таблицы.
	   Использовать простой индекс выгодно:
	   1. работа базы данных сильно нагружает жесткий диск. Большие индексные ключи будут заставлять базу данных выполнять большее количество операций ввода-вывода, что ограничивает производительность.
	   2. элементы индекса часто вовлечены в сравнения, меньшие индексы легче сравнивать.
	   Единственная колонка целочисленного типа является лучшим индексом, так как он мал и легок для сравнения.
	   Строки символов требуют посимвольного сравнения и внимания к обработке параметров.
	   
	 > Селективный индекс - это индекс с высоким процентом уникальных значений.
	   Наиболее эффективные индексы – это индексы с малым процентом дублирующихся значений.
	   (уникальный индекс  обладает наибольшей селективностью, так как не содержит дублирующихся значений)
	   (примеру: телефонный справочник города в котором каждый имеет фамилию Смит И будет не столь полезен, если записи в нем отсортировать по фамилии)
	   
	 > Покрывающие индексы - индексы состоят из столбца данных по которому построен указателя на соответствующую строку.
	   (покрывающий запрос - все запрашиваемые столбцы могут быть извлечены из одного индекса)
	   "Select Count(*), UnitPrice From Products Group by UnitPrice"
	   Для наиболее важных запросов можна рассмотреть возможность создания покрывающего индекса для лучшей производительности.
	   Такие индексы с большой вероятностью будут составными (и это противопоставляется первому принципу - создавать простые индексы)
	   
	 > Кластерный индекс - специальный индекс где все данные из строки содержаться в индексе.
	   Кластерный индекс наиболее эффективный индекс, если он используется, то покрывает весь запрос.
	   (кластерный индекс можно сравнить с телефонным справочником, потому как каждый элемент индекса содержит всю информацию, которая вам нужна и не содержит ссылок для получения дополнительных данных)
	   (В SQL сервере при создании первичного ключа будет автоматически создан кластерный индекс)
	   Элементы для кластерного индекса содержать все значения столбцов.
	   Если изменить запись и поменять значение столбца в кластерном индексе, база данных будет вынуждена перестроить элементы индекса.


  .......................................................................................
  >> (Какие четыре статуса жизненного цикла Entity объекта) https://habrahabr.ru/post/265061
                                                            http://konvi-notes.blogspot.com/2017/01/hibernate.html
     У 'Entity' объекта существует 4-е статуса жизненного цикла:
	 1) new ........ объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных;
	 2) managed .... объект создан, управляется JPA, имеет сгенерированные первичные ключи;
	 3) removed .... объект создан, управляется JPA, но будет удален после commit'a транзакции;
	 4) detached ... объект был создан, но не управляется (или больше не управляется) JPA;
	 
	 Контекстные сессии и паттерны
	 -----------------------------
	 Вместо 'openSession()' можно использовать 'SessionFactory.getCurrentSession()' - он вернет сессию, связанную с контекстом (с каким именно зависит от конфигурации).
	 При работе с базой данных создается объект, который реализует интерфейс 'CurrentSessionContext', Hibernate включает 3-и реализации этого интерфейса:
	 1. JTASessionContext - контекст сессии определяется управляемой JTA транзакцией. При commit-транзакции сессия флашится, очищается и закрывается;
	 2. ThreadLocalSessionContext - для юнит тестов и standalone приложений. жизненный цикл определяется потоком. Работу по очистке выполняет jdbc транзакция;
	 3. ManagedSessionContext - тоже связана с потоком, но может быть расширена на несколько. Мы управляем такой сессией, ее надо будет очистить и закрыть вручную;

  .......................................................................................
  >> (Java / Выполнение блока finally) http://www.quizful.net/interview/java/finally-execution
                                       https://ru.stackoverflow.com/questions/121979/Выполняется-ли-finally-если-в-try-return
      Всегда ли выполняется блок finally?
	  ----------------------------------
	  1. System.exit(0); // Здесь finally недостижим, так как происходит системный выход из программы.
	  2. // Секция finally не выполняется в потоках-демонах. Т.е. потоки-демоны завершают выполнения метода run() без выполнения секции finally.
         // Это происходит из-за того, что демоны завершаются "внезапно" при завершение последнего потока не-демона.
  
  .......................................................................................
+ Аспектно-Ориентированного Программирования (АОП)
  ------------------------------------------------
  >> (Spring Framework) http://proselyte.net/tutorials/spring-tutorial-full-version/aop-with-spring
  >> () http://www.quizful.net/post/aspect-oriented-programming-in-spring
  - Ключевой единицей в ООП является "объект" (внедрение зависимостей "DI" позволяет отделять объекты внутри приложения друг от друга...).
  - Ключевой единицей в АОП является "аспект" (АОП позволяет отделять сквозные проблемы "cross-cuttings" от объектов к которым они относятся...).
	-- (1-ин метод несет 1-ну смысловую нагрузку)
	   Обычно для 1-го метода закладывается только 1-на логическая функциональность (например: если это метод контенации строк - он должен суммировать множество подстрок в одну строку).
	   Другой случай, когда 1-ин метод может выполнять несколько функций (например: web-метод - он прослушивает клиента + обрабатывает данные + формирует возвращаемый результат).
	   --- Реализация для такого мульти-функционального метода может быть раскидана по всему коду приложения (то есть, лежать в разных классах...).
	       Например: каждый класс может реализовывать разные специфические поведения для разных объектов. А вызов этих разных классов объединяется внутри 1-го метода.
		   И чем больше усложняется код, тем сложнее будет пользоваться такой реализацией мульти-функциональности (то есть, велика вероятность допустить ошибку + сложности реализации...).
	   --- Аспектно-Ориентированного Программирования позволяет описывать именнованую-реализацию для мульти-функциональности только в едином месте кода И применять ее потом как функциональное дополнение для любого метода.
	   Пример: в реальности, в каждом методе присутствует:
	   - "служебная логика" (логирование, обработка транзакций, обработка ошибок, авторизация и проверка прав, кэширование)
	   - "бизнес логика" (это прямое назначение метода...web-метод: POST|PUT|GET|DELETE)
	   
  >> (Знакомство с АОП) https://habrahabr.ru/post/114649
  Как это работает:
  1. "join points" - итак, есть список наших допольнительных функций
  2. "pointcut" - теперь объединяем этот список допольнительных функций (join points)
  3. "advice" - объявляем советы которые будем использовать для данного "pointcut"
  4. "cross-cutting" - средствами АОП (создается так называемый перехватчик или Proxy, который берет управление на себя) внедряем в код приложения (такую функциональность еще называют сквозной)
  "Аспект" (Aspect | AspectJ) - это класс, а методы в нем (в этом классе) - "советы" (advice).
  - "Совет" (advice) – это дополнительная логика — код, который должен быть вызван из точки соединения.
    Они делятся на 5 типов:
	1. Before (до выполнения метода)
    2. After (после выполнения)
    3. After returning (после возвращения результата)
    4. After throwing (после выбрасывания исключения)
    4. Around (объединение несколько советов в 1)
  
  >> (Различные типы Аспектно-Ориентированного Программирования) http://www.finecosoft.ru/spring-aop
  Существует два различных способа реализации аспектно-ориентированного программирования:
  1. Статический .... 
  2. Динамический ... 
  
  Архитектура Spring АОП
  - Реализация аспектно-ориентированного программирования в Spring основана на использовании объектов-посредников (proxy - "ProxyFactoryBean").
  
  
+ MongoDB
  -------
  Форматы:
  - Реляционные базы данных (MySQL) имеют формат запросов, который представлен в виде таблиц.
  - Документно-оборотные базы данных (MongoDB) имеют собственный формат запросов, который представлен в виде JSON-строки.
  
  - Записи в реляционных базах данных хранятся в виде "таблиц" и "строк". Колонки для строк определяются на уровне таблицы.
  - Записи в документно-оборотных базах данных хранятся в виде "коллекции" и "документов". Поля для документов определяются на уровне документа (не коллекции).
    (это значит что любой документ внутри коллекции может иметь свой собственный уникальный набор полей... коллекции бесструктурны)
  
  - В реляционных базах данных поддерживаются "транзакции", которые используют: "блокировки" (чтение/запись/...) и "подтверждение запросов" (коммит/ролбэк).
  - Документно-оборотные базы данных НЕподдерживают транзакции (все операции выполняются без "подтверждение запросов"). Но документно-оборотные базы имеют альтернативные приимущества:
    -- "Атомарные операции" - (это специальные операторы: $lt, $lte, $gt, $gte, $ne, $or, $inc, $set, $where, $exists, $push, ...)
	-- "Двухфазный коммит" - (когда атомарных операций не хватает) по сравнению с транзакциями это то же самое что ручное разруливание запросов с JOIN-ами...
	                         (для реляционных баз данных это когда нужно обеспечить транзакции в пределах нескольких баз данных...)
  
  Перебор записей (строк/документов) для выборки данных происходит одинаково и в реляционных и в документно-оборотных базах данных.
  - Но в реляционных базах данных это более сложный путь:
    -- 1. "WHERE" (критерии поиска); 2. "JOIN" (регулирует кросс-запросы); 3. "FROM" (загружает данные в кеш-память); 4. "SELECT" (получает запись);
  - В документно-оборотных базах данных (отсутствуют JOIN-ы) используется "MapReduce" (альтернатива "GROUP BY" для SQL):
    -- сложные вычисления "MapReduce" разбивает на множество простых под-операций, которые выполняются паралельно (независимо).
  Поэтому скорость получения результатов запроса в документно-оборотных базах данных будет намного быстрее (потому-что все вычисления разбиваются на параллельные операции и время затраченное на блокировку данных внутри транзакций).
  Кроме этого, запросы в документно-оборотной базе данных возвращают "курсор" (не всю запись, а только ссылку на запись), а получение самих данных записи происходит уже позже по требованию... и тем самым экономится затрачиваемое время на формирование результатов ответа.
  
  - "ObjectId" сгенерированный MongoDB для поля "_id" может быть любым уникальным значением (поскольку в жизни скорее всего используется ObjectId, здесь также используется он).
    (альтернатива для "внутренних ключей" которые авто-генерятся в реляционных баз данных)
  - Когда начинается разделения данных (горизонтально), вам всё равно придётся выполнять JOIN-ы на клиенте (которым является сервер приложений...).
    (поэтому, для документо-оборотных баз данных JOIN-ы нужно делать вручную, в коде своего приложения)
  + Поддержка "массивов" в MongoDB удобна когда требуется смоделировать отношения "один-ко-многим" или "многие-ко-многим" (например если у сотрудника есть несколько менеджеров их можно сохранить в виде массива):
    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d733"), name: 'Siona', manager: [ObjectId("4d85c7039ab0fd70a117d730"), ObjectId("4d85c7039ab0fd70a117d732")] })
  + Поддержка "вложенных документов" в MongoDB (вложенные документы можно запрашивать с помощью точечной нотации):
    db.employees.insert({_id: ObjectId("4d85c7039ab0fd70a117d734"), name: 'Ghanima', family: {mother: 'Chani', father: 'Paul', brother: ObjectId("4d85c7039ab0fd70a117d730")}})
	db.employees.find({'family.mother': 'Chani'})
  + "DBRef" - он может автоматически получить связанный документ (включает в себя коллекцию и '_id' документа на который он ссылается).
    (это означает что документы из одной и той же коллекции могут ссылаться на другие документы из различных коллекций)
  + "Денормализация" - используется для оптимизации производительности (когда с данных, например, журнала аудита) необходимо было иметь возможность делать снимок...
  
  - С быстрым ростом NoSQL-решений они лишены JOIN-ов, и денормализация стала в порядке вещей, например разрабатываем форум:
    -- обычно чтобы ассоциировать пользователя с его постом - это колонка 'userid в таблице 'posts'.
	   (с такой моделью нельзя отобразить список постов без дополнительного извлечения данных (JOIN) из таблицы пользователей)
	-- возможное решение - хранить имя пользователя 'name' вместе с 'userid' для каждого поста, или можно также вставлять небольшой встроенный документ.

>> (Идентификатор документа) http://pzks.nmu.org.ua/ua/labs/mongodb.pdf
    -----------------------
   Для каждого документа в MongoDB определен уникальный идентификатор, который называется '_id'.
   Если идентификатор не задан явно, то MongoDB создает специальное бинарное значение размером 12-байт. Это значение состоит из нескольких сегментов:
   - Первые 9-байт гарантируют уникальность среди других машин, на которых могут быть реплики базы данных:
     1. значение типа 'timestamp' размером 4-байта
     2. идентификатор машины из 3-байт
     3. идентификатор процесса из 2-байт
     4. счетчик из 3-байт
   - Следующие 3-байта гарантируют уникальность в течение 1-ой секунды для 1-го процесса
   Такая модель гарантирует что он будет иметь уникальное значение, она позволяет создавать до 16.777.216 уникальных объектов ObjectId в секунду для одного процесса.
   
	
>> (Осваиваем селекторы) http://jsman.ru/mongo-book/Glava-1-Osnovy.html
   MongoDB у себя внутри использует бинарный сериализированный JSON-формат.
   
  - В базе данных MongoDB создается 2-е коллекции:
      1. "unicorns" - у коллекции этой можно вызвать методы: "find()", "count()", "insert()", "update()", "remove()"...;
	  2. "system.indexes" - содержит в себе информацию об индексах этой базы;
  - Селектор запросов MongoDB аналогичен "WHERE" SQL-запроса.
	
  db.getCollection('users').find(null, {_id:0,socWendor:1}) ......................................... "Projection" (вывод полей)

  db.getCollection('users').find(null, {_id:0,socWendor:1}).sort({socWendor:1}) ..................... сортировка
  db.getCollection('users').find(null, {_id:0,socWendor:1}).sort({socWendor:1}).limit(5).skip(5) .... "Paging" (постраничная пагинация)
  db.getCollection('users').find({"socWendor":"vk.ru"}) ............................................. "Селектор запросов" (аналогия "WHERE" SQL-запроса)
  db.getCollection('users').find(null, {_id:0,socWendor:1,publicId:1,email:1,active:1}, $or:[{socWendor:'gup.com.ua'},{publicId:{$lt: 500}}]).sort({socWendor:1}).limit(5).skip(5)
  
  >> (Руководство по MongoDB) http://proselyte.net/tutorials/mongodb/data_modeling/
  Советы по моделированию схемы в MongoDB:
  - Комбинируйте объекты в одном документе, если мы будем использовать их вместе.
  - Дублируйте данные, так как время вычислений дороже, чем место на диске.
  - Делайте join-ы во время записи, а не во время чтения.
  - Используйте сложные агрегации в схеме.
  - Оптимизируйте схему под наиболее частые случаи. 
  
>> (Глава 5 — Когда использовать MongoDB) http://jsman.ru/mongo-book/Glava-5-Kogda-ispolzovat-MongoDB.html
>> (Полнотекстовый поиск) https://ruhighload.com/post
                          https://www.elastic.co
    --------------------
    Устройство полнотекстового индекса состоит из двух компонентов:
	1. "Индексатор" - получает текст на вход, делает обработку текста и сохраняет все в индексе;
	2. "Поисковик" - интерфейс поиска по индексу - принимает от клиента запрос, обрабатывает фразу и ищет ее в индексе;
	
	Существует несколько популярных технологий для реализации полнотекстового поиска в приложениях:
	1. "Sphinx" - простое решение которое подойдет для большинства случаев.
	              (Sphinx поддерживает обычный MySQL протокол для поиска, поэтому чтобы найти в индексе какой-то текст достаточно подключиться к порту 9306 и отправить обычный MySQL запрос)
    2. "Solr" - это не просто поисковый индекс, а еще и хранилище документов (в отличие от Sphinx'a, документы сохраняются целиком и их не нужно дублировать в базу данных).
	3. "Elastic" (ElasticSearch) - эта инфраструктура для работы с данными, в том числе полнотекстовым поиском. Построен на основе 'Apache Lucene' (имеет мега продвинутую систему хранения данных и протокол запросов).

    (spring mongodb or query)
>>  (A Guide to Queries in Spring Data MongoDB) http://www.baeldung.com/queries-in-spring-data-mongodb
>>  (Легкий старт: Spring + MongoDB) https://habrahabr.ru/post/217391
>>  (How to query MongoDB with "like") https://stackoverflow.com/questions/3305561/how-to-query-mongodb-with-like
                                       http://www.baeldung.com/queries-in-spring-data-mongodb
    --------------------
	db.getCollection('users').find()
	db.getCollection('users').find({socWendor:"vk.ru"}) ........................................................................... селектор запроса для выборки (аналог 'where')
	db.getCollection('users').find(null, {socWendor:1, userRoles:1, username:1, _id:0}) ........................................... 'Projection' - чтобы получить список полей (аналог 'select')
	db.getCollection('users').find({socWendor:"gup.com.ua"}, {socWendor:1, userRoles:1, username:1, _id:0})
	db.getCollection('users').find({createdDate:{$lt:1492601303397}}, {socWendor:1, userRoles:1, username:1, createdDate:1}) ...... все что меньше заданого числа
	db.getCollection('users').find({createdDate:{$gt:1492601303397}}, {socWendor:1, userRoles:1, username:1, createdDate:1}) ...... все что больше заданого числа
	db.getCollection('users').find(null, {socWendor:1, username:1}).sort({socWendor:-1}) .......................................... сортировка (аналог 'order by socWendor ASC или DESC')
    db.getCollection('users').find({socWendor:"gup.com.ua"}, {socWendor:1, userRoles:1, username:1, _id:0}).sort({username:-1})
	db.getCollection('users').find({createdDate:{$lt:1492601303397}}).count() ..................................................... получить количество найденных записей
	db.getCollection('users').find({createdDate:{$gt:1492601303397}}).count()
	db.getCollection('users').find().limit(10).skip(10) ........................................................................... (пагинация)
	Регулярные выражения
	db.getCollection('users').find({active:true, socWendor:'gup.com.ua'}) ......................................................... (аналог 'WHERE...AND')
	db.getCollection('users').find({$or: [{active:true}, {socWendor:'gup.com.ua'}]}) .............................................. (аналог 'WHERE...OR')
	db.getCollection('users').find({username:/a/}) ................................................................................ (аналог like '%a%') все слова где встречается буква 'а'
	db.getCollection('users').find({username: /^A/}) .............................................................................. (аналог like '%A') все слова которые начинаются с буквы 'а'
	db.getCollection('users').find({username: /о$/}) .............................................................................. (аналог like 'o%') все слова которые заканчиваются буквой 'о'
	db.getCollection('users').find({username:'Anna'}, {username:1})
	db.getCollection('users').find({publicId: {$regex:'22'}}) ..................................................................... полнотекстовый поиск
	db.getCollection('users').find({publicId: {$regex:'22'}}, {username:1, publicId:1})
	db.getCollection('users').find({email:/1q1q1q/i}, {publicId:1, socWendor:1, username:1, email:1, userRoles:1, active:1})
	db.getCollection('users').find({email:{$regex:'1q1q1q', $options:'-i'}}, {publicId:1, socWendor:1, username:1, email:1, userRoles:1, active:1})
	--------------------
	db.getCollection('users').find().pretty() ..................................................................................... для структурированного вывода данных коллекции
	Модификаторы обновления/вставка
	db.getCollection.update({name: 'Aurora'}, {$push: {loves: 'sugar'}})
	db.getCollection.update({page: 'unicorns'}, {$inc: {hits: 1}})
	db.getCollection.update({name: 'Roooooodles'}, {$set: {weight: 590}})
	db.getCollection.update({}, {$set: {vaccinated: true }})
	
	db.getCollection('users').find({email:'1q1q1q@1q.com'}, {publicId:1, socWendor:1, username:1, email:1, userRoles:1, active:1})
	db.getCollection('users').find({email:'1Q1Q1Q1Q@1Q.COM'}, {publicId:1, socWendor:1, username:1, email:1, userRoles:1, active:1})
	--------------------
	db.getCollection('oauth2_access_token').find({userName:'sashakmets@yandex.ru'})
	db.getCollection('oauth2_refresh_token').find({'authentication.userAuthentication.principal.username': 'sashakmets@yandex.ru'})
	
  
*** >> (HQL JOIN example) https://javatalks.ru/topics/28747
        ----------------
	   from User u join u.child1 where...
	   Плюс у хиба опять же не один тип join'ов.
	   Не ну hql запрос то я сделал в итоге, но меня напрягает то что в итоговом sql запросе присутствуют cross join.
В общем как получается, если мы имеем несколько сущностей которые ссылаются на одну и ту же сущность и отношение у них ManyToOne, и нам нужно получить все эти сущности, то hql запрос получается извратный и sql тоже вырисовывается более сложный чем должен быть по идее.
Думал как можно использовать left-ы и прочие join-ы, картина получается та же.
А вот если у нас будет отношение OneToMany (то есть наоборот главная сущность будет иметь список потомков), то запросы выглядят намного красивее.
  
  
  .......................................................................................
+ Cockie | Session | OAuth | Контекст
  -----------------------------------
  Есть:
  - клиент (может быть любое клиентское приложение которое работает на стороне клиента)
    -- у клиента есть IP-адресс
	-- у клиента могут быть Cookie (это сохраненные на стороне клиента файлы которые хранят информацию участвующую в клиентских запросах: поля формы..)
	   клиент может включать свои Cookie в HEAD-запроса
  - сервер:
    -- есть "сервер приложений" (такой себе менеджер для всех веб-приложений..)
	-- и есть "серверное приложение" (это и есть само веб-приложение..)
	   "серверное приложение" на своей стороне может держать разные инструкции (например: выбор способа/формы авторизации..)
	-- у "сервера приложений" может быть Session (это сохраненные на стороне сервера файлы которые хранят информацию участвующую в клиентских запросах: поля формы..)
	   клиент может идентифицировать свою Session по идентификатору id-session (..)
	   ("сервер приложений" выполняет инструкции которые получает от "серверное приложение", например через встроенное API проверяет пользователя в базе данных И передает "серверному приложению" информацию-ответ-запроса полученную от пользователя)
  - OAuth (это альтернатива Session)
    (файл Session живет на стороне сервера короткое время И это время жизни управляется самим "серверным приложением")
	-- это тоже идентификатор-строка который хранится и на серверной стороне и на клиентской стороне И имеет только 2-а токена:
	   "auth-токен" (механизм: служит для идентификации пользователя на серверной стороне)
	   "refrash-токен" (механизм: служит для получения самого "auth-токен"..)
	суть в том, что теперь за хранения всей приватной информация об пользователе несоет ответственность (НЕ сам клиент, на клиентской стороне) уже "OAuth сервис" на стороне специального сервера..
	(теперь хакеру будет сложнее перехватить приватную информацию об пользователе, потому-что для этого нужно сделать больше действий...чтобы вытащить ее)

  Контекст
  - В момент регистрации|аудитенфикации|авторизации "сервер приложений" самостоятельно:
    -- делает проверку пользователя (по логину/паролю..)
    -- определяет его роль и права на этом "сервере приложений"
    -- и создает такой себе объект "Контекст" приложения - внутри которого (куда собирается и) хранится конкретно информация об этом пользователе..
  - Как это работает:
    -- вытаскивается информация которая используется в момент аудитенфикации (либо из Session, либо из OAuth) и передается в объект "Контекст" приложения
	-- внутри (созданного) объекта "Контекст" приложения уже существует вся приватная информация об пользователе
	-- теперь вытаскиваем информации из объекта "Контекст" приложения И дальше:
	   --- делаем уже другую проверку внутри самого (нашего) "серверного приложения" на предмет: права доступа к конкретному защищенному методу внутри приложения..
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  На стороне сервера существует несколько этапов прохождения клиентского запроса:
  1. на все что происходит...самой первой реагирует Опреационная Система (она слушает и логирует все события..) И перенаправляет все запросы по адрессу получателей..
  2. дальше этот запрос получает "сервер приложений"...тоже как-то его обрабатывает И перенаправляет по адрессу на "серверное приложение"..
  3. и уже потом (наше) "серверное приложение" как-то обрабатывает этот запрос

  Дело в том, что только на уровне (последнем этапе) нашего "серверного приложения" может быть защищен доступ к ресурсам..
  Это значит что на всех остальных (предварительных) этапах защита отсутствует...поэтому:
  - злоумышленник сможет безпрепятственно, например: забрать системные файлы-логов, временно-хранящиеся файлы-Session, проанализировать все те клиентские запросы которые Опреационная Система зафиксировала И найти/получить приватную информацию о пользователе (которую потом использовать для авторизации..)
  - плохо то что и на этих уровнях защиты "серверное приложение" никак не может защитить такую информацию..
  .......................................................................................
  - Элементы веб-приложения:
  -- "Servlet"
     это веб-компонет у которого есть сервисные методы-слушатели (services|GET|POST|PUT|DELETE). Эти методы-слушатели переопределяются для каждого конкретного случая на серверном приложении. Они могут принимать параметры и обрабатывать их..
  -- "Model"
     это формат данных который в ответ возвращает метод Servlet-а (HTML-документ|JSON|XML|бинарный-файл..)
  -- "Filter"
     прослушивает URL-адресса и перенаправляет их..
  -- "Exception"
     в случае внутренней ошибки на сервере перенаправляет веб-страницу с ошибкой (здесь даже можно с помощю фильтра улучшить результат..)
  -- "Session"
     создает сессию и ложит туда клиентские данные..
  -- "Security"
     защищенный доступ к рессурсам.. (настраивается обычно на самом "сервере приложений")
  -- ...

  - Spring компоненты:
    -- дело в том, что Spring имеет собственные встроенные компоненты для веб-приложения И некоторые из этих встроенных веб-компонентов по умолчанию уже подключены в проэкт веб-приложения с дэфолтными настройками..

    --- "Servlet" (по умолчанию включен в MVC: DispatchServlet имеет собственный фронтальный контролер, который потом перебрасывает на кастомерские контроллеры..)
    --- "Model" (для REST-методов по умолчанию возвращается JSON; для веб-страниц возвращает документ в виде модели..; также можно этот формат конвертировать для бинарных файлов..;)
    --- "Filter" (по умолчанию из URL-адресса отсекается приставка ".jsp", в итоге получаем обычную сгенерированную на сервере jsp-страничку..)
    --- "Exception" (по умолчанию в Spring-е предусмотрены собственные странички для внутренних ошибок..)
    --- "Session" (можно включить в конфигурационном файле-Spring-а и тогда все поля из объекта-модели будут попадать в сессию автоматически..)
    --- "Security" (помимо тех библиотек что предлагает "сервер приложений", Spring имеет собственные библиотеки для реализации защищенного доступа..)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  Выскакивает на автовайред...тривиальный случай объявления бина в классе но вместо ожидаемого объекта получаем NullPointerException ?
  - Если ты через Autowire делаешь, то то, над чем ты ставишь эту аннотацию - должно быть помечено аннотацией Компонент, репозиторий, сервис, или контроллер а и наче ты не сможешь создать бин
  1. в Spring-е существует интерфейс ApplicationContext - через который можно загрузить спринговые бин-ы, при условии что будут созданы с них объекты...
  2. если это веб-приложение - тогда в web.xml нужно определить ContextListner - с помощью которого...будет иннициироваться/создаваться объекты спринговых бинов
  3. а в интеграционных тестах есть аннотация @RunWith(SpringJUnit4ClassRunner... - с помощью которого...будет иннициироваться/создаваться объекты спринговых бинов и незабываем о том что для всех случаев по нужно еще предварительно сконфигурировать эти бин
  .......................................................................................
  .......................................................................................
+ SPRING, объявления через аннотации и в xml-конфигурации:
  .......................................................................................


  .......................................................................................
+ "redirect" | "forward"
  ----------------------
  >> http://ru.stackoverflow.com/questions/401524/spring-mvc-controller-Разница-между-return-forward-redirect-и-возвратом-jsp-ф
  forward - это ВНУТРИ-серверный переход на другой контроллер
  redirect - отправляет http с кодом 302 и происходит редирект на другой ВНЕШНИЙ-url. Второй применяют частенько как защиту от F5. Скажем при оплате чтобы та повторно не происходила.
  >> http://www.realcoding.net/article/view/2182
  - Forward (пересылкой) - Когда вы выполняете пересылку, нужная нам страница инициируется JSP-контейнером с помощью внутреннего вызова метода. Новая страница продолжает обрабатывать тот же самый запрос, а браузер даже не догадывается о том, что в этом процессе задействовано несколько страниц
  - Redirect (переадресацией) - означает то, что первая страница требует от браузера сделать новый запрос к нужной странице. Таким образом, URL, указанный в браузере, будет заменён URL новой страницы, на которую нас переадресовали, чего не происходит при пересылке. Переадресация медленнее, чем пересылка, поскольку браузер вынужден повторять свой запрос. Второе отличие состоит в том, что объекты функциональной области запроса после переадресации становятся недоступными, так как вы создаёте новый запрос

+ LinkedList - доступ к элементам выполняентся по итератору.
  > минусы (НЕсовсем эффективно расходуется размер списка) также и в том, что требуется небольшое место для записи для ссылки на следующий объект...

+ ITERABLE | ITERATOR
  > Iterable - это интерфейс который реализует этот "Итератор"
  > Итератор - это паттерн который позволяет получить доступ к элементам любой коллекции без вникания в суть ее имплементации.
  >> (В чем отличия TreeSet и HashSet?) https://habrahabr.ru/post/162017/
     Set - не допускает хранение двух одинаковых элементов.
	 TreeSet - обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.

+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/Spring.md

+ КОГДА СОЗДАЕТСЯ И УНИЧТОЖАЕТСЯ СЕССИЯ
  веб-сервер не поддерживает постоянного соединения с клиентом (каждый запрос обрабатывается как новый).
  Сеанс (сессия) - это механизм позволяющий однозначно идентифицировать браузер и создающий для этого браузера файл на сервере (в котором хранятся переменные сеанса).
  Сеансы используются для обеспечения хранения данных во время нескольких запросов Web-страницы
  -- http://crypto.pp.ua/2010/06/seans-sessiya-v-java/
     http://java.markune.ru/servlets/session-tracking.html
     --- getSession() - чтобы открыть новый сеанс ( метод объекта HttpServletRequest возвращает сессию пользователя ). Метод извлекает из запроса в сервлет объект сессии ( интерфейс HttpSession предоставляет методы, которые сохраняют и возвращают данные )
	     Если входной параметр равен true getSession(boolean param) то сервлет-контейнер проверяет наличие сеанса
	     В случае успеха метод возвращает дескриптор этого сеанса. В противном случае метод устанавливает новый сеанс.
		    public doGet(HttpServletRequest request) {
				HttpSession session = request.getSession(true);
			    //Если сессия не существует то ссылка на нее НЕбудет получена
				HttpSession session = req.getSession(false);
			}
		 ................................................
		 invalidate - чтобы вручную завершить сессию
		 (Java) Web-сервер - автоматически завершает сессию (когда в течение определенного времени не происходит запросов, по умолчанию 30 минут)
		 ................................................
	 --- после чего начинается сбор информации о клиенте:
         setAttribute() - чтобы сохранить значения переменной в текущем сеансе
		 getAttribute() - чтобы прочесть значения
		 getAttributeNames() - список имен всех переменных в текущем сеансе
		 removeAttribute() - чтобы удалить значения
		 getId() - возвращает уникальный идентификатор который получает каждый сеанс при создании
		 isNew() - возвращает false для уже существующего сеанса и true – для только что созданного
		 invalidate() - завершить сеанс, уничтожает все связи с объектами, и данные, сохраненные в старом сеансе, будут потеряны для всех приложений
		 getCreationTime() и getLastAccessedTime() - информацию о дате и времени создания последнего обращения к сессии
	 --- время инвалидации (жизни) сессии можно задать с помощью тега session–config в web.xml в виде:
			<session-config>
				<session-timeout>30</session-timeout>
			</session-config>
     --- Как правило при работе с сессией возникают следующие проблемы:
	     поддержка распределенной сессии (синхронизация/репликация данных, уникальность идентификаторов и т.д.);
	     обеспечение безопасности;
	     проблема инвалидации сессии (expiration) предупреждение пользователя об уничтожении сессии;

  .......................................................................................
+ INDEX (в базе данных)
  ---------------------
  >> (Индексы. Теоретические основы) http://www.sql.ru/articles/mssql/03013101indexes.shtml
  >> (14 вопросов об индексах в SQL Server) https://habrahabr.ru/post/247373/
  Физически данные хранятся на 8Кб страницах. Сразу после создания, пока таблица не имеет индексов, таблица выглядит как куча (heap) данных.
  Когда вы хотите получить доступ к данным, SQL Server сканирует всю таблицу что бы найти искомые записи.
  SQL Server не знает что в таблице существует только одна запись, удовлетворяющая условию, пока в таблице не существует: 'Unique constraint', 'Unique index' или 'Primary key'.
  В SQL Server индексы хранятся в виде B-деревьев (B-tree). 'B' означает сбалансированное (не путать с бинарным). SQL Server предлагает к использованию два типа индекса: кластерный (clustered) и некластерный (nonclustered).
  Указатель представляет собой 'Row ID' и имеет следующий формат: НомерФайла:НомерСтраницы:ПозицияЗаписи.
  ( правило, когда работаете с SQL Server: запись может быть найдена либо по 'Row ID' когда нет кластерного индекса, либо по 'кластерному ключу' )

  Индексы которые созданные на базе ОДНОГО-поля таблицы:
  > Кластерный индекс - сами данные таблицы являются частью индекса, для таблицы может быть создан только один 'кластерный индекс'.
                        В SQL Server кластерный индекс является уникальным индексом по определению (все ключи записей должны быть уникальные).
	                    Если существуют записи с одинаковыми значениями, SQL Server делает их уникальными, добавляя номера из внутреннего (невидимого снаружи) счетчика.
						( 'Кластерный индекс' является частью 'не кластерного индекса' )
  > Не кластерный индекс - cами данные не хранятся в индексе и вынимаются из таблицы, используя 'Row ID' или ключ 'кластерного индекса' (важное правило SQL Server: создавать 'кластерные ключи' нужно как можно более короткими).
                           ( Каждый 'некластерный индекс' использует значения кластерного индекса, > увеличение размера 'кластерного индекса' приводит к многократному увеличению по памяти для всех 'не кластерных индексов' и к снижению количества записей индекса способных уместиться в пределах одной страницы )

  Индекс может быть создан на основании НЕСКОЛЬКИХ-полей:
  > Составной ключ - индекс создан на основании нескольких полей, и любая группа значений по полям составного индекса является уникальной.
                     ( существует только одно ограничение – длина ключа индекса или сумма длин этих полей не должна превышать 900 байтов )
  > Уникальные индексы - гарантирует что каждое значение является уникальным в индексируемом поле
                         ( целостность данных может быть гарантирована или 'Unique constrain' или 'primary key'. В основе обоих лежит уникальный индекс )

  Доступ к записям при наличии или отсутствии индексов
  > В зависимости от наличия/отсутствия индексов и их типов, SQL Server может выбрать различные способы доступа к данным таблицы:
    - Сканирование таблицы. ( Когда индексы не используются и таблица не имеет кластерного индекса. Таблица храниться как куча 'heap' )
	- Выборка данных по 'кластерному индексу'
	- Выборка данных по 'не кластерному индексу'

  Индексы так же имеют и ряд недостатков:
  > Индексы занимают дополнительное место на диске и в оперативной памяти ( каждый раз когда вы создается индекс, сохраняется ключи по порядку...и чем больше/длиннее ключ, тем больше размер индекса )
  > Замедляются операции вставки, обновления и удаления записей


+ JPA / HIBERNATE
+ JTA-ТРАНЗАКЦИИ
  http://khpi-iip.mipk.kharkiv.edu/library/j2ee/tutoral/doc/Transaction4.html
  https://www.ibm.com/developerworks/ru/library/0610_bicheno/
  http://www.k-press.ru/cs/2006/3/WAS/WAS.asp
  JTA (Java Transaction API) - API позволяет размечать транзакции способом не зависящим от реализации менеджера транзакций.
  Чтобы разметить JTA-транзакцию нужно вызывать методы: begin, commit и rollback ( интерфейса javax.transaction.UserTransaction )
  Если изменения дают сбой тогда вызывается метод rollback и выбрасывается EJBException
  .....................................................................................
   UserTransaction transaction = context.getUserTransaction();
   try {
      transaction.begin();
      updateChecking(amount);
      machineBalance -= amount;
      insertMachine(machineBalance);
      transaction.commit();
   } catch (Exception ex) {
       try {
          transaction.rollback();
       } catch (SystemException syex) {
           throw new EJBException
              ("Rollback failed: " + syex.getMessage());
       }
       throw new EJBException
          ("Transaction failed: " + ex.getMessage());
    }
  .....................................................................................
  Основная идея использования JMS (Java Message Service) заключается в том, что разработчики создают только клиентские приложения, часть из которых является отправителями, а часть – получателями сообщений.
  > JMS-Сервер (его называют 'message broker') его просто используют подобно Web-серверам...
  > Перед началом работы программы использующей JMS на стороне JMS-сервера создаются «администрируемые объекты», это:
    - фабрики соединений (connection factories)
    – «целевые» объекты двух видов (топики 'topics' и очереди 'queues')
  > Основное отличие топиков от очередей состоит в том что:
    - очередь является просто каналом передачи сообщения единственному потребителю (реализуют программную модель «отправитель-получатель» sender-receiver)
    - а топики размножают сообщение для всех кто желает его получить (реализуют программную модель «издатель-подписчик» (publisher-subscriber)
  > Получатель сообщений может извлекать сообщения в двух режимах:
    1. синхронном - программа-получатель явно вызывает метод receive().
	                Если сообщения доступно - тогда метод возвращает сообщение; а если сообщения нет - тогда метод блокирует поток и программа ждет прихода сообщения
	2. и асинхронном - получатель реализует callback-метод onMessage() специального интерфейса MessageListener.
	                   При приходе сообщения происходит вызов и выполнение кода метода onMessage().

+ СЕКЮРИТИ
  > Декларативное управление безопасностью
    --------------------------------------
  [2] Конфигурирование аутентификации
    <login-config>
	    <auth-method>BASIC</auth-method>
    </login-config>

  [3] Название ролевой полиики
    <security-role>
	    <role-name>ADMIN_ROLE</role-name>
    </security-role>

  [4] Настройка безопасности для веб-приложения
    <security-constraint>
	    <web-resource-collection>
		    <url-pattern>/admin/*</url-pattern>
		    <http-method>GET</http-method>
		    <http-method>POST</http-method>
	    </web-resource-collection>
	    <auth-constraint>
		    <role-name>ADMIN_ROLE</role-name>
	    </auth-constraint>
    </security-constraint>

  > Программное управление безопасностью
    ------------------------------------
  [5] Использование безопасности в сервлетах (в настройках класса-сервлета):
      + '@ServletSecurity' - определяет настройки безопасности;
      + '@HttpMethodConstraint' - ограничения для каждого метода доступа;
      + 'value' - http method (GET,POST..);
      + 'rolesAllowed' - роль которая может получить доступ;
    >> @DeclareRoles ... перечисляет роли для проверки прав доступа к EJB-компоненту
    >> @RolesAllowed ... сообщает контейнеру список ролей которым позволено обращаться к методу EJB-компонента (может применятся либо к отдельному методу либо ко всему классу)
    >> @PermitAll ...... открывает доступ сразу ко всем
    >> @DenyAll ........ закрывает доступ сразу ко всем (делает недоступным класс или метод для любой роли)
    >> @RunAs .......... позволяет выполнить команду от имени другого пользователя (можно временно присвоить пользователю с одной-ролью привилегии с другой ролью)

  > Spring управление безопасностью
    -------------------------------
*       >    'Authentication' -  хранит (объединяет) имя пользователя и пароль в объект (и передается экземпляру 'AuthenticationManager' для проверки)
*                                пользователю будет предложено войти в систему предоставив имя (логин или email) и пароль
*                                представляет пользователя (Principal):
*                                # 'UserDetails' - предоставляет информацию для построения объекта 'Authentication' из DAO-объектов;
*                                # 'UserDetailsService' - создает 'UserDetails';
*            'GrantedAuthority' - представляет роли выданные пользователю в масштабе всего приложения
*       (1)> Если аутентификация прошла успешно возвращает полностью заполненный объект 'Authentication'
*            Инначе будет выброшено исключение 'BadCredentialsException' (с сообщением "Bad Credentials")
*       (2)> 'SecurityContext' - для пользователя устанавливается контекст безопасности
*                                в контексте безопасности храниться вся информация об аутентификации (логин/пароль пользователя) и авторизации (правила авторизации)
*                                (содержит объект 'Authentication' И информацию системы безопасности 'GrantedAuthority' связанную с запросом от пользователя)
*       (3)> 'SecurityContextHolder' - содержит полную информацию о текущем контексте безопасности приложения
*                                      и устанавливает стратегии для хранения информации-'SecurityContext':
*                                      #1 'MODE_THREADLOCAL' локальный поток (по умолчанию);
*                                      #2 'MODE_GLOBAL' глобальный поток;
*                                      #3 'MODE_INHERITABLETHREADLOCAL' порожденные от одного защищенного потока;
*                                      Например: в веб-приложении сервер кэширует информацию пользователя (принципала) в течение сессии и хранит 'SecurityContext' как атрибут 'HttpSession' между HTTP-запросами
*                                                (объект 'SecurityContext' извлекается из 'HttpSession' и восстанавливает контекст в 'SecurityContextHolder' для каждого запроса И очищает 'SecurityContextHolder' после завершения запроса)
*                                                Другие типы приложений, например: 'RESTful веб-сервисы' без сохранения состояния НЕиспользуют HTTP-сессии и будут требовать аутентификации при каждом запросе
*       >    Авторизированный доступ можно прикручивать на:
*            - URL-адресса ... <intercept-url pattern="/add*" access="ROLE_USER"/>
*            - методы ........ <global-method-security secured-annotations="enabled" /> | @Secured("ROLE_ADMIN")
*       >    Форма (способ) аутентификации может быть:
*            - базовый
*            - на форму
*            - ...
*       >    Декларация Spring Security через xml-конфигурацию:
*            - окружаем HTTP-запросы фильтром чтобы гарантировать их защищенность (включаем в web.xml делегирование 'DelegatingFilterProxy' И описываем в '<filter>','<filter-mapping>')
*            - определяем xml-файл с настройками Spring Security ( security.xml ) для получения защищенного web-приложения
*            - добавляем ссылки расположение на Spring Security xml-конфигурации (security.xml) в web.xml и перечисляем их: '<context-param>','<param-value>'

+ КАК РАБОТАЕТ МЕХАНИЗИ OAUTH
  - OpenID - (это чистая 'аутентификация') просто предоставляет информацию о клиенте со стороны другого сервиса (например: используется для быстрой регистрации клиента)
  - OAuth - (это чистая 'авторизация') позволяет программе от пользователя получить права (обозначаются токеном) для пользованием например каким-либо API на стороне другого-доверенного сайта
  http://softwaremaniacs.org/blog/2011/07/14/openid-oauth-difference/
*       > Что такое механихм OAuth - это способ защиты клиентского доступа.
*         Всю доверенность получает и контролирует уже НЕ сам клиент а серверное приложение.
*       > Токен - представляет собой подпись клиента, которая потом идентифицируется на стороне сервера...
*       > Есть OAuth-сервер - который выдает клиенту его токены ('рефреш-токен' и 'актив-токен')
*       > OAuth2Tokenizer - это реализация механизма клиентской автоматической аторизации на серверном приложении.
*       >> НЕавторизированный клиент идет на серверное приложение.
*          Серверное приложение проверяет его и перенаправляет на OAuth-сервер для получения клиентских токенов доступа.
*          Клиент авторизируется на этом OAuth-сервере, получает (свои) клиентские токены доступа.
*          Дальше клиент возвращается на сервер приложений и заходит уже со своими токенами.
*          После этого клиент получает доступ к методам серверного приложения.
*       >> 'рефреш-токен' это механизм авторизации клиента на серверном приложении.
*          Рефреш-токен содержит: ссылку на идентификатор рефреш-токена; OAuth-сервер; зашифрованный клиентский ключ-пароль; ключ-дешифратор;
*       >> 'актив-токен' это клиентская подпись, которая аудитенфицирует личность клиента.
*          Актив-токен содержит: имя клиента; время пользования и время истечения срока для токена; роллевую группу куда входит этот клиент; ссылка на идентификатор рефреш-токен.
*       >> И рефреш-токен и актив-токен хранятся в куках на сторое клиента.
*          Но рефреш-токен может отправляться редко-только один раз на сервер. А актив-токен часто-постоянно каждый раз при запросе отправляется на сервер.
*          Если злоумышленик перехватить актив-токен клиента - то он сможет только на короткое время им воспользоваться.
*          По истечению этого лимитного времени, серверное приложение запросит у клиента его рефреш-токен.
*          Если рефреш-токена нет - тогда доступ для такого клиента будет закрыт...
*          По рефреш-токену серверное приложение автоматически подключается к OAuth-серверу, получает информацию-подтверждения прав доступа клиента и обновляет данные клиентских токенов...
*          Для работы с токенами нужно чтобы сессия была отключена (инначе вся информация будет закешированна внутри сессии по идентификатору сессии)
*          В отличии от актив-токена, рефреш-токен очень редко участвует в клиентских запросах и поэтому вероятность что злоумышленик перехватит его будет очень низкая...
  .....................................................................................
  Токен (тоже являектся кукой, на стороне клиента)
  Наличие и время жизни токенов (куки) контролируется веб-браузером (программой), через время жизни этого токена...
  После удаления токена веб-браузером, в этом случае клиент теряет необходимые данные...и эти (куки) токены уже не восстанавливаются

+ https://habrahabr.ru/company/luxoft/blog/157273/
  > 'Locks' .................... представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
  > 'Atomics' .................. классы с поддержкой атомарных операций над примитивами и ссылками.
  > 'Concurrent Collections' ... набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.
  > 'Queues' ................... неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.
  > 'Synchronizers' ............ вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
  > 'Executors' ................ содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.


>> (git stash) http://stepansuvorov.com/blog/2012/11/git-stash-это-то-что-я-искал/
    ---------
Довольно часто при работе с git возникает ситуация, когда необходимо обновиться (сделать pull), но при этом коммитить сырой код совсем не хочется.
git stash ... команда скрывает все сделанные изменения и переводит код в состояние HEAD (после чего можно сделать pull а дальше уже накатить изменения):
> git stash
> git pull
> git stash apply
и можно продолжать работать.

Опций при работе с командой stash:
> git stash apply - применить изменения к текущей версии
> git stash list - вывести список изменений
> git stash show - вывести последние изменния
> git stash drop - удалить последние изменения в списке 
> git stash pop - [apply] + [drop]
> git stash clear - очистить список изменений

>> (git merge rebase) https://git-scm.com/book/ru/v1/Ветвление-в-Git-Перемещение
                      https://habrahabr.ru/post/161009/
"merge" - (решение для объединения веток) эта команда выполняет трёхходовое слияние между двумя последними снимками состояний (merge.PNG)
"rebase" - (перемещение) можна взять изменения представленные в ветке-C3 и применить их поверх ветки-C4 (rebase.PNG)
> git rebase master
  
>> (Spring Auto-Wiring (автоматическая привязка бинов)) http://www.quizful.net/post/Spring-Auto-Wiring
    --------------------------------------------------
Spring поддерживает 5 режимов автопривязки:
1. no ............ по умолчанию, нет авто привязки, ее нужно устанавливать вручную с использованием атрибута ref.
2. byName ........ Авто привязка по имени, если имя указанное в свойствах бина в атрибуте autowire="byName" такое же как имя бина, то привязка производится автоматически.
3. byType ........ Авто привязка по типу данных, если тип данных бина совпадает с указанным типом данных в авто привязке, то привязака производится автоматически.
4. constructor ... привязка по типу аргумента конструктора. 
5. autodetect .... если контсруктор по умолчанию найден, используется автопривязка.

В Spring вы можете привязать бин автоматически, используя функцию auto-wiring. Чтобы использовать эту функцию достаточно просто определить атрибут autowire в <bean>
------------------------------------------------------------------
<bean id="customer" class="com.test.Customer" autowire="byName" />
    - - - - - - - - - - - - - - - - - - - - - -
.. Важно:
	- Чтобы в Spring-е @Autowire мог автоматически искать подставлять реализацию для типа интерфейса - нужно обязательно объявлять интерфейс для каждого типа бина!!!
	  (инначе, если отсутствует интерфейс бина - тогда @Autowire НЕработает...)
	- В Spring-е есть несколько способов создавать бин:
	  1. в Java-стиле ........................... @Configure, @Bean
	  2. через xml-декларацию (Spring Core) ..... <Beans.xml>
	  3. через xml-декларацию (Spring MVC) ...... <mvc:annotation-driven/>, interface MyBean
	  4. в интеграционных тестах через Spring ... @RunWith(SpringJUnit4ClassRunner
	

Существует несколько способов создания бинов в Spring-е...
-------------------------------------------------------
- Либо с помощью конфигурационного xml|property-файла (в декларативном стиле), либо с через аннотации в Java-классе (в стиле Java)...
1. Если в декларативном стиле, тогда внутри <Beans.xml> нужно явно описать бины и указать расположение их классов:
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
	<bean id="customer" class="com.mkyong.common.Customer" >
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>
	<bean id="personA" class="com.mkyong.common.Person" >
		<property name="name" value="mkyongA" />
	</bean>
2. Если стиле Java, тогда внутри <context.xml> нужно указать путь какие рабочие директории Spring должен сканировать:
   И над каждым классом-бина поставить аннотацию (@Configure, @Component, @Repository, @Service, @Controller, ...)
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	<context:component-scan base-package="com.devblogs.component"/>
3. Загрузить бины с помощю "AnnotationContext":
    - - - - - - - - - - - - - - - - - - - - - -
	ApplicationContext ctx = new ClassPathXmlApplicationContext("SpringBeans.xml");
	ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");
	ApplicationContext ctx = new new AnnotationConfigApplicationContext(SpringMongoConfig.class);
======================================================= [ http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera ]
>>> (Spring изнутри. Этапы инициализации контекста) https://habrahabr.ru/post/222579
>>  (Маленькие секреты Spring) http://www.dataart.ru/blog/2014/04/malen-kie-sekrety-spring
В чем преемущество черех IoC:
- вроде как на лету можно переопределять зависимости исправляя xml-файлы
- Основное преимущество это управление зависимостями вне самих классов (в противном случае у вас в каждом классе будет куча бесполезного кода по созданию экземпляров синглтонов их переиспользованию).
IoC - одна из методик уменьшения связанности между объектами. Это подход.
DI - одна из реализаций IoC. Другая распространенная реализация - Service Locator
Идем дельше - как реализуются DI? а) контейнеры; б) фабрики.

Spring IoC - это IoC, реализованный через DI, реализованный через контейнер.
Вам стало понятнее?

Идем дальше - что такое Spring IoC? Это модуль, который реализует непосредственно контейнер. Все. То есть это Context, BeanFactory и их реализации.

Идем дальше - транзакции в Spring. Что это? Это библиотека классов. И так как эти классы имеют конструкторы, геттеры и сеттеры, то вы, само собой, можете их использовать в спринговом контексте.

IOC позволяет декларативно настроить транзакции, скоупы жизни бинов и т.д.
	
+ SPRING
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   Аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   Еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                   Cвязь между компонентами (DI - иньекция зависимостей):
*                   - выполнена через поле класса – 'Setter Injection' (SI);
*                   - или с использованием конструктора – 'Constructor Injection' (CI)
*                     При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                     В этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу...
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.
* >>>> @Scope("singleton") — ( @Singleton(true) или @Singleton(false) или @Scope("prototype") или @Scope("request") или @Scope("session") или @Scope("global-session") )
*
* >>>>> BeanFactory — это реализация паттерна Фабрика для создание бинов.
* >>>>> ApplicationContext — (из-за большей функциональности рекомендуется использование вместо BeanFactory) может быть использован для загрузки и связывания бинов.
*                            Существует 3 основных реализации:
*                            1. ClassPathXmlApplicationContext (получает информацию из xml-файла, находящегося в classpath)
*                            2. FileSystemXmlApplicationContext (получает информацию из xml-файла)
*                            3. XmlWebApplicationContext (получает информацию из xml-файла за пределами web-приложения)
*
* >> Области видимости (scopes) бинов:
*   1. singleton - (по умолчанию) IoC контейнер создает единственный экземпляр бина без сохранения состояния (stateless);
*   2. prototype - Spring IoC контейнер создает любое количество экземпляров бина с сохранением состояния (stateful);
*   3. request - жизненный цикл экземпляра ограничен единственным HTTP-запросом;
*   4. session - жизненный цикл экземпляра ограничен в пределах одной (HTTP) сессией;
*   5. global session - жизненный цикл экземпляра ограничен в пределах глобальной (HTTP) сессией;
*   6. application - жизненный цикл экземпляра ограничен в пределах ServletContext;
*
* После выхода четвертой версии спринга, у нас появилось четыре способа конфигурирования контекста:
* 1. Конфигурация через аннотации с указанием пакета для сканирования .............................................. AnnotationConfigApplicationContext(“package.name”)
* 2. Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration ... AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.
* 3. Xml конфигурация .............................................................................................. ClassPathXmlApplicationContext(“context.xml”)
* 4. Groovy конфигурация ........................................................................................... GenericGroovyApplicationContext(“context.groovy”)
  ====================== (1) property.properties, (2) ClassConfig.java, (3) context.xml, (4) context,groovy ======================

* Бин в Spring используется для ссылки на любой компонент, управляемый контейнером.
* Существует несколько способов работы с классами как Spring Bean (XML конфигурация, Java based конфигурация, Annotation based конфигурация)
* В Spring предусмотрен дополнительный механизм связывания @Autowired (чтобы аннотация заработала необходимо указать настройки в конфигурационном файле спринг 'context:annotation-config').
* По умолчанию бин задается как 'синглтон' в Spring. Таким образом все публичные  переменные класса могут быть изменены одновременно из разных мест. Поэтому Spring Bean не является потокобезопасным.
* Однако поменяв область действия бина на: 'request', 'prototype', 'session' - он станет потокобезопасным (но это скажется на производительности).
*
* По сути можно класс с любым скоупом определять в любом классе с другим скоупом...но при этом:
* - 'Singleton' бин всегда существует только в единственном экземпляре(является потоко-НЕбезопасным) И всегда будет существовать...
                Если 'Singleton' бин является зависимым для для другого объекта (то есть внутри другого объекта будет объявлено поле типа-класса 'Singleton')
				>> тогда при удалении этого другого-объекта ничего страшного НЕпроизойдет (объект удачно удалиться и программа успешно будет продолжать работать...)
* - 'Prototype' бин (или любой другой) существуют во многих экземплярах НО будет существовать только лиш кратковременно...
                Если 'Prototype' бин является зависимым для для Singleton-объекта (то есть внутри Singleton-объекта будет объявлено поле типа-класса 'Prototype')
				>> тогда при удалении этого другого-объекта удалиться и ссылка на него И это приведет к ошибке 'NullPointerException'
* В 'Singleton' бине можно успешно создавать разовые объекты для генерации например случайных чисел И такие разовые объекты успешно будут работать для всех других объектов...
*
* Чтобы можно было связывать бин обладающий меньшей областью видимости (например, session) с бином, у которого область видимости больше (например, singleton) необходимо вставлять не сами бины, а их прокси объекты
* Самое интересное начинается, когда бин (Bean) со скоупом 'prototype' вставляют в singleton-бин. Тогда появляется понятие "Прокси":
*   @Component
*   @Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
*   public class MyUserData {
*     //...
*   }
*
*   @Bean(scope = DefaultScopes.SESSION)
*   @ScopedProxy
*   public UserPreferences userPreferences() {
*     return new UserPreferences();
*   }
*
* При использовании Constructor Injection, может возникнуть еще одна проблема, известная как Кольцевая Зависимость (Circular dependencies). Представьте себе ситуацию, когда конструктор класса А требует в качестве параметра экземпляр класса B, а тот в свою очередь требует в констуркторе наличие класса A!? В этом случае, Spring Framework, не сможет „поднять“ экземпляры упомянутых компонент (beans), и выбросит исключительную ситуацию: BeanCurrentlyInCreationException. Выходом из подобной ситуации будет переход к Setter Injection. В этом случае при создании объектов, поля будут проинициализиорованы null и только в следующем проходе Spring выполнит Setter Injection.
*
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                        Cвязь между компонентами (DI - иньекция зависимостей):
*                        - выполнена через поле класса – 'Setter Injection' (SI);
*                        - или с использованием конструктора – 'Constructor Injection' (CI)
*                   При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                   в этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу...
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.


+ JAX-WS
 * @WebService — указывает на то, что Java класс (или интерфейс) является веб-службой
 * @WebMethod — позволяет настроить то, как будет отображаться метод класса на операцию веб-службы
 * @WebParam — позволяет настроить то, как будет отображаться конкретный параметр операции на WSDL-часть (part) и XML элемент
 * @WebResult — позволяет настроить то, как будет отображаться возвращаемое значение операции на WSDL-часть (part) и XML элемент
 * @Oneway — указывает на то, что операция является односторонней, то есть не имеет выходных параметров
 * @SOAPBinding — позволяет настроить то, как будет отображаться веб-служба на протокол SOAP
 *
 * 1. Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
				@WebService(name="EntityPortMyType", targetNamespace = "http://my.domain.com/ws/definitions")
				public interface EntityManager{
				    @WebMethod
				    long addEntity();

				    @WebMethod
				    long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );

				    @WebMethod
				    void removeEntity( @WebParam(name = "id")long id );
				}
 * 2. Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
 *      portName        - должен указывать на порт того типа, что прописан в интерфейсе
 *      targetNamespace - должен быть такой же, как и у интерфейса
 *      endpointInterface - точно указывать на полное имя реализуемого интерфейса
 *      wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
				@WebService(serviceName = "EntityManager",
				            portName="EntityPortMyType",
				            endpointInterface = "com.mydomain.webapp.domain.EntityManager",
				            targetNamespace = "http://my.domain.com/ws/definitions",
				            wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")

				public class EntityManagerImpl implements EntityManager{
				    public long addEntity(){
				        // method body
				        return 0;
				    }

				    public long findEntity(IdentityType i_type, String identity){
				        // method body
				        return 0;
				    }

				    public void removeEntity(long id){
				       // method body
				    }
				}
 * 3. В pom файле проекта необходимо совершить:
 *    - вставить код для jaxws-maven плагина,
 *    - обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть)
				<plugin>
				        <groupId>org.codehaus.mojo</groupId>
				        <artifactId>jaxws-maven-plugin</artifactId>
				        <executions>
				            <execution>
				                <goals>
				                    <goal>wsgen</goal>
				                </goals>
				            </execution>
				        </executions>
				        <configuration>
				            <resourceDestDir>${basedir}/src/main/webapp/WEB-INF/wsdl</resourceDestDir>
				            <sei>com.my.domain.webapp.domain.EntityManagerImpl</sei>
				            <genWsdl>true</genWsdl>
				            <keep>true</keep>
				            <packageName>com.my.domain.webapp.domain</packageName>
				        </configuration>
				</plugin>
				<dependency>
				     <groupId>com.sun.xml.ws</groupId>
				     <artifactId>jaxws-rt</artifactId>
				     <version>2.1.3</version>
				</dependency>
 * 4. Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
 *    - Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
 *    - Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener)
				 <listener>
				    <listener-class>
				        com.sun.xml.ws.transport.http.servlet.WSServletContextListener
				    </listener-class>
				</listener>

				<servlet id="ws-entities-servlet">
				    <servlet-name>EntityService</servlet-name>
				    <servlet-class>
				        com.sun.xml.ws.transport.http.servlet.WSServlet
				    </servlet-class>
				    <load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping id="ws-entities-servlet-mapping">
				    <servlet-name>EntityService</servlet-name>
				    <url-pattern>/app/entities</url-pattern>
				</servlet-mapping>
 * 5. Создать файл sun-jaxws.xml
 *      Но что же сервлет будет делать с запросом, пришедшим на url-pattern?
 *      В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки:
				<?xml version="1.0" encoding="UTF-8"?>
				<endpoints
				        xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"
				        version="2.0">
				    <endpoint name="EntityManager"
				            implementation="com.my.domain.webapp.domain.EntityManagerImpl"
				            url-pattern="/app/entities"/>
				</endpoints>
 * 6. Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса
				http://localhost:8080/my-webapp/app/entities?wsdl



ConcurrentLinkedQueue:
.element()
.pull()
.peek()
.pop()

++++++++++++++++++++++++++++++++++++++
Стек - это структура данных, хранящая объекты в порядке "первым вошел, последним вышел" или "последним вошел, первым вышел".
       Обычно у этой структуры есть API с такими методами, как push() и pop(). Иногда присутствует метод peek().

Метод push() - принимает входной объект (например: foo и помещает его во внутренний контейнер; например: массив).
               Метод push() обычно ничего не возвращает.

Если передать методу push() два объекта, например, сначала foo, а потом bar - второй объект bar должен оказаться наверху концептуального стека, содержащего по крайней мере два объекта, так что при вызове метода pop() объект bar должен быть извлечен первым, до первого объекта foo. Если метод pop() вызвать еще раз, должен быть возвращен объект foo и стек должен стать пустым.

Метод pop() удаляет самый последний элемент, добавленный в стек - да, метод pop() должен удалить верхний элемент, при этом предполагается, что в стеке есть элементы, чтобы их удалять.

Метод peek() - работает точно также (метод pop()), но при этом объект не удаляется.
               Метод peek() должен оставить верхний элемент в стеке.

Если вызвать метод pop(), когда в стек еще ничего не было добавлено -  метод pop() должен выдать исключение, показывающее, что в стек еще ничего не добавлялось.

Если выполнить команду push() null - стек должен выдать исключение, так как null не является допустимым значением для метода push().
++++++++++++++++++++++++++++++++++++++
Akka - заботится о потоках и синхронизации...
Spray - это простой но мощный инструмент для построения REST/HTTP сервисов (ничего лишнего)
Play! - это фреймворк для построения RESTFul API (содержит много вещей которые мы не используем)
Slick - работа с базой данных
Scalaz - упрощает программирование в функциональном стиле

ScalaTest - тестирование, близко напоминает тесты в стиле JUnit (удобно)
Specs2 - применяется в стиле модульного тестирования
FlatSpec - для перехода от JUnit-тестированию к использванию BDD-тестирования
Spock - фреймворк для написания тестов в стиле Behaviour-Driven Development (BDD), (для Java и Groovy приложений)

Test-Driven Development (TDD) - это техника программирования, когда модульные тесты пишутся до самой программы
"test-case" (тест кейс) - выполняет одноно типовое действие над исследуемой системой (аргумент1=действие1)
Data-Driven Testing (DDT) - это тесты управляемые данными, когда тестовые данные хранятся отдельно от скриптов
"data-driven" (тест, управляемый данными) - один алгоритм проверки и много вариантов входных данных
Behaviour-Driven Development (BDD) - разработка основанная на функционировании (как программа работает, а не что она производит в конечном итоге)

Simple Build Tool (SBT) - Стандартное средство сборки приложений для Scala
Spark - представляет собой новую кластерную вычислительную среду, обладающую полезными особенностями
Docker - система виртуализации
Agile - это ускоряющая методология создания проектов. Она минимизирует риски посредством коротких (2–3 недели)циклов, или итераций, разработки.
+++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++
Scala, Akka, Multithreading, Algorithms, Machine Learning, Design Patterns
Also have some experience with: Spark, Hadoop, Docker, Play
Методология Agile

Core Java, Concurrency;
J2EE: Servlets, JPA, JMS
Spring: MVC, Security, Data, IOC
Scala: Collections, Akka;
Testing: JUnit, Mockito, Specs2, Spock;
maven, sbt, git, svn;
Linux: Bash scripting, using as server system;

ScalaTest
FlatSpec

Understanding of SQL and NoSQL concepts
Practical Spark experience or Spark MooC certificates is a big plus
Experience in optimising application performance and database queries

+ Low latency\Heavy loaded project
+ Reactive Programming (Kiev Polytechnic Institute)
+ + + + + + + + + + + + + + + + + + + +
ОБЯЗАТЕЛЬНЫЕ ТРЕБОВАНИЯ
    Знания Scala на уровне A2/L1.
    Опыт использования ORM (Hibernate, Slick и пр.).
    Умение использовать системы автоматического тестирования (JUnit, ScalaTest, ScalaMock).
БУДЕТ ПЛЮСОМ
    Опыт ведения проектной документации.
    Знание протокола HTTP и WebSockets.
    Опыт использования Scala-фреймворков Play 2, Akka (spray).
    Опыт использования NoSQL (например, Cassandra, Spark, MongoDB).
    Опыт установки и администрирования серверов приложений (Tomcat, GlassFish, JBoss).
    Владение инструментами для сборки проектов (Gradle, SBT).
    Опыт использования систем Continuous Integration (TeamCity, Jenkins).

Akka framework
Machine learning as a plus

Обязанности:
    Рефакторинг и оптимизация существующего решения.
Требования:
    Опыт работы с akka, spray, slick от года;
    Убежденность в необходимости написания тестов;
    Опыт решения задач интеграции с другими системами;
    Понимание принципов работы HTTP, Websockets;
    Опыт работы с high load решениями будет плюсом.
+++++++++++++++++++++++++++++++++++++++




(стартап) IT-Project
--------------------
Akka framework (Akka HTTP, Akka-HTTP-Sessions)
SecureSocial (Silhouette)
Spray
Finagle
Play Framework
Apache Spark
Docker
++++++++++++++++++++
Akka (Akka Cluster)
SecureSocial (Silhouette) - OAuth2
Spray
Spark & Spark Notebook
Hibernate, Slick
SBT

NodeJS
Angular











P. 142 | Practice 2
-------------------
#1
Do you go to shcool by car? Yes, I do.
Do they live in New York? Yes, they do.
Do you work at home? No, I don't.
Do they get up early? No, they don't.
Do you have breakfast? Yes, I do.
Do you study in Russian? No, I don't.

#2
Have you live in a flat? No, I haven't.
Are Marek and Monika married? No, they aren't.
Have your parents go out a lot? Yes, they have.
Heve you got a new computer? No, I haven't.
Do you have launch in a cafe at the weekend? Yes, I have.
Have you work in the city centre? No, I haven't.
Are they fron Italy? No, they aren't.


P. 143 | Practice 3
-------------------
#1
1)  6:05
2) 10:35
3)  8:30
4) 10:20
5) 11:40
6)  3:15
7)  9:00
8)  9:45

#2
a) half past three
b) quarter past six
c) ten past five
d) elevent oclock
e) quarter to six
f) twenty-five to ten
g) five to four
h) twenty past seven
i) twenty to ten
j) five past one


P. 143 | Remember these words
-----------------------------
>> (Предлоги) http://english-tutorial.ru/grammar-96/
 -=ЕСЛИ ПРИСУТСТВУЕТ СЛОВО ЧТО УКАЗЫВАЕТ НА ВРЕМЯ=-
0. предлог не ставится если выражение включает одно из слов: 'next','last','this','that','one','any','each','every','some','all'
   перед названиями дней в разговорной речи часто опускается предлог 'on' а периодичность может обозначаться словами days, nights, mornings, evenings, afternoons.
 -=ВРЕМЯ ЧТО ВНУТРИ МЕНЕЕ-СУТОК=-
1.          'at' используется для обозначения внутрисуточного времени: at 10 o’clock, at 7.45, at midnight, at night, at dinner.
   ставится перед словами выражающими периодичность или сиюминутность: at the weekend, at weekends.
                                                 популярные праздники: at Christmas, at New Year, at Easter.
                                                    отдельные моменты: at the moment, at present, at the same time.
 -=ДЛЯ ДАТ, ДЛЯ (ДАТ)ПРАЗДНИЧНЫХ ДНЕЙ, ДЛЯ (ДАТ)ДНЕЙ НЕДЕЛИ=-
2.                                        'on' используется для обозначения дней недели: on Monday, on Tuesdays.
                                                                       даты и праздники: on 21 March 1996, on April 1st, on Christmas Day, on my birthday
   если перед временем суток указан день недели то словосочетание идет с предлогом 'on': on Saturday morning, on Sunday evening
 -=ВРЕМЯ НА БОЛЕЕ ДЛИТЕЛЬНЫЕ-ПЕРИОДЫ И ВРЕМЯ НА ПРОМЕЖУТОК ВРЕМЕНИ=-
3. 'in','in the' характеризует наиболее продолжительные периоды (месяцы, сезоны, года): in January, in (the) winter, in 1984, in the 1960s, in the 20th century, in the past, in (the) future.
                 еще 'in','in the' определяет за какой промежуток выполняется действие: in the morning(s), in the afternoon(s), in the evening(s), in the night. Окончание -s указывает на то что событие повторяется каждый упомянутый период.
-----------------------------
>> (Английские предлоги места) http://online-teacher.ru/study/english-predlogi-mesta
1.          'at' находится временное-короткое-время где-то внутри чего-то: at the railway station, at the theatre, at the birthday party
2. 'on' находится временное-короткое-время возле,около,на чем-либо сверху: on the right side, on the sixth floor, on the radio, on TV
3. 'in','in the' находится более-длительное-время где-то внутри (в рамках) чего-то: in Berlin, in the train, in the letter
+. next to, beside, by: непосредственно рядом, очень близко от чего-либо
+. under: расположение ниже/под чего-либо
+. below: расположение ниже какого-либо уровня
+. over: расположение сверху (на поверхности) чего-либо
+. above: расположение над чем-либо (выше)
+. across: расположение с другой стороны; переход на другую сторону чего-либо
+. through: прохождение насквозь, движение сквозь что-либо
+. to: движение по направлению к кому-либо или к чему-либо
+. into: движение, перемещение внутрь чего-либо
+. towards: движение по направлению к чему-либо или кому-либо, приближение без необходимости достижения цели
+. onto: движение, перемещение наверх
+. from: движение откуда-либо, от какой-то отправной точки; указание на происхождение

There is a great difference between her wishes and his possibilities. == ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
-----------------------------
 -=МЕСТО=-
a cinema ........... кинотеатр
a swimming pool .... басейн
a beach ............ пляж
a park ............. парк
a block of flats ... блочный дом (для жилья)
a restaurant ....... ресторан
  small shops ...... магазин
a supermarket ...... супермаркет
a street market .... рынок
a shopping center .. (сеть магазинов)
 a town ............ (маленький) городок
 a city ............ (большой) город
 a village ......... село
 -=ВРЕМЯ=-
at midday .......... в (конкретно-точно) полдень (= одного дня..)
at lunchtime ....... в (конкретно-точно) время обеда (= одного дня..)
at midnight ........ в (конкретно-точно) полночь (= одного дня..)

at the weekend ..... в этот (конкретно-точно) выходной день (= одного дня..)

in the morning ..... в течении утра (в один из какого-нибудь часа = между-через..)
in the afternoon ... в течении после обеда (полудень - в один из какого-нибудь часа = между-через..)
in the evening ..... в течении вечера (в один из какого-нибудь часа = между-через..)

on weekdays ........ в один из (какой-нибудь день) будних дней (в течении рабочей недели = на протяжении..)
 -=ДЕЙСТВИЕ=-
to open ............ (делать) открывать
to close ........... (делать) приближаться
to finish .......... (делать) останавливаться
 -=...=-
by bus ............. НА автобусе

#1
1. I LIVE in a big flat in Milan.
2. They HAVE breakfast in a cafe at the weekend.
3. We STUDY English after school.
4. I GET UP at 6:00 in the morning.
5. You GO to scool by bus and train.
6. I WORK long hours for a big company.

#2
1. I get up AT half past seven.
2. They play football ON Saturdays.
3. Do you have lunch AT midday?
4. I don't work AT the weekend.
5. Do they sleep IN the afernoons?
6. I go to bed early ON weekdays.
7. We wotch TV IN the evenings.
8. They shops close AT lunchtime.

P. 31 | Useful language
#A.
1. Most people live in flats in the city.
2. Children start school at half-past eight.
3. Most people have lunch in offices.
4. Shops close at 13:00 oclock for lunchtime.
5. Yes, they do.
6. Restaurants close at 11:00 p.m.
7. Yes, it does.
8. People have dinner at 8:00 p.m.

#B.
1. Most people live in flats in the city.
2. Most people don't live in the city centre.
3. Children start school at 8:30 a.m., and finish school at 2:30 p.m.
4. Most people don't go home for lunch, because they have lunch in offices.
5. Most shops open at 9:00 a.m. and close at 21:00 o'clock.
6. Most people have lunch at 12:00 o'clock and have dinner at 20:00 oclock.
7. Restaurants open at 9:00 a.m. and close at 9:00 p.m.


(H/W) P. 34
-----------
>> () http://englishbigidea.blogspot.com/2013/12/Like-love-hate-prefer.html
#1
# из инфинитива (ing) в >> I go for walks on holiday...
going for walks ................ гулять
dancing ........................ танцевать
cycling ........................ ездить на велосипеде
reading ........................ читать
cooking ........................ готовить
spending time with friends ..... проводить время с друзъями
plaing computer games .......... играит в компьютерные игры
wathing sport .................. смотреть спорт
spending time on the internet .. проводить время в интернете
swimming ....................... плавать

> I go for walks on holidays.
> I never dance.
> Sometimes I ride a bicycle.
> I often read books.
> Sometimes I cook.
> Sometimes I spend time with my friends.
> I never play computer games.
> I never wath sport.
> I often spend time on the internet.
> Sometimes I go to swim in the pool.

#2
>> To love ..... любить
>> To like ..... нравится
>> To hate ..... ненавидеть
>> To prefer ... предпочитать
>> To want ..... хотеть

> Do you go for walks on holiday?
  Yes, I do.
> Do you like dancing?
  No, I don't.
> Do you like cycling?
  Yes, I do.
> Do you like reading books?
  Yes, I do.
> Do you like cooking?
  No, I don't. I hate it.
> How often do you spend time with your friends?
  I spend time with my frends once or twice a month.
> Do you play computer games?
  Yes, I do. I like it.
> Do you watch sport?
  No, I don't.
> How much time do you spend on the internet?
  I spend four or five hourson the internet.
> Do you like swimming?
  Yes, I do. I like swimming.


P. 35 | Practice 1
- - - - - - - - -[ Like/Dislikes with noun and -ing ]
+ Like.
+ Love.
~ Don't mind.
- Hate.
- Can't staund.
- Don't like / Dislike.

She lives in a big house.
She doesn't like doing big concerts.
She likes comfortable clothes.
She hates the food on aeroplanes.
She doesn't like flying.
She loves singing.
------------------
#1a
1.        (go for restaurants) > She hates going to restaurants.
2. (go for walks with her dog) > She likes going for walks with her dog.
3.                       (fly) > She doesn't like flying.
4.                (her mother) > She loves her mother;
5.   (spend time with friends) > She likes spending time with friends
6.           (do big concerts) > She doesn't like doing big concerts.
7.             (black clothes) > She hates black clothes.
8.    (the food on aeroplanes) > She hates the food on aeroplanes.
















(mongodb test)
https://www.tutorialspoint.com/mongodb/mongodb_mock_test.htm
https://github.com/mongodb/mongo/wiki/Test-The-Mongodb-Server
https://docs.mongodb.com/getting-started/shell/import-data/
(How to Load Test MongoDB with JMeter) https://www.blazemeter.com/blog/how-load-test-mongodb-jmeter
https://www.owasp.org/index.php/Testing_for_NoSQL_injection
(spring mongodb test)
http://stackoverflow.com/questions/29587430/spring-data-mongodb-junit-test
(embedded mongodb java)
http://stackoverflow.com/questions/6437226/embedded-mongodb-when-running-integration-tests
http://www.pretechsol.com/2012/09/java-mongodb-junit-test-with-embedded.html#.WA2_miQhWM8
(nosql java test)
http://www.methodsandtools.com/tools/nosqlunit.php
http://www.slideshare.net/tobiastrelle/no-sql-testautomation
https://dzone.com/articles/testing-spring-data-mongodb-0
https://eclipse.googlesource.com/eclipselink/examples/+/dcf45221d60f9ad69052fa54d87ab286197a52fd/jpa/nosql/mongo/src/test/java/example/Test.java
(Basic Mistakes in Database Testing) https://dzone.com/articles/basic-mistakes-database
(NoSQLUnit) http://lordofthejars.github.io/nosql-unit/nosqlunit.html
			http://www.lordofthejars.com/2012/06/nosqlunit-030-released.html >> https://github.com/lordofthejars/nosql-unit
			https://www.javacodegeeks.com/2012/04/dbunit-spring-and-annotations-for.html >> https://github.com/springtestdbunit/spring-test-dbunit/tree/master/spring-test-dbunit-sample >> http://lordofthejars.github.io/nosql-unit/nosqlunit.pdf
                          (spring nosql database testing)
(Testing Spring Data MongoDB Applications with NoSQLUnit) http://www.lordofthejars.com/2013/01/testing-spring-data-mongodb.html

                 (json validator java)
(Validate JSON against Schema in Java) http://wilddiary.com/validate-json-against-schema-in-java/
                                       https://github.com/daveclayton/json-schema-validator >> https://github.com/daveclayton/json-schema-validator/blob/master/src/main/java/com/github/fge/jsonschema/examples/Example1.java

(Гироборд (Гироскутер / Ховерборд) под Заказ) 5200 грн.
https://www.olx.ua/obyavlenie/girobord-giroskuter-hoverbord-pod-zakaz-IDlkrSv.html#e692397b73

               (opengl шейдеры)
(Шейдеры в libgdx для чайников) https://habrahabr.ru/post/274813/
Kanban
Java 8, Spring, Spring Security, Jetty, NoSQL,
Git, Sonar, TeamCity
Automation Testing
Cassandra, Kafka, Node.js, Backbone.js

Spring: '@Authowired' или 'set-ер' - почему?




https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377534
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377567
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377574
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377595



В класе-интерфейса можно создавать поля-переменные, только НУЖНО их сразу-же здесь иннициализировать (типа как finul..)!!!


>> (Столкнулся с такой проблемой - редактировал файл style.css через Notepad++) http://ru.stackoverflow.com/questions/335561/Восстановить-содержимое-файла













PL/SQL — процедурный блочно-структурированный язык.
> Создание пакетов, процедур и функций, хранимых в базе данных.
> Предоставление интерфейса для вызова внешних процедур.
> Поддержка типов данных SQL и внутренних типов PL/SQL.
> Работа с курсором.
> Механизм обработки исключений.

> Не чувствителен к регистру (кроме строковых переменных и констант).
> Каждая конструкция PL/SQL должна заканчиваться символом ;
> Одна конструкция может быть расположена на нескольких строках.

> Блок — основная структурная единица PL/SQL.
  Блок позволяет объединять объявления и операторы, связанные общей логикой.
  >> Может быть анонимным или именованным.
  >> Может содержать вложенные блоки.
  >> Составные части блока:
     секция объявлений;
     тело блока (обязательная часть);
     обработчики исключений.

DECLARE
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код программы (обязательная часть блока)
EXCEPTION
  -- Обработка исключений
END;
/* Многострочные
комментарии… */
-- Однострочный комментарий

Переменные:
    Могут иметь тип данных SQL или PL/SQL.
    Объявляются в секциях объявлений блоков PL/SQL.
    Видны внутри блока, в котором они объявлены.
    Получают тип данных при объявлении.
    Могут быть проинициализированы значением при объявлении.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

3 Слайд: Часть 1. Структура кода в PL/SQL
    3.1 Слайд: Блоки PL/SQL
    3.4 Слайд: Объявление переменных
    3.7 Слайд: Операторы выбора (IF)
    3.8 Слайд: Операторы выбора (CASE)
    3.11 Слайд: Операторы цикла (простой LOOP)
    3.12 Слайд: Операторы цикла (WHILE LOOP)
    3.13 Слайд: Операторы цикла (FOR LOOP)
    3.15 Слайд: Операторы перехода (GOTO)
4 Слайд: Часть 2. Основные типы и структуры данных
    4.1 Слайд: Типы данных
    4.4 Слайд: Приведение типов
    4.6 Слайд: Коллекции
    4.9 Слайд: Записи
    4.11 Слайд: Атрибуты типизации
5 Слайд: Часть 3. Взаимодействие с БД
    5.1 Слайд: Извлечение и обработка данных
    5.5 Слайд: Курсоры
    5.12 Слайд: Вызовы SQL в PL/SQL-ном блоке
    5.14 Слайд: Динамический SQL — пример
    5.15 Слайд: Управление изменениями
    5.18 Слайд: Триггеры
6 Слайд: Часть 4. Исключения
    6.1 Слайд: Обработка ошибок
    6.3 Слайд: Предопределенные исключения
    6.4 Слайд: Объявление исключений
7 Слайд: Часть 5. Подпрограммы
    7.1 Слайд: Функции, процедуры
    7.6 Слайд: Параметры
    7.9 Слайд: Перегрузка функций, процедур
    7.11 Слайд: Рекурсивный вызов
8 Слайд: Часть 6. Пакеты PL/SQL
    8.1 Слайд: Структура пакета
    8.3 Слайд: Доступ к элементам пакета
    8.4 Слайд: Инициализация данных пакета
9 Слайд: Часть 7. И еще...
    9.1 Слайд: Получение информации из запроса/блока/функции
    9.3 Слайд: Системные представления
    9.4 Слайд: Механизм заданий (jobs)
    9.7 Слайд: Коротко об sqlplus

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Курсор — получаемый при выполнении запроса результирующий набор записей плюс привязанный к нему указатель текущей записи.
Курсоры:
    Явные (объявляются разработчиком).
    Неявные (не требуют объявления, управляются автоматически).
Состояние курсора — атрибуты:
     %ISOPEN
     %FOUND
     %NOTFOUND
     %ROWCOUNT

Триггеры на события DML (на строку/на операцию).
Триггеры INSTEAD OF.
Триггеры на события DDL.
Триггеры на события уровня схемы/БД

1. Обработка ошибок
2. Предопределенные исключения
3. Объявление исключений
Исключение — ошибка времени выполнения.
    Нормальное выполнение блока прекращается.
    Управление возвращается внешнему (вызвавшему) блоку.
    ...до тех пор, пока исключение не будет «перехвачено» и обработано:
        выдано user-friendly сообщение пользователю;
        записано в лог;
        проигнорировано;

Подпрограмма — именованный блок PL/SQL, который может иметь параметры вызова.
Аналогично анонимным блокам могут быть вложенными.

PROCEDURE процедура (параметры) AS
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код процедуры (обязательная часть подпрограммы)
EXCEPTION
  -- Обработка исключений
END процедура;

Функция
	Возвращает некоторое значение.

FUNCTION функция (параметры)
  RETURN тип_значения
AS
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код функции (обязательная часть подпрограммы)
EXCEPTION
  -- Обработка исключений
END функция;

Пакет — хранимый объект, объединяющий логически близкие типы, данные, подпрограммы.

CREATE OR REPLACE PACKAGE пакет AS
  TYPE какой_то_тип AS /*...*/;
  какая_то_переменная тип;
  PROCEDURE какая_то_процедура;
  FUNCTION какая_то_функция RETURN тип;
  --...
END пакет;

Утилита SQL*Plus: позволяет выполнять команды SQL и блоки PL/SQL.
sqlplus — работа в окне командной строки
sqlplusw — оконная версия

sqlplus /NOLOG @script.sql param1 param2

/*script.sql*/
-- Определить код возврата при ошибке
WHENEVER SQLERROR EXIT -1 ROLLBACK
-- Подключиться к БД (параметризовано)
CONNECT &1/&2@ORAXE;
-- Включить вывод
SET SERVEROUTPUT ON;
-- Логировать действия в файл
SPOOL test.log;
-- Объявить и присвоить bind-переменную
var v_cnt NUMBER;
EXEC :v_cnt := 30;
-- Выполнить команду SQL
SELECT * FROM emp WHERE deptno = :v_cnt;
-- Выполнить блок PL/SQL
BEGIN
    dbms_output.put_line('Listed employees for deptno '|| :v_cnt);
END;
/
-- Выйти с кодом "успешно"
EXIT 0;


1. Типы данных
   Простые (скалярные) типы (простые значения без внутренних составляющих):
    NUMBER(точность, масштаб) — число с плавающей точкой;
    CHAR2(размер) — строка постоянной длины;
    VARCHAR2(макс_размер) — строка переменной длины;
    DATE — дата (со временем);
    BOOLEAN — логическое значение;
   Составные типы (структуры из определенных компонент):
    TABLE — коллекция;
    VARRAY — массив;
    RECORD — запись.
   Ссылочные типы: ссылка на объект, например REF CURSOR.
   LOB типы: «локатор», определяющий расположение больших объектов данных (графика, файлы,...):
    BFILE — внешний двоичный файл;
    BLOB — внутренний двоичный объект;
    CLOB — внутренний символьный объект.
2. Приведение типов
     Явное:
        TO_NUMBER()
        TO_CHAR()
        TO_DATE()
        ...
    Неявное.
3. Коллекции
    Таблицы PL/SQL (TABLE)
    Массивы (VARRAY)
   Методы работы с коллекциями:
    EXISTS(индекс_элемента) — существует ли элемент по индексу?
    COUNT — количество элементов в коллекции.
    LIMIT — размер varray-массива.
    DELETE(с_элемента, по_элемент) — удалить элементы: все; один; диапазон.
    FIRST, LAST — индексы первого и последнего элемента.
    PRIOR(индекс_элемента), NEXT(индекс_элемента) — индексы следующего и предыдущего элемента.
4. Записи (RECORD)
5. Атрибуты типизации
     %TYPE
        Объявление переменной с типом другой переменной.
        Объявление переменной с типом поля таблицы в БД.
     %ROWTYPE
        Объявление переменной типа запись, по структуре соответствующей строке таблицы в БД.

Взаимодействие с БД:
1. Извлечение и обработка данных
2. Курсоры
3. Вызовы SQL в PL/SQL-ном блоке
4. Управление изменениями
5. Триггеры


Управление изменениями
Транзакция — последовательность действий с БД, которая:
    или полностью фиксируется в БД,
    или полностью отменяется.
Все SQL-операторы входят в одну транзакцию до тех пор, пока не будет сделана ее фиксация (COMMIT) или откат (ROLLBACK).
    Уровни изоляции транзакций.

Сложная (поэтапная) логика действий с БД: промежуточные точки отката
-- Начало действий с БД
--...
SAVEPOINT имя; -- Точка отката
-- Логически сгруппированные действия, которые если что следует
-- откатывать вместе без отката всей транзакции
ROLLBACK TO SAVEPOINT имя;
--...
COMMIT; -- Фиксация транзакции

Фиксация изменений в БД даже при откате транзакции: автономные транзакции
	PRAGMA AUTONOMOUS_TRANSACTION;
Блокировки.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/* Пакет реализует API доступа к данным сотрудников:
- получение имени сотрудника по его номеру
- получение названия подразделения сотрудника по его номеру
Обращения к БД кешируются.
*/
CREATE OR REPLACE PACKAGE pk_emp AS
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2;
END pk_emp;

CREATE OR REPLACE PACKAGE BODY pk_emp AS
    TYPE TStringArray IS TABLE OF VARCHAR2(100) INDEX BY BINARY_INTEGER;
    la_emp TStringArray;
    la_dept TStringArray;
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        IF NOT la_emp.EXISTS(a_empno) THEN
            SELECT ename INTO la_emp(a_empno)
                FROM emp
                WHERE empno = a_empno;
        END IF;
        RETURN la_emp(a_empno);
    END get_name;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        RETURN la_dept(a_empno);
    END get_dept;
BEGIN
    FOR lc IN (SELECT empno, dname FROM emp e, dept d WHERE d.deptno = e.deptno)
    LOOP
        la_dept(lc.empno) := lc.dname;
    END LOOP;
END pk_emp;