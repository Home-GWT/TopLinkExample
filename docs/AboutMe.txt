
Я разработчик ПО с четырех-летним стажем.
Я специализируюсь в области Java.
Мне приходилось разрабатывать разного рода приложения:
- десктопные Java приложения;
- мобильные Java приложения;
- веб приложения;
Я разрабатывал ПО с помощью следующих языков программирования: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS...

Моим первым местом работы была компания HostingMax.
Это было в 2007-2008 году.
Моими обязаностями являлось разработка мобильных игр для мобильных платформ (Nokia, Samsung, Simens, Alkatel, BlackBarry..).
Здесь я познакомился и изучил технологии J2ME, (Java Media Framework, Mobile Information Device Profile).
А также я разрабатывал мобильную службу SyncML для синхронизации и восстановления персональных данных в мобильных устройствах.

Последним моим местом работы является компания ПриватБанк.
Это было в 2012-1016 год.
Моими обязанотями являлось разработка веб-сервисов для банковских услуг.
Здесь применялись технологии: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
Использовались базы данных MySQL, IQ/ASE, Redis, MongoDB.
Я самостоятельно вел разработку одного отдельного проекта (это корпоративный проект).
И был участником в группе где разрабатывались разные веб-сервисы (это сервлеты, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
Программный код покрывался JUnit, JMock и DBUnit тестами.
Также для глобального тестирования применялись инструменты: SonarQube, SoapUI, JMeter.
В приложении было включено логирование (Log4j).

Кроме веб-сервисов я разрабатывал библиотечные классы (которые потом использовались этими веб-сервисами).
Все разработки велись на Linux системе.
В качестве сборщика использовал ANT, Meven.
Системы контроля версий SVN, GIT.

Более всего мне запомнился проект сервиса для платежной системы.
Здесь применялись технологии: Java-7, Spring-3 (Data/Security/MVC/REST), (ORM-framework) JPA/Hibernate-3
База данных IQ, PostgreSQL.
Этот сервис использовал LiqPay.
Требовалось разработать библиотечные классы для применнеия этим приложением.
Общение с сервисом внутри приложения выполнялось через SOAP-протокол.

+++++++++++++++++++
+++++++++++++++++++
I am an IT developer with 4 years of experience.
I have spent the last four years developing my skills as a banking applications and been promoted once.
My first job was as an developer for mobile soft at HostingMax company.
I am expert in managing teams and solving customer problems.
Although I love my current role, I feel I am now ready for a more challenging assignment.

I can summarize who I am in so:
- Hardworking;
- I am quiet working under pressure;
- I have an open mind about what will work best;
- Attention to all the details;
- Able to keep deadlines successfully;
- Fast-learner, self-motivated and determined;

I have a stable work history.
I think one of my greatest strengths is as a problem solver.
I have the ability to see a situation from different perspectives and I can get my work done even in the face of difficult obstacles.

Nobody is perfect.
I get impatient with team members who are making mistakes or delivering substandard work.

*   >>> http://lelang.ru/english/series/garri-potter-i-filosofskij-kamen-na-anglijskom-s-subtitrami/
*** >>> http://vasabi.tv/video/341-harry-potter-and-the-philosophers-stone/
        http://vasabi.tv/user/profile/admin/
		http://vasabi.tv/video/91-breaking-bad-sezon-1-epizod-1/
*   >>> (harry-potter-and-the-philosopher's-stone books) http://www2.sdfi.edu.cn/netclass/jiaoan/englit/download/Harry%20Potter%20and%20the%20Sorcerer's%20Stone.pdf
+ + + + + + + + + +
+ + + + + + + + + +
>> (5 простых правил порядка слов в английском) http://skyeng.ru/articles/5-prostyh-pravil-poryadka-slov-v-anglijskom
                                                https://www.native-english.ru/grammar/word-order
											  ( http://online-teacher.ru/study/english-predlogi-mesta )

|ОБСТОЯТЕЛЬСТВО МЕСТА-ВРЕМЕНИ| + [ПОДЛЕЖАЩЕЕ-СУЩЕСТВИТЕЛЬНОЕ] + [СКАЗУЕМОЕ-ГЛАГОЛ] + |ДОПОЛНЕНИЕ-ПРИЛАГАТЕЛЬНОЕ СУЩЕСТВИТЕЛЬНОЕ| + |ОБСТОЯТЕЛЬСТВО МЕСТА/ВРЕМЕНИ-ПРИЛАГАТЕЛЬНОЕ|

We (подлежащее) do (сказуемое) our work (дополнение) with pleasure (обстоятельство места и времени).
Мы [существительное] делаем [глагол] нашу работу [дополнение-существительное] с удовольствием [прилагательное].

At the moment I cannot talk.
В настоящий момент я не могу говорить.
В настоящий момент (дополнение-места/времени) ... я (кто?) не могу (дополнение) говорить (что делать?)

There is a great difference between her wishes and his possibilities.
ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
= = = = =
(что?) ... существует (что делает?) огромная (какая?) разница (дополнение-что?) ...


>> (EnglishLessons4U - Learn English with Ronnie) https://www.youtube.com/channel/UC4cmBAit8i_NJZE8qK8sfpA


I am a software developer with five-years of experience.
I specialize in the area of Java/JavaScript and Scala.
I had to develop different kinds of applications:
- The desktop Java applications;
- The mobile Java applications;
- And the web applications;
I developed the software using following programming languages: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS ...(for example)

My first job was the "HostingMax" company.
It was in the 2007-2008 year. (start twenty and seven last twenty and eight)
My responsibility is develop mobile games for mobile platforms (Nokia, Samsung, Simens, Alkatel, BlackBarry ..).
There acquainted and learned J2ME technology, (Java Media Framework, Mobile Information Device Profile).
And I developed a SyncML mobile service for synchronization and restoration of a personal data in mobile devices.

My last place of work is a at "PrivatBank" company.
It was in the 2012-2016 year. (start twenty and twelf last twenty and sixteen)
My responsibility was development of web-services for banking ..services.
There used technologyies: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
We used a database: MySQL, IQ/ASE, Redis, MongoDB.
I was an alone development of one project (this corporate project).
And I was a member of the group for developed various web services (it servlets, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
There is code covered by JUnit, JMock and DBUnit tests.
Also used tools for global testing: SonarQube, SoapUI, JMeter.
Apps had logging (it Log4j).

Addition I developed library classes (which are then used by these web services).
All developments were on a Linux system.
As a tools builder was used ANT, Maven.
Version control systems SVN, GIT.

Most of all I remember the service project for payment system.
There used technologyies: Java-7, Spring-3 (Data/Security/MVC/REST), ORM-framework (JPA/Hibernate-3)
Database: IQ, PostgreSQL, Redis.
This service was use LiqPay.
Was necessary develop library classes for use into this application.
Data communication with the service performed within the application throus SOAP-protocol.

I am expert in managing teams and solving customer problems.
Although I love my current role, I feel I am now ready for a more challenging assignment.
I have a stable work history.
I think one of my greatest strengths is as a problem solver.
I have the ability to see a situation from different perspectives and I can get my work done even in the face of difficult obstacles.
I can summarize who I am in so:
- Hardworking;
- I am quiet working under pressure;
- I have an open mind about what will work best;
- Attention to all the details;
- I able to keep deadlines successfully;
- Fast-learner, self-motivated and determined;

Nobody is perfect.
I get impatient with team members who are making mistakes or delivering substandard work.






В последнее время я участвовал в разрабатке проекта электронного магазина.
Я сам выбирал технологии которые нужно было приемнить для реализации задач бизнеса.
В состав этого электронного магазина входили модули:
- оплата
- авторизации
- банкинг
- система резервации
- AngularJS (1)
-

> Рассказать об полиморфизме, инкапсуляции и наследованию в Java ?
  http://java-se-learning.blogspot.com/2013/07/blog-post_4.html
  Парадигмы объектно ориентированного программирования Java основаны на трёх основополагающих концепциях, называемых абстракция, инкапсуляция, наследование и полиморфизм.
  1. Абстракция - выделение важных особенностей, характеристик объекта, главным образом отличающего его от других объектов. Выделение главных особенностей, не вдаваясь в в подробности, не вдаваясь в детали.
  2. Полиморфизм - возможность одного интерфейса иметь различные реализация. Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Инкапсуляция - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Наследование - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
  --------------------------------------
  https://jsehelper.blogspot.com/2016/01/java-core-1.html
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
    управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	стэковая память существует лиш на короткое время для работы отдельной под-программы
	стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	"java.lang.StackOverflowError" (если память стэка заполнена)
	"-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	всякий раз когда создается объект - он хранится в куче
	объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	память в куче живет с самого начала до самого конца работы программы
	"java.lang.OutOfMemoryError" (если память кучи заполнена)
	"-Xms" и "-Xmx" (опции JVM определить размер памяти кучи)
    -- "Perm-anent Gen-eration" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
	-- "Heap" (сама куча)
	   --- Новая куча
	       ---- "Eden Space" (молодое поколение - сюда попадают все новосозданные объекты)
		   ---- "Survivor Space" (сюда попадают выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
	   --- Старая куча
	       ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
> Какие методы есть у класса Object?
  ---------------------------------
  https://jsehelper.blogspot.com/2016/01/java-core-2.html
  1. public final native Class getClass()
  2. public native int hashCode()
  3. public boolean equals(Object obj)
  4. protected native Object clone() throws CloneNotSupportedException
  5. public String toString()
  6. public final native void notify()
  7. public final native void notifyAll()
  8. public final native void wait(long timeout) throws InterruptedException
  9. public final void wait(long timeout, int nanos) throws InterruptedException
  10. public final void wait() throws InterruptedException
  11. protected void finalize() throws Throwable
> Исключения?
  ----------
  >> https://jsehelper.blogspot.com/2016/01/java-core-3.html
  >> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L1025
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	 * Исключения - это наследники класса 'Throwable':
	 *              Error (системные ошибки при работе виртуальной Java-машины... - StackOverFlowError, OutOfMemoryError) - такие ошибкиm безсмысленно обрабатывать
	 *              Exception >> 'Checked' (проверяемые исключения - FileNotFoundException, IOException, InterrupdetException) - такие исключения/ошибки НЕвозможно ранее предугадать в программе, поэтому их обизательно нужно обрабатывать
	 *              RuntimeException >> 'Unchecked' (НЕпроверяемые исключения - NullPointerException, ArrayIndexOutOfBundlesException, ConncurrentModificationException, ClassNotFoundException, IllegalTypeException, ClassCastException, ArithmeticException) - такие исключения/ошибки можно и нужно предугадать в программе (их нет нужды обрабатывать)
	 * сигнатура throws... - помечаем в момент описания/определения метода который может выбросить исключение
	 * try/catch/finally - используем в момент вызова метода (который может выбросить исключение) когда мы сами хотим обрабатывать это исключение
	 *
  >> D:\IdeaProjects\spring\SpringFileUpload_restore\3\SpringFileUpload\src\test\java\com\journaldev\spring\TryCatchFinaly.java
     - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	 * - сперва отработает блок-try, только до оператора 'return'
	 *   (если блок-try свалиться, тогда вместо него сперва отработает блок-catch, только до оператора 'return')
	 * - после этого выполнение перейдет к блоку-finally
	 *   (в любом случае первым будет вызван оператор 'return' который из блока-finally)
	 * - если оператор 'return' в блоке-finally отсутствует тогда, следующим может вызван оператор 'return' который из блока-try (или на случай когда блок-try свалиться, тогда вместо него следующим может вызван оператор 'return' из блока-catch)
	 * - если оператор 'return' в try/catch/finally отсутствует, только тогда последним будет вызван оператор 'return' который в конце тела функции
	 * try/catch/finally >>> иерархия вызова:
	 * * * * * * * * * * * * * * * * * *
	 * Здесь если в блоке 'try' будет выброшено исключение - тогда программа прервется и передаст выполнение в блок 'catch' - где условия программы ГАРАНТИРОВАННО будет выполнена...
	 * Если есть список блоков 'catch' - тогда выбран будет только один, первый подходящий catch из списка (больше ничего)
	 * Дальше выполниться блок 'finally'
	 * *********************************
	 * Если внутри блока 'catch' бросить исключение - тогда блок 'finally' никогда невыпониться (программа просто прервется...)
	 * Если блоки 'try/catch' будут вложены их будет много - тогда исключение перейдет к внешнему блоку 'catch'
	 * *********************************
	 * Если внутри блока 'finally' бросить исключение - тогда программа просто прервется...исключение перейдет к внешнему блоку 'catch'
	 * *********************************
	 * Множество 'catch' блоков - это такой себе список кейсов - из которого (по типу исключения) будет выбран только один (остальные НЕбудут выполнены)!
	 * Дальше будет выполнен блок 'finally' (если тактой есть)
> Рассказать об одном из проектов который больше всех остальных мне запомнился ?
  Я принимал участвие в коммерческом проекте по публицированию объявлений.
  В частности я занимался разработкой системы авторизации + сыстемы оплаты + системы для резервирования заказов.
> Я занимаюсь автомобильным спортом.
  Участвую в соревнованиях на картингах на коротких и длинных дистанциях.
  Иногда мы собираемся с друзьями в команду и проводим соревнование между собой.
  - - - - - - - - - - - - - - - - - - - - - - - - [ lot/many/any ]
  Some times I take part to mini auto racing

  My hobby is auto sport.
  I take part to mini auto racing.
  Some times I vs my frends, together to competes auto racing on track.
  Frequency we to choose various tracks for the compete.
  Some times we are organize to competes on impassability of roads. For example on a mountains place.
  I think it is very intetesting and beautiful. The environment nature.
  We get a lot of impressions.
  And yet I am a subscriber to the magazine sports.
  I read and on find news in the world of auto sport.

  Я беру участие в автомобильных соревнованиях вместе с моими друзъями.
  I take part to compete auto racing together vs my frends.
  - - - - - - - - - - - - - - - - - - - - - - - -
>> http://iloveenglish.ru/stories/view/pishem_interesnij_rasskaz_o_sebe_na_anglijskom

   Сами по себе слова, в английском языке, вообще ничего не обозначают:
   0. (Физический, неодушевленный) предмет
   .. Название предмета
      The <ЧТО>.

   .. Направленное (обращение к) действие
      To <ЧТО ДЕЛАЕТ>

   Именно структура предложения, в английском языке, описывает какое-то действие:
   1. (Иннициатор действия) кто-то / что-то
      <ПОДЛЕЖАЩЕЕ>
	  оно ................. it

   2. (Бытие) действие
      <СКАЗУЕМОЕ>
	  есть ................ is

   3. (Абстрактное, куда направленное действие: вещь-место-время) о чем либо / где-то / когда-то
	  вещь ................ thing
	  какая-нибудь вещь ... something
	  кто-нибудь .......... anybody
	  там ................. there
	  себя ................ myself
	  тебя ................ yourself
	  его ................. himself
	  иногда .............. sometime
	  однажды ............. one time
	  следующий раз ....... next time

   4. Форма простого предложения
      <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ> + <ДОПОЛНЕНИЕ>.
	  или
	  <ДОПОЛНЕНИЕ> + <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ>.
	  -----------------------------------------
	  <ИНИЦИАТОР: КТО> + <ДЕЙСТВИЕ: ЧТО ДЕЛАЕТ> + <ВЕЩЬ|МЕСТО|ВРЕМЯ: КУДА НАПРАВЛЕННО ДЕЙСТВИЕ>.
	  или
	  <ВЕЩЬ|МЕСТО|ВРЕМЯ: КУДА НАПРАВЛЕННО ДЕЙСТВИЕ> + <ИНИЦИАТОР: КТО> + <ДЕЙСТВИЕ: ЧТО ДЕЛАЕТ>.
      Я пишу книгу.
	  Кто-то есть там. (Там кто-то есть).

   5. Полная форма предложения
      (ОБСТ-ВО МЕСТА|ВРЕМЕНИ) + <ПОДЛЕЖАЩЕЕ> + <СКАЗУЕМОЕ> + <(ДОПОЛНЕНИЕ...) || (ОБСТ-ВО ДЕЙСТВИЯ|МЕСТА|ВРЕМЕНИ)>.
	  ------------------------------------------------------------------------------------------------------------
	  <КТО> + <ЧТО ДЕЛАЕТ> + <КУДА НАПРАВЛЕННО ДЕЙСТВИЕ> + <ДОПОЛНЕНИЕ>.

   ++++++++++
   6. Если, в английском языке, предложение неполное где нехватает либо ПОДЛЕЖАЩЕГО или СКАЗУЕМОГО или ДОПОЛНЕНИЯ
      - тогда в этом случае добавляем абстрактное и <ПОДЛЕЖАЩЕЕ> (иннициатора действия) и <СКАЗУЕМОЕ> (бытие действие):
   ---
   Я - Саша.
   Мое имя есть Саша.
   ---
   Позвольте представиться.
   (Позвольте мне представиться?) Позвольте мне информировать о себе?
   ---
   Сложно описать себя.
   Это есть сложно чтобы описать себя.
   ---
   Вообще-то говорить о себе много хороших слов не слишком-то скромно...
   <ДЕЙСТВИЕ ПО НАПРАВЛЕННОЮ К> говорить (много) хороших слов <УТОЧНЕНИЕ> о себе <СКАЗУЕМОЕ> является очень не скромно
   ---
   Самое сложное – это рассказать о себе что-то объективное...
   The most difficult thing is to tell something objective about myself...
   ---
   Кто-нибудь собирается послушать мою историю?
   (кто-то есть там | там кто-то есть) есть там кто-то?
     что-то собираться (сделать) послушать
	   (что...) моя история
   ---
   Непросто говорить о себе
   (непросто=сложно) это есть сложно
     (...делать для) говорить об

   ++++++++++
   ---
   Я - Саша.
   Меня зовут Саша.
   Мое имя есть Саша. == My name is Sasha.
   ---
   Позвольте представиться.
   (Позвольте мне представиться?)
   Вводить в курс oб / информировать...
   Позвольте мне ввести о себе. == Let me introduce myself.
   ---
   Сложно описать себя.
   Это есть сложно чтобы описать себя.
   It is difficult to describe myself.
   ---
   Вообще-то говорить о себе много хороших слов не слишком-то скромно...
   (ДЕЙСТВИЕ ПО НАПРАВЛЕННОЮ К) говорить (много) хороших слов (УТОЧНЕНИЕ) о себе  является очень не скромно == To tell many good words about yourself is not very modest...
   ---
   Самое сложное – это рассказать о себе что-то объективное...

   The most difficult thing is to tell something objective about myself...
   ---
   Кто-нибудь собирается послушать мою историю?
   (кто-то есть там | там кто-то есть) есть там кто-то?
     что-то собираться (сделать) послушать
	   (что...) моя история
   Is there anybody going to listen to my story?
   ---
   (собирается послушать = going to listen)
   ---
   Непросто говорить о себе
   (непросто=сложно) это есть сложно
     (...делать для) говорить об
   It is hard to speak about myself

   поскольку только люди со стороны могут видеть меня объективно
   (люди со стороны) окружающие меня люди
     видеть (могут видеть)
	   объективно (я объективный)
   people surrounding me can see me objectively

   Непросто говорить о себе, поскольку только люди со стороны могут видеть меня объективно.
   It is hard to speak about myself as only people surrounding me can see me objectively.
  - - - - - - - - - - - - - - - - - - - - - - - -
  Часто для соревнованиях мы выбираем разные трассы. И таким способом результаты каждого нового сорревнования становятся непредсказуемым.
  Еще мы собираем команду для туристического отдыха.
  Там мы устраиваем заезд на квадроциклах по бездорожью, по гористой местности.
  Это очень интересно и очень красиво.
  Также мы можем наблюдать разные пейзажи на природе.
  Мы получаем удовольствие из таких поездок и делимся между собой своми впечетлениями.
> Мое хобби - собирать разные радио-модели автомобилей.
  На сборку каждой модели можно потратить и один месяц и один год.
  Часто бывает сложно найти специфическую деталь для конкретной модели автомобиля.
  Иногда приходиться эту деталь делать самому.
  Часто бывает что плохо сдлеланная радио-модель автомобиля ломается на дороге во время езды.
  Поэтому я запасаюсь запасными деталями для каждой модели автомобиля.
  Я нравится собирать традиционные и классические автомобильные модели, с бензиновыми двигателями.
  Это очень тонкая работа и требует большого внимания и высокой точности выполнения. А также и терпение к длительному времени потраченому на создание каждой модели.
  Но мне это очень нравится.
> Я часто смотрю телепередачи о проведении спортивных чемпионатов авто-роллейных сорревнований между легковыми и грузовыми категориями, на коротких и длинных дистанциях.
  А также я смотрю и другие телевизионные авто-шоу, например: Топ-Гир.
  Подписываюсь и читаю спортивные журналы по автоспорту.
>
>
>
> Мне ненравиться когда нарушаются ранее оговоренные сроки выполнения заданий.......
  Когда срывается план работы из-за плохо спланированых действий......

> Tell me about polymorphism, encapsulation and inheritance in Java?
  Paradigm of object oriented programming is based on three fundamental concepts: encapsulation, inheritance and polymorphism.
  1. Abstraction - this is the allocation of the main features, without going into details and details.
  2. Polymorphism - это возможность одного интерфейса иметь различные реализация.     it is posybylyty for any one interface has various implementations.     Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Encapsulation - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Inheritance - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
> I am go in for motor sports.
  I participate on sports events for karting in a short and long distances...........................................
  Sometimes we're going with friends to the team and to hold competitions among themselves.
  Often competitions we choose different routes. And in this way the results of each new sorrevnovaniya become unpredictable.
  Once we collect the team for leisure tourism.
  There we arrange check-ATV on the road, on a hilly terrain.
  It is very interesting and very beautiful.
  Also we can observe different views on the nature.
  We get pleasure from these trips and share with each other svomi vpechetlenie.
> My hobby - collecting various car radio models.
  and one month and one year can be spent on the assembly of each model.
  It is often difficult to find a specific item for a specific car model.
  Sometimes you do this part yourself.
  It often happens that bad sdlelannaya car radio model breaks down on the road while driving.
  So I stock up on spare parts for each model of car.
  I like to collect traditional and classic car models with petrol engines.
  It is very delicate work and requires a lot of attention and precision execution. And patience for the long time spent on the creation of each model.
  But I like it a lot.
> I often watch TV programs on the organization of sports-car championships rolleynyh sorrevnovany between passenger and freight categories for short and long distances.
  And as I watch television and other auto shows, for example: Top Gear.
  I subscribe and read sports magazines Motorsport.

>> (Как успешно пройти собеседование на английском языке) http://englex.ru/how-to-pass-job-interview-successfully/
                                                          https://skyeng.ru/articles/gotovimsya-k-sobesedovaniyu-na-anglijskom-yazyke-top-50-voprosov-soiskatelyu?source_type=cpa&utm_source=admitad&admitad_uid=b17ec614a79587c11e699ec1fcfa9d53
   1. Tell me about yourself — Расскажите о себе
   
   Furthermore, I’m a better listener - that’s why I’ve always been able to be in agreement with different types of people.
   I have over six years of experience in java developer.
   -----------------------------------------------------
   Более того, я замечательный слушатель, поэтому я всегда был способен ладить с разными типами людей.
   У меня более шести лет опыта работы Java-разработчиком.
   
>> https://www.eduonix.com/blog/software-development/learn-use-functions-methods-scala/



  .......................................................................................
+ Cockie | Session | OAuth | Контекст
  -----------------------------------
  Есть:
  - клиент (может быть любое клиентское приложение которое работает на стороне клиента)
    -- у клиента есть IP-адресс
	-- у клиента могут быть Cookie (это сохраненные на стороне клиента файлы которые хранят информацию участвующую в клиентских запросах: поля формы..)
	   клиент может включать свои Cookie в HEAD-запроса
  - сервер:
    -- есть "сервер приложений" (такой себе менеджер для всех веб-приложений..)
	-- и есть "серверное приложение" (это и есть само веб-приложение..)
	   "серверное приложение" на своей стороне может держать разные инструкции (например: выбор способа/формы авторизации..)
	-- у "сервера приложений" может быть Session (это сохраненные на стороне сервера файлы которые хранят информацию участвующую в клиентских запросах: поля формы..)
	   клиент может идентифицировать свою Session по идентификатору id-session (..)
	   ("сервер приложений" выполняет инструкции которые получает от "серверное приложение", например через встроенное API проверяет пользователя в базе данных И передает "серверному приложению" информацию-ответ-запроса полученную от пользователя)
  - OAuth (это альтернатива Session)
    (файл Session живет на стороне сервера короткое время И это время жизни управляется самим "серверным приложением")
	-- это тоже идентификатор-строка который хранится и на серверной стороне и на клиентской стороне И имеет только 2-а токена:
	   "auth-токен" (механизм: служит для идентификации пользователя на серверной стороне)
	   "refrash-токен" (механизм: служит для получения самого "auth-токен"..)
	суть в том, что теперь за хранения всей приватной информация об пользователе несоет ответственность (НЕ сам клиент, на клиентской стороне) уже "OAuth сервис" на стороне специального сервера..
	(теперь хакеру будет сложнее перехватить приватную информацию об пользователе, потому-что для этого нужно сделать больше действий...чтобы вытащить ее)

  Контекст
  - В момент регистрации|аудитенфикации|авторизации "сервер приложений" самостоятельно:
    -- делает проверку пользователя (по логину/паролю..)
    -- определяет его роль и права на этом "сервере приложений"
    -- и создает такой себе объект "Контекст" приложения - внутри которого (куда собирается и) хранится конкретно информация об этом пользователе..
  - Как это работает:
    -- вытаскивается информация которая используется в момент аудитенфикации (либо из Session, либо из OAuth) и передается в объект "Контекст" приложения
	-- внутри (созданного) объекта "Контекст" приложения уже существует вся приватная информация об пользователе
	-- теперь вытаскиваем информации из объекта "Контекст" приложения И дальше:
	   --- делаем уже другую проверку внутри самого (нашего) "серверного приложения" на предмет: права доступа к конкретному защищенному методу внутри приложения..
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  На стороне сервера существует несколько этапов прохождения клиентского запроса:
  1. на все что происходит...самой первой реагирует Опреационная Система (она слушает и логирует все события..) И перенаправляет все запросы по адрессу получателей..
  2. дальше этот запрос получает "сервер приложений"...тоже как-то его обрабатывает И перенаправляет по адрессу на "серверное приложение"..
  3. и уже потом (наше) "серверное приложение" как-то обрабатывает этот запрос

  Дело в том, что только на уровне (последнем этапе) нашего "серверного приложения" может быть защищен доступ к ресурсам..
  Это значит что на всех остальных (предварительных) этапах защита отсутствует...поэтому:
  - злоумышленник сможет безпрепятственно, например: забрать системные файлы-логов, временно-хранящиеся файлы-Session, проанализировать все те клиентские запросы которые Опреационная Система зафиксировала И найти/получить приватную информацию о пользователе (которую потом использовать для авторизации..)
  - плохо то что и на этих уровнях защиты "серверное приложение" никак не может защитить такую информацию..
  .......................................................................................
  - Элементы веб-приложения:
  -- "Servlet"
     это веб-компонет у которого есть сервисные методы-слушатели (services|GET|POST|PUT|DELETE). Эти методы-слушатели переопределяются для каждого конкретного случая на серверном приложении. Они могут принимать параметры и обрабатывать их..
  -- "Model"
     это формат данных который в ответ возвращает метод Servlet-а (HTML-документ|JSON|XML|бинарный-файл..)
  -- "Filter"
     прослушивает URL-адресса и перенаправляет их..
  -- "Exception"
     в случае внутренней ошибки на сервере перенаправляет веб-страницу с ошибкой (здесь даже можно с помощю фильтра улучшить результат..)
  -- "Session"
     создает сессию и ложит туда клиентские данные..
  -- "Security"
     защищенный доступ к рессурсам.. (настраивается обычно на самом "сервере приложений")
  -- ...

  - Spring компоненты:
    -- дело в том, что Spring имеет собственные встроенные компоненты для веб-приложения И некоторые из этих встроенных веб-компонентов по умолчанию уже подключены в проэкт веб-приложения с дэфолтными настройками..

    --- "Servlet" (по умолчанию включен в MVC: DispatchServlet имеет собственный фронтальный контролер, который потом перебрасывает на кастомерские контроллеры..)
    --- "Model" (для REST-методов по умолчанию возвращается JSON; для веб-страниц возвращает документ в виде модели..; также можно этот формат конвертировать для бинарных файлов..;)
    --- "Filter" (по умолчанию из URL-адресса отсекается приставка ".jsp", в итоге получаем обычную сгенерированную на сервере jsp-страничку..)
    --- "Exception" (по умолчанию в Spring-е предусмотрены собственные странички для внутренних ошибок..)
    --- "Session" (можно включить в конфигурационном файле-Spring-а и тогда все поля из объекта-модели будут попадать в сессию автоматически..)
    --- "Security" (помимо тех библиотек что предлагает "сервер приложений", Spring имеет собственные библиотеки для реализации защищенного доступа..)
  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  Выскакивает на автовайред...тривиальный случай объявления бина в классе но вместо ожидаемого объекта получаем NullPointerException ?
  - Если ты через Autowire делаешь, то то, над чем ты ставишь эту аннотацию - должно быть помечено аннотацией Компонент, репозиторий, сервис, или контроллер а и наче ты не сможешь создать бин
  1. в Spring-е существует интерфейс ApplicationContext - через который можно загрузить спринговые бин-ы, при условии что будут созданы с них объекты...
  2. если это веб-приложение - тогда в web.xml нужно определить ContextListner - с помощью которого...будет иннициироваться/создаваться объекты спринговых бинов
  3. а в интеграционных тестах есть аннотация @RunWith(SpringJUnit4ClassRunner... - с помощью которого...будет иннициироваться/создаваться объекты спринговых бинов и незабываем о том что для всех случаев по нужно еще предварительно сконфигурировать эти бин
  .......................................................................................


  .......................................................................................
+ "redirect" | "forward"
  ----------------------
  >> http://ru.stackoverflow.com/questions/401524/spring-mvc-controller-Разница-между-return-forward-redirect-и-возвратом-jsp-ф
  forward - это ВНУТРИ-серверный переход на другой контроллер
  redirect - отправляет http с кодом 302 и происходит редирект на другой ВНЕШНИЙ-url. Второй применяют частенько как защиту от F5. Скажем при оплате чтобы та повторно не происходила.
  >> http://www.realcoding.net/article/view/2182
  - Forward (пересылкой) - Когда вы выполняете пересылку, нужная нам страница инициируется JSP-контейнером с помощью внутреннего вызова метода. Новая страница продолжает обрабатывать тот же самый запрос, а браузер даже не догадывается о том, что в этом процессе задействовано несколько страниц
  - Redirect (переадресацией) - означает то, что первая страница требует от браузера сделать новый запрос к нужной странице. Таким образом, URL, указанный в браузере, будет заменён URL новой страницы, на которую нас переадресовали, чего не происходит при пересылке. Переадресация медленнее, чем пересылка, поскольку браузер вынужден повторять свой запрос. Второе отличие состоит в том, что объекты функциональной области запроса после переадресации становятся недоступными, так как вы создаёте новый запрос

+ LinkedList - доступ к элементам выполняентся по итератору.
  > минусы (НЕсовсем эффективно расходуется размер списка) также и в том, что требуется небольшое место для записи для ссылки на следующий объект...

+ ITERABLE | ITERATOR
  > Iterable - это интерфейс который реализует этот "Итератор"
  > Итератор - это паттерн который позволяет получить доступ к элементам любой коллекции без вникания в суть ее имплементации.
  >> (В чем отличия TreeSet и HashSet?) https://habrahabr.ru/post/162017/
     Set - не допускает хранение двух одинаковых элементов.
	 TreeSet - обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.

+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/Spring.md

+ КОГДА СОЗДАЕТСЯ И УНИЧТОЖАЕТСЯ СЕССИЯ
  веб-сервер не поддерживает постоянного соединения с клиентом (каждый запрос обрабатывается как новый).
  Сеанс (сессия) - это механизм позволяющий однозначно идентифицировать браузер и создающий для этого браузера файл на сервере (в котором хранятся переменные сеанса).
  Сеансы используются для обеспечения хранения данных во время нескольких запросов Web-страницы
  -- http://crypto.pp.ua/2010/06/seans-sessiya-v-java/
     http://java.markune.ru/servlets/session-tracking.html
     --- getSession() - чтобы открыть новый сеанс ( метод объекта HttpServletRequest возвращает сессию пользователя ). Метод извлекает из запроса в сервлет объект сессии ( интерфейс HttpSession предоставляет методы, которые сохраняют и возвращают данные )
	     Если входной параметр равен true getSession(boolean param) то сервлет-контейнер проверяет наличие сеанса
	     В случае успеха метод возвращает дескриптор этого сеанса. В противном случае метод устанавливает новый сеанс.
		    public doGet(HttpServletRequest request) {
				HttpSession session = request.getSession(true);
			    //Если сессия не существует то ссылка на нее НЕбудет получена
				HttpSession session = req.getSession(false);
			}
		 ................................................
		 invalidate - чтобы вручную завершить сессию
		 (Java) Web-сервер - автоматически завершает сессию (когда в течение определенного времени не происходит запросов, по умолчанию 30 минут)
		 ................................................
	 --- после чего начинается сбор информации о клиенте:
         setAttribute() - чтобы сохранить значения переменной в текущем сеансе
		 getAttribute() - чтобы прочесть значения
		 getAttributeNames() - список имен всех переменных в текущем сеансе
		 removeAttribute() - чтобы удалить значения
		 getId() - возвращает уникальный идентификатор который получает каждый сеанс при создании
		 isNew() - возвращает false для уже существующего сеанса и true – для только что созданного
		 invalidate() - завершить сеанс, уничтожает все связи с объектами, и данные, сохраненные в старом сеансе, будут потеряны для всех приложений
		 getCreationTime() и getLastAccessedTime() - информацию о дате и времени создания последнего обращения к сессии
	 --- время инвалидации (жизни) сессии можно задать с помощью тега session–config в web.xml в виде:
			<session-config>
				<session-timeout>30</session-timeout>
			</session-config>
     --- Как правило при работе с сессией возникают следующие проблемы:
	     поддержка распределенной сессии (синхронизация/репликация данных, уникальность идентификаторов и т.д.);
	     обеспечение безопасности;
	     проблема инвалидации сессии (expiration) предупреждение пользователя об уничтожении сессии;

  .......................................................................................
+ INDEX (в базе данных)
  ---------------------
  >> (Индексы. Теоретические основы) http://www.sql.ru/articles/mssql/03013101indexes.shtml
  >> (14 вопросов об индексах в SQL Server) https://habrahabr.ru/post/247373/
  Физически данные хранятся на 8Кб страницах. Сразу после создания, пока таблица не имеет индексов, таблица выглядит как куча (heap) данных.
  Когда вы хотите получить доступ к данным, SQL Server сканирует всю таблицу что бы найти искомые записи.
  SQL Server не знает что в таблице существует только одна запись, удовлетворяющая условию, пока в таблице не существует: 'Unique constraint', 'Unique index' или 'Primary key'.
  В SQL Server индексы хранятся в виде B-деревьев (B-tree). 'B' означает сбалансированное (не путать с бинарным). SQL Server предлагает к использованию два типа индекса: кластерный (clustered) и некластерный (nonclustered).
  Указатель представляет собой 'Row ID' и имеет следующий формат: НомерФайла:НомерСтраницы:ПозицияЗаписи.
  ( правило, когда работаете с SQL Server: запись может быть найдена либо по 'Row ID' когда нет кластерного индекса, либо по 'кластерному ключу' )

  Индексы которые созданные на базе ОДНОГО-поля таблицы:
  > Кластерный индекс - сами данные таблицы являются частью индекса, для таблицы может быть создан только один 'кластерный индекс'.
                        В SQL Server кластерный индекс является уникальным индексом по определению (все ключи записей должны быть уникальные).
	                    Если существуют записи с одинаковыми значениями, SQL Server делает их уникальными, добавляя номера из внутреннего (невидимого снаружи) счетчика.
						( 'Кластерный индекс' является частью 'не кластерного индекса' )
  > Не кластерный индекс - cами данные не хранятся в индексе и вынимаются из таблицы, используя 'Row ID' или ключ 'кластерного индекса' (важное правило SQL Server: создавать 'кластерные ключи' нужно как можно более короткими).
                           ( Каждый 'некластерный индекс' использует значения кластерного индекса, > увеличение размера 'кластерного индекса' приводит к многократному увеличению по памяти для всех 'не кластерных индексов' и к снижению количества записей индекса способных уместиться в пределах одной страницы )

  Индекс может быть создан на основании НЕСКОЛЬКИХ-полей:
  > Составной ключ - индекс создан на основании нескольких полей, и любая группа значений по полям составного индекса является уникальной.
                     ( существует только одно ограничение – длина ключа индекса или сумма длин этих полей не должна превышать 900 байтов )
  > Уникальные индексы - гарантирует что каждое значение является уникальным в индексируемом поле
                         ( целостность данных может быть гарантирована или 'Unique constrain' или 'primary key'. В основе обоих лежит уникальный индекс )

  Доступ к записям при наличии или отсутствии индексов
  > В зависимости от наличия/отсутствия индексов и их типов, SQL Server может выбрать различные способы доступа к данным таблицы:
    - Сканирование таблицы. ( Когда индексы не используются и таблица не имеет кластерного индекса. Таблица храниться как куча 'heap' )
	- Выборка данных по 'кластерному индексу'
	- Выборка данных по 'не кластерному индексу'

  Индексы так же имеют и ряд недостатков:
  > Индексы занимают дополнительное место на диске и в оперативной памяти ( каждый раз когда вы создается индекс, сохраняется ключи по порядку...и чем больше/длиннее ключ, тем больше размер индекса )
  > Замедляются операции вставки, обновления и удаления записей


+ JPA / HIBERNATE
+ JTA-ТРАНЗАКЦИИ
  http://khpi-iip.mipk.kharkiv.edu/library/j2ee/tutoral/doc/Transaction4.html
  https://www.ibm.com/developerworks/ru/library/0610_bicheno/
  http://www.k-press.ru/cs/2006/3/WAS/WAS.asp
  JTA (Java Transaction API) - API позволяет размечать транзакции способом не зависящим от реализации менеджера транзакций.
  Чтобы разметить JTA-транзакцию нужно вызывать методы: begin, commit и rollback ( интерфейса javax.transaction.UserTransaction )
  Если изменения дают сбой тогда вызывается метод rollback и выбрасывается EJBException
  .....................................................................................
   UserTransaction transaction = context.getUserTransaction();
   try {
      transaction.begin();
      updateChecking(amount);
      machineBalance -= amount;
      insertMachine(machineBalance);
      transaction.commit();
   } catch (Exception ex) {
       try {
          transaction.rollback();
       } catch (SystemException syex) {
           throw new EJBException
              ("Rollback failed: " + syex.getMessage());
       }
       throw new EJBException
          ("Transaction failed: " + ex.getMessage());
    }
  .....................................................................................
  Основная идея использования JMS (Java Message Service) заключается в том, что разработчики создают только клиентские приложения, часть из которых является отправителями, а часть – получателями сообщений.
  > JMS-Сервер (его называют 'message broker') его просто используют подобно Web-серверам...
  > Перед началом работы программы использующей JMS на стороне JMS-сервера создаются «администрируемые объекты», это:
    - фабрики соединений (connection factories)
    – «целевые» объекты двух видов (топики 'topics' и очереди 'queues')
  > Основное отличие топиков от очередей состоит в том что:
    - очередь является просто каналом передачи сообщения единственному потребителю (реализуют программную модель «отправитель-получатель» sender-receiver)
    - а топики размножают сообщение для всех кто желает его получить (реализуют программную модель «издатель-подписчик» (publisher-subscriber)
  > Получатель сообщений может извлекать сообщения в двух режимах:
    1. синхронном - программа-получатель явно вызывает метод receive().
	                Если сообщения доступно - тогда метод возвращает сообщение; а если сообщения нет - тогда метод блокирует поток и программа ждет прихода сообщения
	2. и асинхронном - получатель реализует callback-метод onMessage() специального интерфейса MessageListener.
	                   При приходе сообщения происходит вызов и выполнение кода метода onMessage().

+ СЕКЮРИТИ
  > Декларативное управление безопасностью
    --------------------------------------
  [2] Конфигурирование аутентификации
    <login-config>
	    <auth-method>BASIC</auth-method>
    </login-config>

  [3] Название ролевой полиики
    <security-role>
	    <role-name>ADMIN_ROLE</role-name>
    </security-role>

  [4] Настройка безопасности для веб-приложения
    <security-constraint>
	    <web-resource-collection>
		    <url-pattern>/admin/*</url-pattern>
		    <http-method>GET</http-method>
		    <http-method>POST</http-method>
	    </web-resource-collection>
	    <auth-constraint>
		    <role-name>ADMIN_ROLE</role-name>
	    </auth-constraint>
    </security-constraint>

  > Программное управление безопасностью
    ------------------------------------
  [5] Использование безопасности в сервлетах (в настройках класса-сервлета):
      + '@ServletSecurity' - определяет настройки безопасности;
      + '@HttpMethodConstraint' - ограничения для каждого метода доступа;
      + 'value' - http method (GET,POST..);
      + 'rolesAllowed' - роль которая может получить доступ;
    >> @DeclareRoles ... перечисляет роли для проверки прав доступа к EJB-компоненту
    >> @RolesAllowed ... сообщает контейнеру список ролей которым позволено обращаться к методу EJB-компонента (может применятся либо к отдельному методу либо ко всему классу)
    >> @PermitAll ...... открывает доступ сразу ко всем
    >> @DenyAll ........ закрывает доступ сразу ко всем (делает недоступным класс или метод для любой роли)
    >> @RunAs .......... позволяет выполнить команду от имени другого пользователя (можно временно присвоить пользователю с одной-ролью привилегии с другой ролью)

  > Spring управление безопасностью
    -------------------------------
*       >    'Authentication' -  хранит (объединяет) имя пользователя и пароль в объект (и передается экземпляру 'AuthenticationManager' для проверки)
*                                пользователю будет предложено войти в систему предоставив имя (логин или email) и пароль
*                                представляет пользователя (Principal):
*                                # 'UserDetails' - предоставляет информацию для построения объекта 'Authentication' из DAO-объектов;
*                                # 'UserDetailsService' - создает 'UserDetails';
*            'GrantedAuthority' - представляет роли выданные пользователю в масштабе всего приложения
*       (1)> Если аутентификация прошла успешно возвращает полностью заполненный объект 'Authentication'
*            Инначе будет выброшено исключение 'BadCredentialsException' (с сообщением "Bad Credentials")
*       (2)> 'SecurityContext' - для пользователя устанавливается контекст безопасности
*                                в контексте безопасности храниться вся информация об аутентификации (логин/пароль пользователя) и авторизации (правила авторизации)
*                                (содержит объект 'Authentication' И информацию системы безопасности 'GrantedAuthority' связанную с запросом от пользователя)
*       (3)> 'SecurityContextHolder' - содержит полную информацию о текущем контексте безопасности приложения
*                                      и устанавливает стратегии для хранения информации-'SecurityContext':
*                                      #1 'MODE_THREADLOCAL' локальный поток (по умолчанию);
*                                      #2 'MODE_GLOBAL' глобальный поток;
*                                      #3 'MODE_INHERITABLETHREADLOCAL' порожденные от одного защищенного потока;
*                                      Например: в веб-приложении сервер кэширует информацию пользователя (принципала) в течение сессии и хранит 'SecurityContext' как атрибут 'HttpSession' между HTTP-запросами
*                                                (объект 'SecurityContext' извлекается из 'HttpSession' и восстанавливает контекст в 'SecurityContextHolder' для каждого запроса И очищает 'SecurityContextHolder' после завершения запроса)
*                                                Другие типы приложений, например: 'RESTful веб-сервисы' без сохранения состояния НЕиспользуют HTTP-сессии и будут требовать аутентификации при каждом запросе
*       >    Авторизированный доступ можно прикручивать на:
*            - URL-адресса ... <intercept-url pattern="/add*" access="ROLE_USER"/>
*            - методы ........ <global-method-security secured-annotations="enabled" /> | @Secured("ROLE_ADMIN")
*       >    Форма (способ) аутентификации может быть:
*            - базовый
*            - на форму
*            - ...
*       >    Декларация Spring Security через xml-конфигурацию:
*            - окружаем HTTP-запросы фильтром чтобы гарантировать их защищенность (включаем в web.xml делегирование 'DelegatingFilterProxy' И описываем в '<filter>','<filter-mapping>')
*            - определяем xml-файл с настройками Spring Security ( security.xml ) для получения защищенного web-приложения
*            - добавляем ссылки расположение на Spring Security xml-конфигурации (security.xml) в web.xml и перечисляем их: '<context-param>','<param-value>'

+ КАК РАБОТАЕТ МЕХАНИЗИ OAUTH
  - OpenID - (это чистая 'аутентификация') просто предоставляет информацию о клиенте со стороны другого сервиса (например: используется для быстрой регистрации клиента)
  - OAuth - (это чистая 'авторизация') позволяет программе от пользователя получить права (обозначаются токеном) для пользованием например каким-либо API на стороне другого-доверенного сайта
  http://softwaremaniacs.org/blog/2011/07/14/openid-oauth-difference/
*       > Что такое механихм OAuth - это способ защиты клиентского доступа.
*         Всю доверенность получает и контролирует уже НЕ сам клиент а серверное приложение.
*       > Токен - представляет собой подпись клиента, которая потом идентифицируется на стороне сервера...
*       > Есть OAuth-сервер - который выдает клиенту его токены ('рефреш-токен' и 'актив-токен')
*       > OAuth2Tokenizer - это реализация механизма клиентской автоматической аторизации на серверном приложении.
*       >> НЕавторизированный клиент идет на серверное приложение.
*          Серверное приложение проверяет его и перенаправляет на OAuth-сервер для получения клиентских токенов доступа.
*          Клиент авторизируется на этом OAuth-сервере, получает (свои) клиентские токены доступа.
*          Дальше клиент возвращается на сервер приложений и заходит уже со своими токенами.
*          После этого клиент получает доступ к методам серверного приложения.
*       >> 'рефреш-токен' это механизм авторизации клиента на серверном приложении.
*          Рефреш-токен содержит: ссылку на идентификатор рефреш-токена; OAuth-сервер; зашифрованный клиентский ключ-пароль; ключ-дешифратор;
*       >> 'актив-токен' это клиентская подпись, которая аудитенфицирует личность клиента.
*          Актив-токен содержит: имя клиента; время пользования и время истечения срока для токена; роллевую группу куда входит этот клиент; ссылка на идентификатор рефреш-токен.
*       >> И рефреш-токен и актив-токен хранятся в куках на сторое клиента.
*          Но рефреш-токен может отправляться редко-только один раз на сервер. А актив-токен часто-постоянно каждый раз при запросе отправляется на сервер.
*          Если злоумышленик перехватить актив-токен клиента - то он сможет только на короткое время им воспользоваться.
*          По истечению этого лимитного времени, серверное приложение запросит у клиента его рефреш-токен.
*          Если рефреш-токена нет - тогда доступ для такого клиента будет закрыт...
*          По рефреш-токену серверное приложение автоматически подключается к OAuth-серверу, получает информацию-подтверждения прав доступа клиента и обновляет данные клиентских токенов...
*          Для работы с токенами нужно чтобы сессия была отключена (инначе вся информация будет закешированна внутри сессии по идентификатору сессии)
*          В отличии от актив-токена, рефреш-токен очень редко участвует в клиентских запросах и поэтому вероятность что злоумышленик перехватит его будет очень низкая...
  .....................................................................................
  Токен (тоже являектся кукой, на стороне клиента)
  Наличие и время жизни токенов (куки) контролируется веб-браузером (программой), через время жизни этого токена...
  После удаления токена веб-браузером, в этом случае клиент теряет необходимые данные...и эти (куки) токены уже не восстанавливаются

+ https://habrahabr.ru/company/luxoft/blog/157273/
  > 'Locks' .................... представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
  > 'Atomics' .................. классы с поддержкой атомарных операций над примитивами и ссылками.
  > 'Concurrent Collections' ... набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.
  > 'Queues' ................... неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.
  > 'Synchronizers' ............ вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
  > 'Executors' ................ содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.


>> (git stash) http://stepansuvorov.com/blog/2012/11/git-stash-это-то-что-я-искал/
    ---------
Довольно часто при работе с git возникает ситуация, когда необходимо обновиться (сделать pull), но при этом коммитить сырой код совсем не хочется.
git stash ... команда скрывает все сделанные изменения и переводит код в состояние HEAD (после чего можно сделать pull а дальше уже накатить изменения):
> git stash
> git pull
> git stash apply
и можно продолжать работать.

Опций при работе с командой stash:
> git stash apply - применить изменения к текущей версии
> git stash list - вывести список изменений
> git stash show - вывести последние изменния
> git stash drop - удалить последние изменения в списке 
> git stash pop - [apply] + [drop]
> git stash clear - очистить список изменений

  
>> (Spring Auto-Wiring (автоматическая привязка бинов)) http://www.quizful.net/post/Spring-Auto-Wiring
    --------------------------------------------------
Spring поддерживает 5 режимов автопривязки:
1. no ............ по умолчанию, нет авто привязки, ее нужно устанавливать вручную с использованием атрибута ref.
2. byName ........ Авто привязка по имени, если имя указанное в свойствах бина в атрибуте autowire="byName" такое же как имя бина, то привязка производится автоматически.
3. byType ........ Авто привязка по типу данных, если тип данных бина совпадает с указанным типом данных в авто привязке, то привязака производится автоматически.
4. constructor ... привязка по типу аргумента конструктора. 
5. autodetect .... если контсруктор по умолчанию найден, используется автопривязка.

В Spring вы можете привязать бин автоматически, используя функцию auto-wiring. Чтобы использовать эту функцию достаточно просто определить атрибут autowire в <bean>
------------------------------------------------------------------
<bean id="customer" class="com.test.Customer" autowire="byName" />
    - - - - - - - - - - - - - - - - - - - - - -
.. Важно:
	- Чтобы в Spring-е @Autowire мог автоматически искать подставлять реализацию для типа интерфейса - нужно обязательно объявлять интерфейс для каждого типа бина!!!
	  (инначе, если отсутствует интерфейс бина - тогда @Autowire НЕработает...)
	- В Spring-е есть несколько способов создавать бин:
	  1. в Java-стиле ........................... @Configure, @Bean
	  2. через xml-декларацию (Spring Core) ..... <Beans.xml>
	  3. через xml-декларацию (Spring MVC) ...... <mvc:annotation-driven/>, interface MyBean
	  4. в интеграционных тестах через Spring ... @RunWith(SpringJUnit4ClassRunner
	

Существует несколько способов создания бинов в Spring-е...
-------------------------------------------------------
- Либо с помощью конфигурационного xml|property-файла (в декларативном стиле), либо с через аннотации в Java-классе (в стиле Java)...
1. Если в декларативном стиле, тогда внутри <Beans.xml> нужно явно описать бины и указать расположение их классов:
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	<bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/>
	<bean id="customer" class="com.mkyong.common.Customer" >
		<property name="action" value="buy" />
		<property name="type" value="1" />
	</bean>
	<bean id="personA" class="com.mkyong.common.Person" >
		<property name="name" value="mkyongA" />
	</bean>
2. Если стиле Java, тогда внутри <context.xml> нужно указать путь какие рабочие директории Spring должен сканировать:
   И над каждым классом-бина поставить аннотацию (@Configure, @Component, @Repository, @Service, @Controller, ...)
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	<context:component-scan base-package="com.devblogs.component"/>
3. Загрузить бины с помощю "AnnotationContext":
    - - - - - - - - - - - - - - - - - - - - - -
	ApplicationContext ctx = new ClassPathXmlApplicationContext("SpringBeans.xml");
	ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml");
	ApplicationContext ctx = new new AnnotationConfigApplicationContext(SpringMongoConfig.class);
======================================================= [ http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera ]
В чем преемущество черех IoC:
- вроде как на лету можно переопределять зависимости исправляя xml-файлы
- Основное преимущество это управление зависимостями вне самих классов (в противном случае у вас в каждом классе будет куча бесполезного кода по созданию экземпляров синглтонов их переиспользованию).
IoC - одна из методик уменьшения связанности между объектами. Это подход.
DI - одна из реализаций IoC. Другая распространенная реализация - Service Locator
Идем дельше - как реализуются DI? а) контейнеры; б) фабрики.

Spring IoC - это IoC, реализованный через DI, реализованный через контейнер.
Вам стало понятнее?

Идем дальше - что такое Spring IoC? Это модуль, который реализует непосредственно контейнер. Все. То есть это Context, BeanFactory и их реализации.

Идем дальше - транзакции в Spring. Что это? Это библиотека классов. И так как эти классы имеют конструкторы, геттеры и сеттеры, то вы, само собой, можете их использовать в спринговом контексте.

IOC позволяет декларативно настроить транзакции, скоупы жизни бинов и т.д.
	
+ SPRING
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   Аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   Еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                   Cвязь между компонентами (DI - иньекция зависимостей):
*                   - выполнена через поле класса – 'Setter Injection' (SI);
*                   - или с использованием конструктора – 'Constructor Injection' (CI)
*                     При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                     В этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу...
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.
* >>>> @Scope("singleton") — ( @Singleton(true) или @Singleton(false) или @Scope("prototype") или @Scope("request") или @Scope("session") или @Scope("global-session") )
*
* >>>>> BeanFactory — это реализация паттерна Фабрика для создание бинов.
* >>>>> ApplicationContext — (из-за большей функциональности рекомендуется использование вместо BeanFactory) может быть использован для загрузки и связывания бинов.
*                            Существует 3 основных реализации:
*                            1. ClassPathXmlApplicationContext (получает информацию из xml-файла, находящегося в classpath)
*                            2. FileSystemXmlApplicationContext (получает информацию из xml-файла)
*                            3. XmlWebApplicationContext (получает информацию из xml-файла за пределами web-приложения)
*
* >> Области видимости (scopes) бинов:
*   1. singleton - (по умолчанию) IoC контейнер создает единственный экземпляр бина без сохранения состояния (stateless);
*   2. prototype - Spring IoC контейнер создает любое количество экземпляров бина с сохранением состояния (stateful);
*   3. request - жизненный цикл экземпляра ограничен единственным HTTP-запросом;
*   4. session - жизненный цикл экземпляра ограничен в пределах одной (HTTP) сессией;
*   5. global session - жизненный цикл экземпляра ограничен в пределах глобальной (HTTP) сессией;
*   6. application - жизненный цикл экземпляра ограничен в пределах ServletContext;
*
* После выхода четвертой версии спринга, у нас появилось четыре способа конфигурирования контекста:
* 1. Конфигурация через аннотации с указанием пакета для сканирования .............................................. AnnotationConfigApplicationContext(“package.name”)
* 2. Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration ... AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.
* 3. Xml конфигурация .............................................................................................. ClassPathXmlApplicationContext(“context.xml”)
* 4. Groovy конфигурация ........................................................................................... GenericGroovyApplicationContext(“context.groovy”)
  ====================== (1) property.properties, (2) ClassConfig.java, (3) context.xml, (4) context,groovy ======================

* Бин в Spring используется для ссылки на любой компонент, управляемый контейнером.
* Существует несколько способов работы с классами как Spring Bean (XML конфигурация, Java based конфигурация, Annotation based конфигурация)
* В Spring предусмотрен дополнительный механизм связывания @Autowired (чтобы аннотация заработала необходимо указать настройки в конфигурационном файле спринг 'context:annotation-config').
* По умолчанию бин задается как 'синглтон' в Spring. Таким образом все публичные  переменные класса могут быть изменены одновременно из разных мест. Поэтому Spring Bean не является потокобезопасным.
* Однако поменяв область действия бина на: 'request', 'prototype', 'session' - он станет потокобезопасным (но это скажется на производительности).
*
* По сути можно класс с любым скоупом определять в любом классе с другим скоупом...но при этом:
* - 'Singleton' бин всегда существует только в единственном экземпляре(является потоко-НЕбезопасным) И всегда будет существовать...
                Если 'Singleton' бин является зависимым для для другого объекта (то есть внутри другого объекта будет объявлено поле типа-класса 'Singleton')
				>> тогда при удалении этого другого-объекта ничего страшного НЕпроизойдет (объект удачно удалиться и программа успешно будет продолжать работать...)
* - 'Prototype' бин (или любой другой) существуют во многих экземплярах НО будет существовать только лиш кратковременно...
                Если 'Prototype' бин является зависимым для для Singleton-объекта (то есть внутри Singleton-объекта будет объявлено поле типа-класса 'Prototype')
				>> тогда при удалении этого другого-объекта удалиться и ссылка на него И это приведет к ошибке 'NullPointerException'
* В 'Singleton' бине можно успешно создавать разовые объекты для генерации например случайных чисел И такие разовые объекты успешно будут работать для всех других объектов...
*
* Чтобы можно было связывать бин обладающий меньшей областью видимости (например, session) с бином, у которого область видимости больше (например, singleton) необходимо вставлять не сами бины, а их прокси объекты
* Самое интересное начинается, когда бин (Bean) со скоупом 'prototype' вставляют в singleton-бин. Тогда появляется понятие "Прокси":
*   @Component
*   @Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
*   public class MyUserData {
*     //...
*   }
*
*   @Bean(scope = DefaultScopes.SESSION)
*   @ScopedProxy
*   public UserPreferences userPreferences() {
*     return new UserPreferences();
*   }
*
* При использовании Constructor Injection, может возникнуть еще одна проблема, известная как Кольцевая Зависимость (Circular dependencies). Представьте себе ситуацию, когда конструктор класса А требует в качестве параметра экземпляр класса B, а тот в свою очередь требует в констуркторе наличие класса A!? В этом случае, Spring Framework, не сможет „поднять“ экземпляры упомянутых компонент (beans), и выбросит исключительную ситуацию: BeanCurrentlyInCreationException. Выходом из подобной ситуации будет переход к Setter Injection. В этом случае при создании объектов, поля будут проинициализиорованы null и только в следующем проходе Spring выполнит Setter Injection.
*
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                        Cвязь между компонентами (DI - иньекция зависимостей):
*                        - выполнена через поле класса – 'Setter Injection' (SI);
*                        - или с использованием конструктора – 'Constructor Injection' (CI)
*                   При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                   в этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу...
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.


+ JAX-WS
 * @WebService — указывает на то, что Java класс (или интерфейс) является веб-службой
 * @WebMethod — позволяет настроить то, как будет отображаться метод класса на операцию веб-службы
 * @WebParam — позволяет настроить то, как будет отображаться конкретный параметр операции на WSDL-часть (part) и XML элемент
 * @WebResult — позволяет настроить то, как будет отображаться возвращаемое значение операции на WSDL-часть (part) и XML элемент
 * @Oneway — указывает на то, что операция является односторонней, то есть не имеет выходных параметров
 * @SOAPBinding — позволяет настроить то, как будет отображаться веб-служба на протокол SOAP
 *
 * 1. Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
				@WebService(name="EntityPortMyType", targetNamespace = "http://my.domain.com/ws/definitions")
				public interface EntityManager{
				    @WebMethod
				    long addEntity();

				    @WebMethod
				    long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );

				    @WebMethod
				    void removeEntity( @WebParam(name = "id")long id );
				}
 * 2. Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
 *      portName        - должен указывать на порт того типа, что прописан в интерфейсе
 *      targetNamespace - должен быть такой же, как и у интерфейса
 *      endpointInterface - точно указывать на полное имя реализуемого интерфейса
 *      wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
				@WebService(serviceName = "EntityManager",
				            portName="EntityPortMyType",
				            endpointInterface = "com.mydomain.webapp.domain.EntityManager",
				            targetNamespace = "http://my.domain.com/ws/definitions",
				            wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")

				public class EntityManagerImpl implements EntityManager{
				    public long addEntity(){
				        // method body
				        return 0;
				    }

				    public long findEntity(IdentityType i_type, String identity){
				        // method body
				        return 0;
				    }

				    public void removeEntity(long id){
				       // method body
				    }
				}
 * 3. В pom файле проекта необходимо совершить:
 *    - вставить код для jaxws-maven плагина,
 *    - обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть)
				<plugin>
				        <groupId>org.codehaus.mojo</groupId>
				        <artifactId>jaxws-maven-plugin</artifactId>
				        <executions>
				            <execution>
				                <goals>
				                    <goal>wsgen</goal>
				                </goals>
				            </execution>
				        </executions>
				        <configuration>
				            <resourceDestDir>${basedir}/src/main/webapp/WEB-INF/wsdl</resourceDestDir>
				            <sei>com.my.domain.webapp.domain.EntityManagerImpl</sei>
				            <genWsdl>true</genWsdl>
				            <keep>true</keep>
				            <packageName>com.my.domain.webapp.domain</packageName>
				        </configuration>
				</plugin>
				<dependency>
				     <groupId>com.sun.xml.ws</groupId>
				     <artifactId>jaxws-rt</artifactId>
				     <version>2.1.3</version>
				</dependency>
 * 4. Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
 *    - Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
 *    - Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener)
				 <listener>
				    <listener-class>
				        com.sun.xml.ws.transport.http.servlet.WSServletContextListener
				    </listener-class>
				</listener>

				<servlet id="ws-entities-servlet">
				    <servlet-name>EntityService</servlet-name>
				    <servlet-class>
				        com.sun.xml.ws.transport.http.servlet.WSServlet
				    </servlet-class>
				    <load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping id="ws-entities-servlet-mapping">
				    <servlet-name>EntityService</servlet-name>
				    <url-pattern>/app/entities</url-pattern>
				</servlet-mapping>
 * 5. Создать файл sun-jaxws.xml
 *      Но что же сервлет будет делать с запросом, пришедшим на url-pattern?
 *      В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки:
				<?xml version="1.0" encoding="UTF-8"?>
				<endpoints
				        xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"
				        version="2.0">
				    <endpoint name="EntityManager"
				            implementation="com.my.domain.webapp.domain.EntityManagerImpl"
				            url-pattern="/app/entities"/>
				</endpoints>
 * 6. Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса
				http://localhost:8080/my-webapp/app/entities?wsdl



ConcurrentLinkedQueue:
.element()
.pull()
.peek()
.pop()

++++++++++++++++++++++++++++++++++++++
Стек - это структура данных, хранящая объекты в порядке "первым вошел, последним вышел" или "последним вошел, первым вышел".
       Обычно у этой структуры есть API с такими методами, как push() и pop(). Иногда присутствует метод peek().

Метод push() - принимает входной объект (например: foo и помещает его во внутренний контейнер; например: массив).
               Метод push() обычно ничего не возвращает.

Если передать методу push() два объекта, например, сначала foo, а потом bar - второй объект bar должен оказаться наверху концептуального стека, содержащего по крайней мере два объекта, так что при вызове метода pop() объект bar должен быть извлечен первым, до первого объекта foo. Если метод pop() вызвать еще раз, должен быть возвращен объект foo и стек должен стать пустым.

Метод pop() удаляет самый последний элемент, добавленный в стек - да, метод pop() должен удалить верхний элемент, при этом предполагается, что в стеке есть элементы, чтобы их удалять.

Метод peek() - работает точно также (метод pop()), но при этом объект не удаляется.
               Метод peek() должен оставить верхний элемент в стеке.

Если вызвать метод pop(), когда в стек еще ничего не было добавлено -  метод pop() должен выдать исключение, показывающее, что в стек еще ничего не добавлялось.

Если выполнить команду push() null - стек должен выдать исключение, так как null не является допустимым значением для метода push().
++++++++++++++++++++++++++++++++++++++
Akka - заботится о потоках и синхронизации...
Spray - это простой но мощный инструмент для построения REST/HTTP сервисов (ничего лишнего)
Play! - это фреймворк для построения RESTFul API (содержит много вещей которые мы не используем)
Slick - работа с базой данных
Scalaz - упрощает программирование в функциональном стиле

ScalaTest - тестирование, близко напоминает тесты в стиле JUnit (удобно)
Specs2 - применяется в стиле модульного тестирования
FlatSpec - для перехода от JUnit-тестированию к использванию BDD-тестирования
Spock - фреймворк для написания тестов в стиле Behaviour-Driven Development (BDD), (для Java и Groovy приложений)

Test-Driven Development (TDD) - это техника программирования, когда модульные тесты пишутся до самой программы
"test-case" (тест кейс) - выполняет одноно типовое действие над исследуемой системой (аргумент1=действие1)
Data-Driven Testing (DDT) - это тесты управляемые данными, когда тестовые данные хранятся отдельно от скриптов
"data-driven" (тест, управляемый данными) - один алгоритм проверки и много вариантов входных данных
Behaviour-Driven Development (BDD) - разработка основанная на функционировании (как программа работает, а не что она производит в конечном итоге)

Simple Build Tool (SBT) - Стандартное средство сборки приложений для Scala
Spark - представляет собой новую кластерную вычислительную среду, обладающую полезными особенностями
Docker - система виртуализации
Agile - это ускоряющая методология создания проектов. Она минимизирует риски посредством коротких (2–3 недели)циклов, или итераций, разработки.
+++++++++++++++++++++++++++++++++++++++
+++++++++++++++++++++++++++++++++++++++
Scala, Akka, Multithreading, Algorithms, Machine Learning, Design Patterns
Also have some experience with: Spark, Hadoop, Docker, Play
Методология Agile

Core Java, Concurrency;
J2EE: Servlets, JPA, JMS
Spring: MVC, Security, Data, IOC
Scala: Collections, Akka;
Testing: JUnit, Mockito, Specs2, Spock;
maven, sbt, git, svn;
Linux: Bash scripting, using as server system;

ScalaTest
FlatSpec

Understanding of SQL and NoSQL concepts
Practical Spark experience or Spark MooC certificates is a big plus
Experience in optimising application performance and database queries

+ Low latency\Heavy loaded project
+ Reactive Programming (Kiev Polytechnic Institute)
+ + + + + + + + + + + + + + + + + + + +
ОБЯЗАТЕЛЬНЫЕ ТРЕБОВАНИЯ
    Знания Scala на уровне A2/L1.
    Опыт использования ORM (Hibernate, Slick и пр.).
    Умение использовать системы автоматического тестирования (JUnit, ScalaTest, ScalaMock).
БУДЕТ ПЛЮСОМ
    Опыт ведения проектной документации.
    Знание протокола HTTP и WebSockets.
    Опыт использования Scala-фреймворков Play 2, Akka (spray).
    Опыт использования NoSQL (например, Cassandra, Spark, MongoDB).
    Опыт установки и администрирования серверов приложений (Tomcat, GlassFish, JBoss).
    Владение инструментами для сборки проектов (Gradle, SBT).
    Опыт использования систем Continuous Integration (TeamCity, Jenkins).

Akka framework
Machine learning as a plus

Обязанности:
    Рефакторинг и оптимизация существующего решения.
Требования:
    Опыт работы с akka, spray, slick от года;
    Убежденность в необходимости написания тестов;
    Опыт решения задач интеграции с другими системами;
    Понимание принципов работы HTTP, Websockets;
    Опыт работы с high load решениями будет плюсом.
+++++++++++++++++++++++++++++++++++++++




(стартап) IT-Project
--------------------
Akka framework (Akka HTTP, Akka-HTTP-Sessions)
SecureSocial (Silhouette)
Spray
Finagle
Play Framework
Apache Spark
Docker
++++++++++++++++++++
Akka (Akka Cluster)
SecureSocial (Silhouette) - OAuth2
Spray
Spark & Spark Notebook
Hibernate, Slick
SBT

NodeJS
Angular











P. 142 | Practice 2
-------------------
#1
Do you go to shcool by car? Yes, I do.
Do they live in New York? Yes, they do.
Do you work at home? No, I don't.
Do they get up early? No, they don't.
Do you have breakfast? Yes, I do.
Do you study in Russian? No, I don't.

#2
Have you live in a flat? No, I haven't.
Are Marek and Monika married? No, they aren't.
Have your parents go out a lot? Yes, they have.
Heve you got a new computer? No, I haven't.
Do you have launch in a cafe at the weekend? Yes, I have.
Have you work in the city centre? No, I haven't.
Are they fron Italy? No, they aren't.


P. 143 | Practice 3
-------------------
#1
1)  6:05
2) 10:35
3)  8:30
4) 10:20
5) 11:40
6)  3:15
7)  9:00
8)  9:45

#2
a) half past three
b) quarter past six
c) ten past five
d) elevent oclock
e) quarter to six
f) twenty-five to ten
g) five to four
h) twenty past seven
i) twenty to ten
j) five past one


P. 143 | Remember these words
-----------------------------
>> (Предлоги) http://english-tutorial.ru/grammar-96/
 -=ЕСЛИ ПРИСУТСТВУЕТ СЛОВО ЧТО УКАЗЫВАЕТ НА ВРЕМЯ=-
0. предлог не ставится если выражение включает одно из слов: 'next','last','this','that','one','any','each','every','some','all'
   перед названиями дней в разговорной речи часто опускается предлог 'on' а периодичность может обозначаться словами days, nights, mornings, evenings, afternoons.
 -=ВРЕМЯ ЧТО ВНУТРИ МЕНЕЕ-СУТОК=-
1.          'at' используется для обозначения внутрисуточного времени: at 10 o’clock, at 7.45, at midnight, at night, at dinner.
   ставится перед словами выражающими периодичность или сиюминутность: at the weekend, at weekends.
                                                 популярные праздники: at Christmas, at New Year, at Easter.
                                                    отдельные моменты: at the moment, at present, at the same time.
 -=ДЛЯ ДАТ, ДЛЯ (ДАТ)ПРАЗДНИЧНЫХ ДНЕЙ, ДЛЯ (ДАТ)ДНЕЙ НЕДЕЛИ=-
2.                                        'on' используется для обозначения дней недели: on Monday, on Tuesdays.
                                                                       даты и праздники: on 21 March 1996, on April 1st, on Christmas Day, on my birthday
   если перед временем суток указан день недели то словосочетание идет с предлогом 'on': on Saturday morning, on Sunday evening
 -=ВРЕМЯ НА БОЛЕЕ ДЛИТЕЛЬНЫЕ-ПЕРИОДЫ И ВРЕМЯ НА ПРОМЕЖУТОК ВРЕМЕНИ=-
3. 'in','in the' характеризует наиболее продолжительные периоды (месяцы, сезоны, года): in January, in (the) winter, in 1984, in the 1960s, in the 20th century, in the past, in (the) future.
                 еще 'in','in the' определяет за какой промежуток выполняется действие: in the morning(s), in the afternoon(s), in the evening(s), in the night. Окончание -s указывает на то что событие повторяется каждый упомянутый период.
-----------------------------
>> (Английские предлоги места) http://online-teacher.ru/study/english-predlogi-mesta
1.          'at' находится временное-короткое-время где-то внутри чего-то: at the railway station, at the theatre, at the birthday party
2. 'on' находится временное-короткое-время возле,около,на чем-либо сверху: on the right side, on the sixth floor, on the radio, on TV
3. 'in','in the' находится более-длительное-время где-то внутри (в рамках) чего-то: in Berlin, in the train, in the letter
+. next to, beside, by: непосредственно рядом, очень близко от чего-либо
+. under: расположение ниже/под чего-либо
+. below: расположение ниже какого-либо уровня
+. over: расположение сверху (на поверхности) чего-либо
+. above: расположение над чем-либо (выше)
+. across: расположение с другой стороны; переход на другую сторону чего-либо
+. through: прохождение насквозь, движение сквозь что-либо
+. to: движение по направлению к кому-либо или к чему-либо
+. into: движение, перемещение внутрь чего-либо
+. towards: движение по направлению к чему-либо или кому-либо, приближение без необходимости достижения цели
+. onto: движение, перемещение наверх
+. from: движение откуда-либо, от какой-то отправной точки; указание на происхождение

There is a great difference between her wishes and his possibilities. == ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
-----------------------------
 -=МЕСТО=-
a cinema ........... кинотеатр
a swimming pool .... басейн
a beach ............ пляж
a park ............. парк
a block of flats ... блочный дом (для жилья)
a restaurant ....... ресторан
  small shops ...... магазин
a supermarket ...... супермаркет
a street market .... рынок
a shopping center .. (сеть магазинов)
 a town ............ (маленький) городок
 a city ............ (большой) город
 a village ......... село
 -=ВРЕМЯ=-
at midday .......... в (конкретно-точно) полдень (= одного дня..)
at lunchtime ....... в (конкретно-точно) время обеда (= одного дня..)
at midnight ........ в (конкретно-точно) полночь (= одного дня..)

at the weekend ..... в этот (конкретно-точно) выходной день (= одного дня..)

in the morning ..... в течении утра (в один из какого-нибудь часа = между-через..)
in the afternoon ... в течении после обеда (полудень - в один из какого-нибудь часа = между-через..)
in the evening ..... в течении вечера (в один из какого-нибудь часа = между-через..)

on weekdays ........ в один из (какой-нибудь день) будних дней (в течении рабочей недели = на протяжении..)
 -=ДЕЙСТВИЕ=-
to open ............ (делать) открывать
to close ........... (делать) приближаться
to finish .......... (делать) останавливаться
 -=...=-
by bus ............. НА автобусе

#1
1. I LIVE in a big flat in Milan.
2. They HAVE breakfast in a cafe at the weekend.
3. We STUDY English after school.
4. I GET UP at 6:00 in the morning.
5. You GO to scool by bus and train.
6. I WORK long hours for a big company.

#2
1. I get up AT half past seven.
2. They play football ON Saturdays.
3. Do you have lunch AT midday?
4. I don't work AT the weekend.
5. Do they sleep IN the afernoons?
6. I go to bed early ON weekdays.
7. We wotch TV IN the evenings.
8. They shops close AT lunchtime.

P. 31 | Useful language
#A.
1. Most people live in flats in the city.
2. Children start school at half-past eight.
3. Most people have lunch in offices.
4. Shops close at 13:00 oclock for lunchtime.
5. Yes, they do.
6. Restaurants close at 11:00 p.m.
7. Yes, it does.
8. People have dinner at 8:00 p.m.

#B.
1. Most people live in flats in the city.
2. Most people don't live in the city centre.
3. Children start school at 8:30 a.m., and finish school at 2:30 p.m.
4. Most people don't go home for lunch, because they have lunch in offices.
5. Most shops open at 9:00 a.m. and close at 21:00 o'clock.
6. Most people have lunch at 12:00 o'clock and have dinner at 20:00 oclock.
7. Restaurants open at 9:00 a.m. and close at 9:00 p.m.


(H/W) P. 34
-----------
>> () http://englishbigidea.blogspot.com/2013/12/Like-love-hate-prefer.html
#1
# из инфинитива (ing) в >> I go for walks on holiday...
going for walks ................ гулять
dancing ........................ танцевать
cycling ........................ ездить на велосипеде
reading ........................ читать
cooking ........................ готовить
spending time with friends ..... проводить время с друзъями
plaing computer games .......... играит в компьютерные игры
wathing sport .................. смотреть спорт
spending time on the internet .. проводить время в интернете
swimming ....................... плавать

> I go for walks on holidays.
> I never dance.
> Sometimes I ride a bicycle.
> I often read books.
> Sometimes I cook.
> Sometimes I spend time with my friends.
> I never play computer games.
> I never wath sport.
> I often spend time on the internet.
> Sometimes I go to swim in the pool.

#2
>> To love ..... любить
>> To like ..... нравится
>> To hate ..... ненавидеть
>> To prefer ... предпочитать
>> To want ..... хотеть

> Do you go for walks on holiday?
  Yes, I do.
> Do you like dancing?
  No, I don't.
> Do you like cycling?
  Yes, I do.
> Do you like reading books?
  Yes, I do.
> Do you like cooking?
  No, I don't. I hate it.
> How often do you spend time with your friends?
  I spend time with my frends once or twice a month.
> Do you play computer games?
  Yes, I do. I like it.
> Do you watch sport?
  No, I don't.
> How much time do you spend on the internet?
  I spend four or five hourson the internet.
> Do you like swimming?
  Yes, I do. I like swimming.


P. 35 | Practice 1
- - - - - - - - -[ Like/Dislikes with noun and -ing ]
+ Like.
+ Love.
~ Don't mind.
- Hate.
- Can't staund.
- Don't like / Dislike.

She lives in a big house.
She doesn't like doing big concerts.
She likes comfortable clothes.
She hates the food on aeroplanes.
She doesn't like flying.
She loves singing.
------------------
#1a
1.        (go for restaurants) > She hates going to restaurants.
2. (go for walks with her dog) > She likes going for walks with her dog.
3.                       (fly) > She doesn't like flying.
4.                (her mother) > She loves her mother;
5.   (spend time with friends) > She likes spending time with friends
6.           (do big concerts) > She doesn't like doing big concerts.
7.             (black clothes) > She hates black clothes.
8.    (the food on aeroplanes) > She hates the food on aeroplanes.
















(mongodb test)
https://www.tutorialspoint.com/mongodb/mongodb_mock_test.htm
https://github.com/mongodb/mongo/wiki/Test-The-Mongodb-Server
https://docs.mongodb.com/getting-started/shell/import-data/
(How to Load Test MongoDB with JMeter) https://www.blazemeter.com/blog/how-load-test-mongodb-jmeter
https://www.owasp.org/index.php/Testing_for_NoSQL_injection
(spring mongodb test)
http://stackoverflow.com/questions/29587430/spring-data-mongodb-junit-test
(embedded mongodb java)
http://stackoverflow.com/questions/6437226/embedded-mongodb-when-running-integration-tests
http://www.pretechsol.com/2012/09/java-mongodb-junit-test-with-embedded.html#.WA2_miQhWM8
(nosql java test)
http://www.methodsandtools.com/tools/nosqlunit.php
http://www.slideshare.net/tobiastrelle/no-sql-testautomation
https://dzone.com/articles/testing-spring-data-mongodb-0
https://eclipse.googlesource.com/eclipselink/examples/+/dcf45221d60f9ad69052fa54d87ab286197a52fd/jpa/nosql/mongo/src/test/java/example/Test.java
(Basic Mistakes in Database Testing) https://dzone.com/articles/basic-mistakes-database
(NoSQLUnit) http://lordofthejars.github.io/nosql-unit/nosqlunit.html
			http://www.lordofthejars.com/2012/06/nosqlunit-030-released.html >> https://github.com/lordofthejars/nosql-unit
			https://www.javacodegeeks.com/2012/04/dbunit-spring-and-annotations-for.html >> https://github.com/springtestdbunit/spring-test-dbunit/tree/master/spring-test-dbunit-sample >> http://lordofthejars.github.io/nosql-unit/nosqlunit.pdf
                          (spring nosql database testing)
(Testing Spring Data MongoDB Applications with NoSQLUnit) http://www.lordofthejars.com/2013/01/testing-spring-data-mongodb.html

                 (json validator java)
(Validate JSON against Schema in Java) http://wilddiary.com/validate-json-against-schema-in-java/
                                       https://github.com/daveclayton/json-schema-validator >> https://github.com/daveclayton/json-schema-validator/blob/master/src/main/java/com/github/fge/jsonschema/examples/Example1.java

(Гироборд (Гироскутер / Ховерборд) под Заказ) 5200 грн.
https://www.olx.ua/obyavlenie/girobord-giroskuter-hoverbord-pod-zakaz-IDlkrSv.html#e692397b73

               (opengl шейдеры)
(Шейдеры в libgdx для чайников) https://habrahabr.ru/post/274813/
Kanban
Java 8, Spring, Spring Security, Jetty, NoSQL,
Git, Sonar, TeamCity
Automation Testing
Cassandra, Kafka, Node.js, Backbone.js

Spring: '@Authowired' или 'set-ер' - почему?




https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377534
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377567
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377574
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377595



В класе-интерфейса можно создавать поля-переменные, только НУЖНО их сразу-же здесь иннициализировать (типа как finul..)!!!


>> (Столкнулся с такой проблемой - редактировал файл style.css через Notepad++) http://ru.stackoverflow.com/questions/335561/Восстановить-содержимое-файла













PL/SQL — процедурный блочно-структурированный язык.
> Создание пакетов, процедур и функций, хранимых в базе данных.
> Предоставление интерфейса для вызова внешних процедур.
> Поддержка типов данных SQL и внутренних типов PL/SQL.
> Работа с курсором.
> Механизм обработки исключений.

> Не чувствителен к регистру (кроме строковых переменных и констант).
> Каждая конструкция PL/SQL должна заканчиваться символом ;
> Одна конструкция может быть расположена на нескольких строках.

> Блок — основная структурная единица PL/SQL.
  Блок позволяет объединять объявления и операторы, связанные общей логикой.
  >> Может быть анонимным или именованным.
  >> Может содержать вложенные блоки.
  >> Составные части блока:
     секция объявлений;
     тело блока (обязательная часть);
     обработчики исключений.

DECLARE
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код программы (обязательная часть блока)
EXCEPTION
  -- Обработка исключений
END;
/* Многострочные
комментарии… */
-- Однострочный комментарий

Переменные:
    Могут иметь тип данных SQL или PL/SQL.
    Объявляются в секциях объявлений блоков PL/SQL.
    Видны внутри блока, в котором они объявлены.
    Получают тип данных при объявлении.
    Могут быть проинициализированы значением при объявлении.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

3 Слайд: Часть 1. Структура кода в PL/SQL
    3.1 Слайд: Блоки PL/SQL
    3.4 Слайд: Объявление переменных
    3.7 Слайд: Операторы выбора (IF)
    3.8 Слайд: Операторы выбора (CASE)
    3.11 Слайд: Операторы цикла (простой LOOP)
    3.12 Слайд: Операторы цикла (WHILE LOOP)
    3.13 Слайд: Операторы цикла (FOR LOOP)
    3.15 Слайд: Операторы перехода (GOTO)
4 Слайд: Часть 2. Основные типы и структуры данных
    4.1 Слайд: Типы данных
    4.4 Слайд: Приведение типов
    4.6 Слайд: Коллекции
    4.9 Слайд: Записи
    4.11 Слайд: Атрибуты типизации
5 Слайд: Часть 3. Взаимодействие с БД
    5.1 Слайд: Извлечение и обработка данных
    5.5 Слайд: Курсоры
    5.12 Слайд: Вызовы SQL в PL/SQL-ном блоке
    5.14 Слайд: Динамический SQL — пример
    5.15 Слайд: Управление изменениями
    5.18 Слайд: Триггеры
6 Слайд: Часть 4. Исключения
    6.1 Слайд: Обработка ошибок
    6.3 Слайд: Предопределенные исключения
    6.4 Слайд: Объявление исключений
7 Слайд: Часть 5. Подпрограммы
    7.1 Слайд: Функции, процедуры
    7.6 Слайд: Параметры
    7.9 Слайд: Перегрузка функций, процедур
    7.11 Слайд: Рекурсивный вызов
8 Слайд: Часть 6. Пакеты PL/SQL
    8.1 Слайд: Структура пакета
    8.3 Слайд: Доступ к элементам пакета
    8.4 Слайд: Инициализация данных пакета
9 Слайд: Часть 7. И еще...
    9.1 Слайд: Получение информации из запроса/блока/функции
    9.3 Слайд: Системные представления
    9.4 Слайд: Механизм заданий (jobs)
    9.7 Слайд: Коротко об sqlplus

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Курсор — получаемый при выполнении запроса результирующий набор записей плюс привязанный к нему указатель текущей записи.
Курсоры:
    Явные (объявляются разработчиком).
    Неявные (не требуют объявления, управляются автоматически).
Состояние курсора — атрибуты:
     %ISOPEN
     %FOUND
     %NOTFOUND
     %ROWCOUNT

Триггеры на события DML (на строку/на операцию).
Триггеры INSTEAD OF.
Триггеры на события DDL.
Триггеры на события уровня схемы/БД

1. Обработка ошибок
2. Предопределенные исключения
3. Объявление исключений
Исключение — ошибка времени выполнения.
    Нормальное выполнение блока прекращается.
    Управление возвращается внешнему (вызвавшему) блоку.
    ...до тех пор, пока исключение не будет «перехвачено» и обработано:
        выдано user-friendly сообщение пользователю;
        записано в лог;
        проигнорировано;

Подпрограмма — именованный блок PL/SQL, который может иметь параметры вызова.
Аналогично анонимным блокам могут быть вложенными.

PROCEDURE процедура (параметры) AS
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код процедуры (обязательная часть подпрограммы)
EXCEPTION
  -- Обработка исключений
END процедура;

Функция
	Возвращает некоторое значение.

FUNCTION функция (параметры)
  RETURN тип_значения
AS
  -- Объявление переменных, типов, курсоров и проч.
BEGIN
  -- Код функции (обязательная часть подпрограммы)
EXCEPTION
  -- Обработка исключений
END функция;

Пакет — хранимый объект, объединяющий логически близкие типы, данные, подпрограммы.

CREATE OR REPLACE PACKAGE пакет AS
  TYPE какой_то_тип AS /*...*/;
  какая_то_переменная тип;
  PROCEDURE какая_то_процедура;
  FUNCTION какая_то_функция RETURN тип;
  --...
END пакет;

Утилита SQL*Plus: позволяет выполнять команды SQL и блоки PL/SQL.
sqlplus — работа в окне командной строки
sqlplusw — оконная версия

sqlplus /NOLOG @script.sql param1 param2

/*script.sql*/
-- Определить код возврата при ошибке
WHENEVER SQLERROR EXIT -1 ROLLBACK
-- Подключиться к БД (параметризовано)
CONNECT &1/&2@ORAXE;
-- Включить вывод
SET SERVEROUTPUT ON;
-- Логировать действия в файл
SPOOL test.log;
-- Объявить и присвоить bind-переменную
var v_cnt NUMBER;
EXEC :v_cnt := 30;
-- Выполнить команду SQL
SELECT * FROM emp WHERE deptno = :v_cnt;
-- Выполнить блок PL/SQL
BEGIN
    dbms_output.put_line('Listed employees for deptno '|| :v_cnt);
END;
/
-- Выйти с кодом "успешно"
EXIT 0;


1. Типы данных
   Простые (скалярные) типы (простые значения без внутренних составляющих):
    NUMBER(точность, масштаб) — число с плавающей точкой;
    CHAR2(размер) — строка постоянной длины;
    VARCHAR2(макс_размер) — строка переменной длины;
    DATE — дата (со временем);
    BOOLEAN — логическое значение;
   Составные типы (структуры из определенных компонент):
    TABLE — коллекция;
    VARRAY — массив;
    RECORD — запись.
   Ссылочные типы: ссылка на объект, например REF CURSOR.
   LOB типы: «локатор», определяющий расположение больших объектов данных (графика, файлы,...):
    BFILE — внешний двоичный файл;
    BLOB — внутренний двоичный объект;
    CLOB — внутренний символьный объект.
2. Приведение типов
     Явное:
        TO_NUMBER()
        TO_CHAR()
        TO_DATE()
        ...
    Неявное.
3. Коллекции
    Таблицы PL/SQL (TABLE)
    Массивы (VARRAY)
   Методы работы с коллекциями:
    EXISTS(индекс_элемента) — существует ли элемент по индексу?
    COUNT — количество элементов в коллекции.
    LIMIT — размер varray-массива.
    DELETE(с_элемента, по_элемент) — удалить элементы: все; один; диапазон.
    FIRST, LAST — индексы первого и последнего элемента.
    PRIOR(индекс_элемента), NEXT(индекс_элемента) — индексы следующего и предыдущего элемента.
4. Записи (RECORD)
5. Атрибуты типизации
     %TYPE
        Объявление переменной с типом другой переменной.
        Объявление переменной с типом поля таблицы в БД.
     %ROWTYPE
        Объявление переменной типа запись, по структуре соответствующей строке таблицы в БД.

Взаимодействие с БД:
1. Извлечение и обработка данных
2. Курсоры
3. Вызовы SQL в PL/SQL-ном блоке
4. Управление изменениями
5. Триггеры


Управление изменениями
Транзакция — последовательность действий с БД, которая:
    или полностью фиксируется в БД,
    или полностью отменяется.
Все SQL-операторы входят в одну транзакцию до тех пор, пока не будет сделана ее фиксация (COMMIT) или откат (ROLLBACK).
    Уровни изоляции транзакций.

Сложная (поэтапная) логика действий с БД: промежуточные точки отката
-- Начало действий с БД
--...
SAVEPOINT имя; -- Точка отката
-- Логически сгруппированные действия, которые если что следует
-- откатывать вместе без отката всей транзакции
ROLLBACK TO SAVEPOINT имя;
--...
COMMIT; -- Фиксация транзакции

Фиксация изменений в БД даже при откате транзакции: автономные транзакции
	PRAGMA AUTONOMOUS_TRANSACTION;
Блокировки.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/* Пакет реализует API доступа к данным сотрудников:
- получение имени сотрудника по его номеру
- получение названия подразделения сотрудника по его номеру
Обращения к БД кешируются.
*/
CREATE OR REPLACE PACKAGE pk_emp AS
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2;
END pk_emp;

CREATE OR REPLACE PACKAGE BODY pk_emp AS
    TYPE TStringArray IS TABLE OF VARCHAR2(100) INDEX BY BINARY_INTEGER;
    la_emp TStringArray;
    la_dept TStringArray;
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        IF NOT la_emp.EXISTS(a_empno) THEN
            SELECT ename INTO la_emp(a_empno)
                FROM emp
                WHERE empno = a_empno;
        END IF;
        RETURN la_emp(a_empno);
    END get_name;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        RETURN la_dept(a_empno);
    END get_dept;
BEGIN
    FOR lc IN (SELECT empno, dname FROM emp e, dept d WHERE d.deptno = e.deptno)
    LOOP
        la_dept(lc.empno) := lc.dname;
    END LOOP;
END pk_emp;
