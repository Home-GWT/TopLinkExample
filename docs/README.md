[Markdown: Help](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) **|** [Markdown support](https://daringfireball.net/projects/markdown/syntax)

[Хоткеи в IntelliJ-IDEA](https://juja.com.ua/java/ide/intellij-idea-hotkeys) ([+](http://eax.me/intellij-idea-hotkeys))


* **(** [Java.Test](Java.Test.txt) **)**
* [EJB делится на 3-типа компонентов](Java%20(авторизация-сервисы).txt#L424) **|** [полезные ответы на вопросы #1](AboutMe.txt#L871) **|** [полезные ответы на вопросы #2](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L153)  **(** [EJB](../src/com/voituk/jpaexample/EJB.md) **|** [Java.Test.1](Java.Test.txt) **|** [Java.Test.2](Java.Test2.txt) **|** [tree_node](../src/com/java/tree_algorithm/tree_node.pdf) **)**
* [Java Perfomance Test](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L2145) **(** [использование памяти процессом Java](https://www.ibm.com/developerworks/ru/library/j-codetoheap) **|** [SystemTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/SystemTest.java) **|** [ServicePerfomanceTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/cities_roads/ServicePerfomanceTest.java) **|** [CollectionsPerformance](https://github.com/JobTest/axiom/tree/develop4.1/src/test/java/example/testtask/townsandroads) **|** [String, StringBuffer and StringBuilder Memory and Runtime Analysis](http://java.globinch.com/java-quick-tips/performance-string-stringbuffer-stringbuilder-memory-runtime-analysis) **|** [Performance factors](http://www.vogella.com/tutorials/JavaPerformance/article.html) **|** [SearchPhrase_PerformanceTest](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/task/SearchPhrase_PerformanceTest.java) **|** [MSL2 (zip)](https://mail.google.com/mail/u/0/?tab=wm#inbox/15e6d13cebc81504) **|** [MockitoTest](https://github.com/JobTest/axiom/tree/develop/cities_roads/src/test/java/example/testtask) **+** [Get size of object in memory](http://www.javapractices.com/topic/TopicAction.do?Id=83) **+** [Memory consumption of popular Java data types – part 2](http://java-performance.info/memory-consumption-of-java-data-types-2) **)**
* [Scala Perfomance Test](http://scalameter.github.io/home/gettingstarted/0.5/configuration/index.html)
* [Коллекции](Коллекции.md) **|** [Сложности алгоритмов](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/README.md) **|** [Stack](firefox.txt#L593) **(** [Stack: push/pop/peek](../src/com/voituk/jpaexample/JMS.md#L386) **|** [Java Коллекции](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/prepare)  **|** [пример реализации кэша через LinkedHashMap](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/LRUCacheTest.java) **|** [вставка и обход бинарного дерева в глубину и в ширину](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/TreeTest.java) **|** [Tree Algorithm](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/tree_algorithm/TreeTest.java) **)**
* [Arrays / Collections .sort](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/sort/FruitTest.java) **|** [Comparable / Comparator](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/sort/Fruit.java) 
* [Дженерики](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/generic/README.md) **|** [Optional](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/README.md) **|** [Executor](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/concurrent/README.md) **|** [SQL HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/README.md) **|** [SOAP](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/SOAP/README.md)
* [Базы данных](Базы%20данных.md) **(** [JPA и Hibernate в вопросах и ответах](https://habrahabr.ru/post/265061) **|** [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **|** [HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/sql/README.md) **)**
* [PL/SQL](PL-SQL.md) **(** [Test1](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/Test1.sql#L46) **)**
* [Design Patterns](Design%20Patterns.md)
* [Исключения в Java](Исключения%20в%20Java.md) **(** [TryCatchFinaly](https://github.com/Home-Spring/SpringFileUpload2/blob/master/src/test/java/com/journaldev/spring/TryCatchFinaly.java) **|** [pdf](Исключения%20и%20ошибки.pdf) **)**
* [что нового в java-8](что%20нового%20в%20java-8.md)  **|** [Java8.2](https://github.com/Home-Java8/Java8.2)  **(** [Stream](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/Java8Test2.java) **|** [Краткий список нововведений в Java 8](http://microfork.com/whats-new-in-java-8/) **)**
* **(** [10-советов по многопоточному программированию на Java](https://tproger.ru/translations/10-java-multithread-practices) **)**
* [различие между oauth-1 и oauth-2](различие%20между%20oauth-1%20и%20oauth-2.md)
* [Аспектно-Ориентированном Программирование](АОП.md) **(** [Знакомство с АОП](https://habrahabr.ru/post/114649) **|** [Spring АОП](http://www.finecosoft.ru/spring-aop) **)**
* [introduction](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/spring_mvc/introduction.md) **(** [Home-Spring/docs](https://github.com/Home-Spring/docs) **|** spring управлять бинами на лету через xml: [1](https://habrahabr.ru/company/haulmont/blog/248981) **|** [2](https://habrahabr.ru/post/106744) **|** [3](http://java-course.ru/student/book2/spring) **|** [4](http://spring-projects.ru/guides/lessons/lesson-2) **|** [5](https://habrahabr.ru/post/228953) **|** [MVC](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/spring_mvc) **)**
* **(** [сессия](https://github.com/JobTest/axiom/blob/develop4.1/src/main/java/example/testtask/java8/meeting2/java%20developer%20kiev.txt) **)**
* [Аббревиатура SOLID](https://web-creator.ru/articles/solid) **(** `эти принципы позволяют строить на базе ООП масштабируемые ПО с понятной бизнеслогикой` **)**

    1. Принцип единственной обязанности (Single responsibility) `обозначает что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.`
    2. Принцип открытости / закрытости (Open-closed) `декларирует что классы, модули, функции должны быть открыты для расширения, но закрыты для изменения (это означает что эти сущности могут менять свое поведение без изменения их исходного кода).`
    3. Принцип разделения интерфейса (Interface segregation) `гово­рит о том, что слишком толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах которые необходимы им в работе (в итоге при изменении метода-интерфейса не должны меняться клиенты которые этот метод не используют).`
    4. Принцип инверсии зависимостей (Dependency inversion) `модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа моду­лей должны зависеть от абстракций.`
    5. Принцип подстановки Барбары Лисков (Liskov substitution) `функ­ции которые используют базовый тип должны иметь возможность использовать подтипы базового типа не зная об этом.`

![Аббревиатура SOLID](5e55695664a7484684759f990e20dbdf.png)

     При обычной рекурсии - в теле функции остается лежать текущее значение переменной.
     И каждый раз когда функция вызывает саму-себя - клонируется тело этой функции, но уже с другим значением переменной.
     И таких клонов может быть безконечное количество - именно это услоие (наличие безконечного количества клонов) и приводит к переполнение стэка.

```javascript
    static int func(int n){
        if(n==0) return 0;
        return n + func(n-1); //return n+func(--n); //return n+func(n--);
    }
```


     В хвостовой рекурсии - в теле функции никакие переменные вообще не храняться!
     Все значения для переменных передаются только в параметрах функции.
     В теле самой-же функции лежит только оператор-возврата значения. А все значения вычисляются на уровне, в момент передачи параметров.
     То есть, каждый раз когда функция вызывает саму-себя старое тело функции уничтожается! И поэтому клон функции будет всегда один (это значит что переполнения стэка никогда не наступит)

```javascript
    static int add(int nun, int step){
        if(step==0) return nun; //return 1;
        return add((nun+(step-1)), step-1);
    }
```


     Функции высшего порядка - это функция которая принимает в качестве аргументов другие функции или возвращает в качестве результата другую функцию.
     ( Идея состоит в том что функции имеют такой-же статус как и другие объекты данных.
       Использование функций высшего порядка приводит к абстрактным и компактным программам... )

```javascript
    Function<Integer, Integer> f = x -> x + 3;
    BiFunction<Function<Integer, Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
    System.out.println(g.apply(f, 7));
```

     Каррирование - это преобразование функции со многими аргументами в набор функций каждая из которых имеет по одному аргументу.

     Замыкание - ( является глобальной переменной ) это когда в теле функции присутствуют ссылки на переменные которые объявленные вне тела этой функции.

```javascript
    /**
     * 'Optional' (проверка на 'null' средствами Java 8, без условных операций...)
     * **********
     * функция может принимать значение либо строка либо null
     * В случае если значение null тогда Optionak должен вернуть альтернативное значение (НЕ null...)
     */
    public Optional<String> func(String value) {

        Optional<String> res = Optional.ofNullable( value );

        return res.orElse("альтернативное НЕпустое значение");
    }
```

```javascript
    /**
     * 'Stream'
     * **********
     * в первом случае:
     * * 'map' преобразует поток stream-ов в (поток) список String-ов
     * * находит первый попашийся элемент с этого списка String-ов
     * * и возвращает элемент типа String
     */
    public String findId() {
        
        List<Client> clients = ...

        return clients.stream()
                .map(client -> client.getTaxId()) // Client -> String
                .findFirst()
                .get(); // String
    }

    /**
     * 'Stream' + 'Optional'
     * *********************
     * во втором случае:
     * * 'map' преобразует поток stream-ов в (поток) список String-ов
     * * находит первый попашийся элемент с этого списка String-ов
     * * и возвращает элемент типа Optional
     * дальше Optional проверяет:
     * * если результат НЕ null тогда возвращаем найденный результат (это для того чтобы предотвратить 'NullPointerException')...
     */
    public String findId() {
        
        List<Client> clients = ...

        Optional<String> taxId = clients.stream()
                .map(client -> client.getTaxId()) // Client -> String
                .findFirst(); // Optional<String>

        return taxId.isPresent() // true / false
                ? taxId.get() // String
                : "НЕнайдено";
    }
```

---
1. Есть обычные интерфесы (которые имплементируются в классах);
2. Есть интерфейсы с дефолтными методами ('default' - которое определяют дефолтную реализацию методов еще на уровне интерфейса);
3. Есть функциональные интерфейсы (это интерфейсы только с одним методом);

.

    Так вот, лямбда-выражение - это отложенное определение тела функции на потом (с помощью функциональных интерфейсов...).
    Удобным способом использования их является тот факт, что можно опускать круглые и фигурные дужки (с помощью которых описывается синтаксис для параметра и тела функции...).
    Кроме этого, реализовывать определение тела функции можно и в отдельнм классе (при условии что поля этого класса будут идентичны функционвльному интерфейсу)

```javascript
    interface MyFace2 {
        void hello(String val);
    }

    MyFace2 face2 = val -> { System.out.println(val); };
    face2.hello("Hello!");
```

```javascript
    static class MyClazz3 {
        public static void hello(String val) {
            System.out.println(val);
        }
    }

    MyFace3 face3 = MyClazz3::hello;
    face3.hello("Hello!");
```


---
* ( Java-8 )

'map()' - преобразует данные из одного типа в другой.
          Например, есть 'Publisher' (издатель) и есть много подписчиков 'Subscribe'. Так вот: 'map' делает легкое связывание между двумя этими источниками И
                    позволяет передать данные от одного типа источника 'Publisher' для (других типов источников) всех его зависимых слушателей 'Subscribe'.

     'map()' - может преобразовывать каждый элемент стрима И возвращает только одно значение (а именно - коллекцию).
     'flatMap()' - может преобразовывать каждый элемент стрима НО возвращает поток значений (стрим).


---
* Классы

```javascript
    /**
     * A static{}
     * B static{}
     * A {}
     * B.func=null
     * B {}
     */

    /*
     * #1. первым делом, в классе, будут вызваны статические блоки И в базовом классе и потом в классе наследнике.
     *     (для всех блоков правило 'полиморфизма' не действует!)
     */

    /*
     * #2. Полиморфизм - это правило переопределение функции по умолчанию в классах наследниках действует только на функции класса.
     *     Те функции которые переопределенные в классе наследнике по умолчанию применяются для всех базовых классов.
     */

    /*
     * #3. дальше, в классе, будут вызваны обычные блоки И в базовом классе и потом в классе наследнике.
     */

    /*
     * #4. только потом, в классе, будут вызваны конструкторы И в базовом классе и потом в классе наследнике.
     *     Конструкторы это такие себе именнованные блоки, которые ведут себя как обычные блоки, но при этом служат для иннициализации класса в момент его создания.
     */
```

```javascript
    /**
     * В интерфейсе можно объявлять поля НО они должны быть обизательно проинициализированны И НЕдолжны быть приватными!
     * (по умолчанию все поля в интерфейсе являются статическими и публичными и финальными)
     */
    public interface MyC {
//        public static final int a; // ошибка - нет иннициализации
//        private int b = 100; // ошибка - нельзя приватное поле
        int a = 100; // нормально!
        String str = "abc"; // нормально!
        Aaa aaa = new Aaa(); // нормально!

        class Aaa {
            private int ego;
            private String name;
            public int getEgo() {
                return ego;
            }
            public void setEgo(int ego) {
                this.ego = ego;
            }
            public String getName() {
                return name;
            }
            public void setName(String name) {
                this.name = name;
            }
        }
    }
```

```javascript
    /**
     * Интерфейс может иметь или НЕиметь вообще методов (интерфейсные - без реализации)
     * Но в интерфейсе запрещается иметь методы с реализацией
     * Интерфейсы в Java используются для МНОЖЕСТВЕННОГО наследования
     * Дефолтные методы интерфейса в Java-8 (наоборот) разрешают НЕпереопределять их в классе-наследнике
     * МОЖНО делать static интерфейс но НЕЛЬЗЯ делать final интерфейс и его методы (НО поля внутри интерфейса являются final)
     * 
     * Абстрактный класс может иметь или НЕиметь вообще методы абстрактные методы или может НЕиметь ниодного вообще любого методы
     * Абстрактные классы в Java используются для ОДНОГО наследования (НО он принуждает что реализация метода должна обизательно быть определена в классе-наследника)
     * Еще абстрактный класс запрещает создавать его экземпляр
     * (Общее между абстракцией и функциональным интерфейсом - то что они все должны быть переопределены в своих наследниках...местах вызова)
     */

    interface A {}

    interface AA {
        int a();
    }

    interface AAA {
        default int a() {
            return 0;
        }
    }

    abstract class B {}

    abstract class BB {
        abstract int a();
    }

    abstract class BBB {
        int a() {
            return 0;
        }
    }
```

```javascript
    /**
     * Статические классы вместе со статическими методами МОЖНО НАСЛЕДОВАТЬ!
     * При этом использование операторов 'new' и 'null' НЕбудет играть никакой роли...потому-что оператор 'static' уже создаст единственный экземпляр для этого приложения И все зависит только от объявленного типа переменной-класса
     * 
     * статические поля и методы МОГУТ вызываться внутри НЕстатических методов!
     * НО НЕстатические поля и методы НЕМОГУТ вызываться внутри статических методов
     */
    public static class MyA {
        public static void func() {
            System.out.println("MyA");
        }
    }

    public static class MyB extends MyA {
        public static void func() {
            System.out.println("MyB");
        }
    }
    
    ///////////////
    MyA.func();
    MyB.func();

    MyA myA = new MyA();
    MyB myB = new MyB();
    MyA myX = new MyB();
    myA.func();
    myB.func();
    myX.func();

    myA = null;
    myB = null;
    myA.func();
    myB.func();
```

    Java работает только на ПОВЫШЕНИЯ ТИПОВ (явное-приведение типов!
    Для коллекций приведение типов работает на ПОВЫШЕНИЯ и ПОНИЖЕНИЕ ТИПОВ! (Но для этого НУЖНО указывать ТИП КОЛЛЕКЦИИ, ИЛИ можно указывать общий интерфейс)
    [здесь](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java/ExtendTest.java)

```javascript
        /*
         * Java работает только на ПОВЫШЕНИЯ ТИПОВ (явное-приведение типов)!
         * (инначе выбрасывает checked-проверяемое исключение java.lang.ClassCastException)
         */
         A a1 = new B("B1",1);
         aa = bb;
//        B b2 = (B) new A("A2"); // java.lang.ClassCastException
//        bb = (B) aa;            // java.lang.ClassCastException
         
        /*
         * Для коллекций приведение типов работает на ПОВЫШЕНИЯ и ПОНИЖЕНИЕ ТИПОВ!
         * (Но для этого НУЖНО указывать ТИП КОЛЛЕКЦИИ, можно указывать общий интерфейс)
         * (инначе выбрасывает checked-проверяемое исключение java.lang.ClassCastException)
         */
        List<A> aList1 = (List) bList;
        List<B> bList1 = (List) aList;
        List<A> aaList1 = (LinkedList) bbList;
        List<B> bbList1 = (ArrayList) aaList;
//        List<A> aaList1 = (ArrayList) bbList; // java.lang.ClassCastException
//        List<B> bbList1 = (LinkedList) aaList; // java.lang.ClassCastException

        /*
         * Приведение типов для хеш-карт
         */
        Map<String, String> map = new HashMap<>();
        map.put("Hello", "World");
        map.put("Apple", "3.14");
        map.put("Another", "Element");

        // для списков в Java 7
        List<String> keyList = new ArrayList<>(map.keySet());
        List<String> valueList = new ArrayList<>(map.values());

        // для списков в Java 8
        List<String> values = map.values().stream()
                .collect(Collectors.toList());
        
        // для массивов
        String[] arr = map.values().toArray(new String[0]);
```

    Рефлексивность: сравнение объекта самого-себя - гарантированно возвращает равенство (при условии что объекты неNULL)
    Симметричность: если два объкекты 'A' и 'B' равны - тогда при обратном условии сравнения (либо 'A==B' либо 'B==A') гарантируется их равенство
    Транзитивность: три объекта 'A','B','C'; при двух условиях равенства объектов если 'A==B' и 'B==C' - тогда гарантируется равенство между 'A==C'
    [здесь](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L597)

```javascript
    class C {
        int ego;

        public int hashCode() { return ego; }

        public boolean equals(Object o) {
            if (this == o) return true; // Рефлексивность: сравнение объекта самого-себя
            // Симметричность: если два объкекты 'A' и 'B' равны - тогда при обратном условии сравнения (либо 'A==B' либо 'B==A') гарантируется их равенство
            // Транзитивность: три объекта 'A','B','C'; при двух условиях равенства объектов если 'A==B' и 'B==C' - тогда гарантируется равенство между 'A==C'
            if (o == null || getClass() != o.getClass()) return false;

            C c = (C) o;

            return ego == c.ego;
        }
    }
```

---
* Способы сравнения объектов

```javascript
/**
 *
 * 18. Что такое пул строк?
 * ***********************
 ** Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка,
 *  иначе создается новая строка в пуле, а затем возвращается ссылка.
 ** Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того,
 *  чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.
 *
 * пул строк – это набор строк, который хранится в памяти Java heap.
 * Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
 * Пул строк также является примером паттерна Приспособленец (Flyweight).
 * Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.
 *
 * 19. Что делает метод intern()?
 * *****************************
 * Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка
 * на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.
 * Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
 *
 */
```


---
* Concurrent Collections

```javascript
/**
 *
 * CopyOnWrite коллекции:
 * - CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList
 * - CopyOnWriteArraySet<E> — Имплементация интерфейса Set
 * Улучшенные реализации HashMap, TreeMap с лучшей поддержкой многопоточности и масштабируемости:
 * - ConcurrentMap<K, V> — Интерфейс, расширяющий Map
 * - ConcurrentHashMap<K, V> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей
 * - ConcurrentNavigableMap<K,V> — Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений
 * - ConcurrentSkipListMap<K, V> — Является аналогом TreeMap с поддержкой многопоточности
 * - ConcurrentSkipListSet<E> — Имплементация Set интерфейса
 *
 * - ConcurrentLinkedQueue — синхронно добавляет / удаляет элементы (использует алгоритм для быстрой переборки элементов)
 * - ConcurrentLinkedDequeue — (такой же как и 'ConcurrentLinkedQueue') работает в двух-стороннем порядке FIFO
 */
```


---
JPQL-запрос — используется на уровне DAO слоя...например в Spring-Data @Repository / CrudRepository / JpaRepository
               в случае если метод должен формировать специфический sql-запрос...

```javascript
    @Query("select b from Bank b where b.name = :name")
	Bank findByName(@Param("name") String name);
```

---
* join в HQL

HQL-запрос — это такой запрос который строиться с помощью "Criteria" на уровне Service слоя.

```javascript
    Criteria criteria = session.createCriteria(My.class);
    criteria.get()
            .list()
            .load()
```

**(** [https://forum.hibernate.org/viewtopic.php?f=1&t=1009553](https://forum.hibernate.org/viewtopic.php?f=1&t=1009553) **)** [https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies](https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies)
[https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables](https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables)

```
   Вот важная вещь которую нужно знать о "join fetching":
   - fetch="join" используется только при получении данных через функции "get()" или "load()": с помощью настройки "criteria.setFetchMode('name', FetchMode.LAZY)"
   - fetch="join" использует "OUTHER JOIN" для ПУСТЫХ (nullable) "MANY-TO-ONE" FOREIGN KEY (внешних ключей) и коллекций
   - fetch="join" использует "INNER JOIN" для НЕПУСТЫХ (not-null) "MANY-TO-ONE" FOREIGN KEY (внешних ключей)

   HQL-запросы не учитывают стратегию выборки JOIN-ов определенных в mapping-документе
   Чтобы HQL-запрос мог использовать "LEFT OUTHER JOIN" - нужно явно написать его в своем запросе...
```

```javascript
    @NamedQuery(name = "query1", query = "SELECT DISTINCT o " +
        "FROM Organization o, User u " +
        "JOIN o.roles oRole " +
        "JOIN u.roles uRole " +
        "WHERE oRole.id = uRole.id AND u.id = :uId")
    public class Organization { ...
```

```
  Какие методы есть у класса Object
  ---------------------------------
   1. public final native Class getClass()
   2.             public String toString()
   3.         public native int hashCode()
   4.            public boolean equals(Object obj)
   5.   protected native Object clone() throws CloneNotSupportedException
   6.            protected void finalize() throws Throwable
   7.  public final native void wait(long timeout) throws InterruptedException
   8.         public final void wait(long timeout, int nanos) throws InterruptedException
   9.         public final void wait() throws InterruptedException
  10.  public final native void notify()
  11.  public final native void notifyAll()
```

![HotSpot JVM](untitled3.png)

![HotSpot JVM](untitled.png)

![HotSpot JVM](untitled2.png)

```
  Какие существуют области памяти в Java (HotSpot JVM)
  --------------------------------------
  Есть 3-сегмента:
  1. Stack (Стек)
  2. Heap (Куча)
  3. PermGen (Permanent Generation)
  --------------------------------------
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
            управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	        стэковая память существует лиш на короткое время для работы отдельной под-программы
	        стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	        "java.lang.StackOverflowError" (если память стэка заполнена)
	        "-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	      всякий раз когда создается объект - он хранится в куче
	      объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	      память в куче живет с самого начала до самого конца работы программы
	      "java.lang.OutOfMemoryError" (если память кучи заполнена)
    -- "Permanent Generation" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
                              изменение размера в PermGen – это дорогостоящая и трудоёмкая операция
                              Размер в PermGen можно задать 2-мя параметрами JVM:
                              -XX:PermSize (задаёт минимальный или изначальный размер)
                              -XX:MaxPermSize (задаёт максимальный размер)
	-- "Heap" (основной сегмент памяти где хранятся все ваши объекты):
	          опции JVM определить размер памяти кучи:
	          "-Xms" (минимум)
	          "-Xmx" (максимум)
	          И делится на 2-а подсегмента:
               1. Young Generation (Новая куча)
                  ---- "Eden" (молодое поколение - сюда попадают все новосозданные объекты)
                  ---- "Survivor" (сюда копируются выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
               2. Old Generation (Старая куча)
                  ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
                       Сборка муссора (Garbage Collection - `GC`)
                       --------------
                       - `stop-the-world` (этот алгоритм создаёт то что называется моментом `когда мир остановился`. Во время выполнения GC JVM переводится в состояние паузы...)
                                          суть `GC Stop` заключается в дефрагментации памяти.
                       Существует множество алгоритмов которыми может воспользоваться JVM для проведения GC:
                       - `Mark-Sweep` (Первое – обход графа и установка особого флажка на каждом из достижимых объектов; Второе – сканирование всей памяти и помещение объектов без флажка в список свободного пространства;)
                       - `Copy Collector` (позволяет осуществить все вышеперечисленное только за один проход: когда находим в графе новый объект мы сразу копируем его в другое пространство памяти...)
                       - `Mark-Sweep-Compact` (выполняет `Mark-Sweep`, затем после выполнения действия-sweep, он перемещает объект в памяти чтобы выполнить дефрагментацию и обеспечить непрерывность свободного места...)
```

```
Класс 'Stack' - работает по принципу LIFO (последним пришел - первым ушел). Элементы кладутся в стек «друг на друга», причем взять можно только верхний-элемент, который был положен в стек последним:
push(Object item) - помещает элемент на вершину стека;
pop() - извлекает из стека верхний элемент;
peek() - возвращает верхний элемент, не извлекая его из стека;
empty() - проверяет, не пуст ли стек;
```


```javascript
    /**
     * @see https://javadevblog.com/polnoe-rukovodstvo-po-java-8-stream.html
     * @see https://habrahabr.ru/company/luxoft/blog/270383
     */


    public void testStreamTerminal(){
        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Чтобы создать поток:
         * - stream // из существующего списка
         * - of     // из перечисляющих элементов
         */
        Stream.of("dd2", "aa2", "bb1", "bb3", "cc")
                .forEach(System.out::println);

        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Есть 'терминальные методы' которые ничего НЕврзвращают:
         * ifPresent, forEach
         *
         * Есть 'терминальные методы' которые возвращают:
         * - min, max, average, findFirst, findAny  // Optional
         * - sum, count                             // примитивные типы Java
         * - collect                                // List
         * - reduce                                 // Object
         */
        OptionalInt min = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .min(); // Optional
        OptionalInt max = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .max(); // Optional
        OptionalDouble average = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .average(); // Optional
        OptionalInt findFirst = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .findFirst(); // Optional
        OptionalInt findAny = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .findAny(); // Optional

        int sum = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .sum(); // int
        long count = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .count(); // long

        List<Integer> items = Stream.of(22, 2, 1, 33, 0)
                .collect(Collectors.toList()); // List

        Stream.of(22, 2, 1, 33, 0)
                .forEach(System.out::println);

        min.ifPresent(x -> System.out.println("min = " + x));
        max.ifPresent(x -> System.out.println("max = " + x));
        average.ifPresent(x -> System.out.println("average = " + x));
        findFirst.ifPresent(x -> System.out.println("findFirst = " + x));
        findAny.ifPresent(x -> System.out.println("findAny = " + x));

        System.out.println("sum = " + sum);
        System.out.println("count = " + count);

        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Stream НЕмогут быть использованы повторно (как только вызывается терминальная операция - поток закрывается)
         */
//        Stream<Integer> streamInt = Stream.of(22, 2, 1, 33, 0);
//        min = streamInt.mapToInt(Integer::valueOf).min(); // операция выполнится успешно
//        max = streamInt.mapToInt(Integer::valueOf).max(); // Вылетит Exception

        /**
         * Чтобы избежать этого, мы должны создать новую цепь для каждой терминальной операции.
         * Каждый вызов конструктора get() создает новый поток, с которым мы можем безопасно работать.
         */
        Supplier<Stream<Integer>> streamInt = () -> Stream.of(22, 2, 1, 33, 0);
        min = streamInt.get().mapToInt(Integer::valueOf)
                .min();
        max = streamInt.get().mapToInt(Integer::valueOf)
                .max();
        average = streamInt.get().mapToInt(Integer::valueOf)
                .average();
        findFirst = streamInt.get().mapToInt(Integer::valueOf)
                .findFirst();
        findAny = streamInt.get().mapToInt(Integer::valueOf)
                .findAny();
        sum = streamInt.get().mapToInt(Integer::valueOf)
                .sum();
        count = streamInt.get().mapToInt(Integer::valueOf)
                .count();
    }


    /**
     *      Терминальные (продвинутые) операции:
     *      COLLECT, reduce
     */
    public void testCollect() {
        /**
         * Превращает элементы Stream-а в List, Set, Map
         * collect // принимает 'Collector' (который состоит из 4-ех операций: поставщик, аккумулятор, объединитель, финишер)
         */
        Collector<Person, StringJoiner, String> PERSON_COOLECTOR = Collector.of(
                () -> new StringJoiner(" | "),          // (1) поставщик
                (j,p) -> j.add(p.name.toUpperCase()),   // (2) аккумулятор
                (j1,j2) -> j1.merge(j2),                // (3) объединитель
                StringJoiner::toString);                // (4) финишер
        String names = persons.stream()
                .collect(PERSON_COOLECTOR);
        System.out.println(names); // ANDREW | IGOR | IRA | VITIA

        List<Person> filtered = persons.stream()
                .collect(Collectors.toList()); // [Andrew, Igor, Ira, Vitia]
        System.out.println(filtered);

        Map<Integer, List<Person>> personsByAge = persons.stream()
                .collect(Collectors.groupingBy(p -> p.age)); // {20=[Andrew], 23=[Igor, Ira], 12=[Vitia]}
        System.out.println(personsByAge);

        Double averageAge = persons.stream()
                .collect(Collectors.averagingInt(p -> p.age)); // 19.5
        System.out.println(averageAge);

        String phrase = persons.stream()
                .filter(p -> p.age >= 18)
                .map(p -> p.name)
                .collect(Collectors.joining(" и ", "В Германии ", " совершеннолетние.")); // В Германии Andrew и Igor и Ira совершеннолетние.
        System.out.println(phrase);
    }


    /**
     *      Терминальные (продвинутые) операции:
     *      collect, REDUCE
     */
    public void testReduce() {
        /**
         * работа 'Reduce' очень схожа на 'Comparator' (он проходит по списку, берет 2-а рядом стоящих элемента и сравнивает их...)
         * Только 'Reduce' позволяет еще дополнительно выполнять другие операции и формировать ответ..
         */

        // Вариант #1:
        persons.stream()
                .reduce((p1,p2) ->      // (1) на вход принимает 2-а рядом стоящих элемента из списка
                        p1.age > p2.age // сравнивает их и формирует результат...
                                ? p1
                                : p2)
                .ifPresent(System.out::println); // Xxx

        // Вариант #2:
        Person person = persons.stream()
                .reduce(new Person(),     // (1) указываем ему какой тип результата нужно возвращать на выходе...
                        (p1,p2) -> {      // (2) на вход принимает 2-а рядом стоящих элемента из списка
                            Person p = new Person();
                            p.age += p1.age + p2.age;
                            p.name += p1.name + " " + p2.name;
                            return p; }); // и формирует результат...
        System.out.format("name = %s; \nage = %s;\n", person.name, person.age);

        // Вариант #3:
        Integer ages = persons.stream()
                .reduce(0,                    // (1) первичная иннициализация значения...
                        (sum,p) ->            // (2) указываем сам элемент и его значение какое нужно брать...
                                sum += p.age,
                        (sum1,sum2) ->        // (3) на вход принимаетзначение из 2-ух рядом стоящих элементов из списка
                                sum1 + sum2); // и формирует результат...
        System.out.println(ages); // 108
    }


    public void testStreamInterim() {
        // filter, map, mapToInt, flatMap, sorted, limit

        /**
         * Все промежуточные методы возвращают только <Stream>
         * - filter, map, mapToInt, flatMap, sorted, limit // Stream
         *
         * Некоторые промежуточные методы принимают <FunctionalInterface>
         * - filter, map, mapToInt, flatMap // <FunctionalInterface>
         */
        Stream.of("dd2", "aa2", "bb1", "bb3", "bb5", "bb2", "cc")
                .filter(s -> s.startsWith("b"))                    // принимает <FunctionalInterface>, возвращает <Stream>
                .sorted((s1,s2) -> s2.compareTo(s1))               // принимает <FunctionalInterface>, возвращает <Stream>
                .limit(3)                                          // принимает 'Long', возвращает <Stream>
                .map(s -> s.replaceAll("b", "")) // принимает <FunctionalInterface>, возвращает <Stream>
                .forEach(System.out::println);

        System.out.println();

        Stream.of(22, 2, 1, 33, 0)
                .sorted()                   // ничего НЕпринимает, возвращает <Stream>
                .mapToInt(Integer::valueOf) // принимает <FunctionalInterface>, возвращает <Stream>
                .forEach(System.out::println);
    }


    /**
     *      Промежуточные (продвинутые) операции:
     *      FLATMAP
     */
    public void testFlatMap() {
        /**
         * ('map' - преобразовывает объекты одного потока в другие объекты для другого потока...)
         * 'flatMap' - (похож на 'map', только) преобразует каждый элемент одного потока в в другие объекты для МНОГИХ других потоков...
         */
        IntStream.range(1, 4)
                .mapToObj(i -> new Foo("Foo" + i))
                .peek(f -> IntStream.range(1, 4)
                        .mapToObj(i -> new Bar("Bar" + i + " <- " + f.name))
                        .forEach(f.bars::add))
                .flatMap(f -> f.bars.stream())
                .forEach(b -> System.out.println(b.name));
    }
```


Java Concurrency (`java.util.concurrent`)
---

* [1](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L1075) **|** [2](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/concurrent)

    > Процесс — это участок программного кода который лежит в области ОЗУ.
    > Поток — это выделенное процессорное время на выполнение программного кода (этого процесса).
    > Критическая секция — когда несколько потоков пытаются одновременно получить доступ к общему рессурсу.
    > Захват монитора - когда один поток получает доступ к ресурсу а другие потоки в это время ожидают освобождения этого ресурса.

> `Runnable` — это интерфейс (с одним методом `run`) внутри которого описывается задача.

> `Thread` — это класс-сервис который запускает задачу в отдельном потоке.
             Таким потоком можно управлять с помощью методов: (`start`/`stop`/`sleep`/`interrupted`) а еще (`join`/`yield`).
> Чтобы решать проблемы с `критическими секциями`: в `Thread` есть методы для блокировки потоков: (`wait`/`notify`).
> Жизненный цикл потока: NEW, RUNNING, BLOCKING, WAITING, TERMINATE

```text
Существует 5-способов синхронизации (`synchronized`) для критических секций между потоков:
1. относительно текущего экземпляра (объекта) класса
2. относительно статического класса

3. (lock-синхронизация) относительно одного объекта

4. оператор `volitale` (позволяет полулчить прямой доступ к данным в памяти, минуя кеш-потока)
5. использование атомарных функций (get/set) 
```

I. Исполнители

> `Callable` — это задачи которые могут быть переданы исполнителям (типа `Runnable`), но (в отличие от `Runnable`) `Callable` может возвращать значение.
                `submit()` НЕждет завершения задачи и исполнитель НЕможет вернуть результат задачи напрямую
> `Future` — поэтому (вместо `Callable`) исполнитель возвращает специальный объект-Future у которого можно запросить результат задачи.
             (`isDone`/`get`) и еще (`invokeAll`/`invokeAny`)

> `ExecutorService` — (интерфейс) сервис-исполнителей (типа `Thread` но есть важное отличие: он никогда НЕостановится, поэтому его останавливать явно)
                       (`submit`/`shutdown`/`shutdownNow`/`awaitTermination`)
> `Executors` — это (класс) предоставляет фабричные методы для создания сервисов-исполнителей
```javascript
Executors.newSingleThreadExecutor(); // вернет исполнителя с пулом в 1-поток
Executors.newFixedThreadPool(10);    // вернет исполнителя с пулом в 10-потоков
Executors.newWorkStealingPool();     // вернет исполнителя с пулом потоков равным количеству ядер машины
```

II. Синхронизация и Блокировки

> `Semaphore` — (более удобен чем `wait`/`notify`) ограничивает количество потоков которые используют `критические секции` (`tryAcquire`/`release`).

> `ReentrantLock` — (типа `wait`/`notify`) реализует то же поведение что и обычные блокировки: (`lock`/`unlock`/`tryLock`).
> `ReadWriteLock` — отдельная блокировка для чтения и для записи (`readLock`/`writeLock`/`readUnlock`/`writeUnlock`).
> `StampedLock` — (похож на `ReadWriteLock`) у этого класса есть методы для `оптимистичной блокировки` (`tryOptimisticRead`/`tryConvertToWriteLock`/`validate`).
```text
Блокировка на чтения запрещает использовать блокировку на запись.

'Оптимистическая блокировка' позволяет другим потокам блокировать ресурс НЕдожидаясь окончания работы.
(После захвата ресурса оптимистическая блокировка является валидной И предыдущая оптимистическая блокировка отправляется спать - уже перестает быть валидной)
ПРОБЛЕМА В ТОМ ЧТО ПОСТОЯНО НУЖНО СЛЕДИТЬ ЗА ВАЛИДНОСТЬЮ ОПТИМИСТИЧЕСКИХ БЛОКИРОВОК.
```

III. Атомарные операции

> `AtomicInteger`, `AtomicBoolean`, `AtomicLong`, `AtomicReference` — (`get`/`incrementAndGet`/`updateAndGet`).

> `LongAdder` — (альтернатива `AtomicLong`)
> `LongAccumulator` — (расширяет `LongAdder`)


[Коллекции](https://habrahabr.ru/post/237043)
---

![Коллекции](65cd6dce50e84d659152c482e5565f3c.png)

Есть два типа коллекций, это список и хеш-карты

> 1. `Collection` — это общий интерфейс для всех коллекций-списка:
> `List` (это интерфейс для списков)
>> `Vector` — в его основе лежит массив. (+) применяется где нужна потокобезопасность; (-) из-за синхронизации работает очень медленно;
>> `ArrayList` — в его основе лежит массив-индекс. (+) быстро добавляет элеметы только в конец списка и по индексу быстро получает доступ к любому элементу; (-) медленно выполняется удаление или любое изменение связанное с размером списка;
>> `LinkedList` — в его основе лежит связи-итератор между элементами. (+) быстро добавляет элеметы в любое место списка и быстро удаляет их; (-) для поиска медленно выполняется перебор элементов;
> `Set` — такие списки НЕсодержат (отсекают) дубликаты элементов (+) исключаются избыточные элементы в списке + отсутствуют утечки в памяти; (-) НЕльзя обновлять уже существующий элемент;
> `Queue` (это интерфейс для очередей) такие списки являются двух-сторонними И позволяют сортировать элемпенты по критерию приоритетности...
>> `ArrayDeQueue` — 
>> `LinkedList` — 
>> `PriorityQueue` — 
> 2. `Map` (это интерфейс для хеш-карт)
>> `HashTable` — в его основе лежит массив списков. (+) применяется где нужна потокобезопасность; (-) из-за синхронизации работает очень медленно;
>> `HashMap` — (контракт между hashCode и equals). (+) позволяет очень быстро выполнять все операции над элементами списка! (-) плохо определенный hashCode и equals ведет к снижению в производительности и к утечке в памяти...;
>> `TreeMap` — (самосортирующие структуры 'Comparable' или 'Comparator' compare или compareTo) (+) быстрый поиск элемента за минимальное количество итераций + позволяет работать с очень большими таблицами; (-) большое время добавление нового элемента;


    Область применения коллекций:
    1. Вся информация хранится в базе данных. Обычно клиент в текущем запросе запрашивает (НЕвсю информацию из базы данных а) только какую-то часть из этого...
       Например строится запрос к базе данных где клиент хочет получить список машин конкретной марки за какой-то период ИЛИ получить машин которые вмещаются на одной странице и отсортированы по дате выпуска...
       Результатом такого запроса на выходе будет получен НЕбольшой список элементов 10-1000 элемеентов.
       Обычно такой полученный список просто отдается клиенту в слой-представления (и никаких операций с таким списком больше НЕвыполняют)
    2. Если элементы в списке очень тяжеловестные в таких случаях очень ресурсоемно-медленно выполнять какие-либо навигационные операции по такому списку...
       Например для сортировки элементов внутри списка чтобы перебрать каждый тяжеловестный элемент списка и сравнить его - это очень ресурсоемкая процедура (потому-что сам элемент очень большой)
       Для этой цели существуют Хеш-Карты (асоциативные массивы, 'Приспособленец' — внутреннее и внешнее состояние элементов) позволяют каждый тяжеловестный элемент ('value') ассоциировать с более легковестным элементом ('key')
       Поэтому Хеш-Карты удобно использовать в операциях для внутренних навигационных-вычисленний (хешировать промежуточные запросы, быстро сортировать элементы в списке...)
    3. (и списки о хеш-карты обычно хорошо применять для внутренних операций где размер таких списков НЕбольшой)
       Но когда размер списка превышает 100.000 - 1.000.000 работать с таким большим списком становится НЕудобно потому-что обычно в запросах никто не использует столько иногоинформации чтобы помнить о всех ключах и элементах
       Для поисковых систем строятся очень большие списки И чтобы быстро получить доступ к любому элементу такого списка (за минимальное количество шагов) для этого строятся специальные поисковые структуры...
       Бинарные-деревья — для построения таких Бинарные-деревьев затрачивается много времени НО такие структуры должны жить долго (удобно можно использовать в поисковых системах, для выполнения математических расчетов...построить кротчайшее расстояние...) 


Слоевая архитектура в приложении (доменный слой, DAO-слой, сервисный слой, DTO, web-слой или API)
---

###Протокол
1. Любое приложение состоит из `клиентской` и `серверной` части.
   * `серверная часть` — это та часть приложения которая работает на стороне рессурсов.
     Например: контроллер на плате устройства 'дисковода' умеет работать с секциями диска...записывать и читать данные...
   * `клиентская часть` — это та часть приложения которая работает на стороне клиента (в конкретной Опреационной Системе или на конкретном компьютере подключенного к сети).
     Например: клиентское приложение 'файлового менеджера' умеет распознавать: 'диски', 'директории', 'программы', 'документы' (а также умеет обращаться с ними: раскрывать директории, запускать программы, читать документы с помощью асоциированной программы...) 
   * и `серверная` и `клиентская` часть являются программами которые запущены и постоянно висят-работают (как сокеты...в режиме ожидания дожидаются команды)
     Каждая из этих программ ничего друг о друге НЕзнает. И чтобы научить их как-то общяться между собой — для этого и существует `протокол`
     Например `файловый протокол` описывает порядок взаимодействия между клиентом и сервером для получения информации из дискового носителя
     (можно помогает-формировать клиентские команды, ходить по директориям, смотреть содержимое, запускать программы на выполнение внутри Операционной Системы, скармливать документы на чтение..., оповещает в случае ошибки на стороне клиента или сервера)
     (`http-протокол`: порядок работы в режиме запрос-ответ, поддерживает 4~типа операций, оповещает в случае ошибки на стороне клиента или сервера, имеет: ['физический уровень', 'сетевой уровень', 'транспортный', 'прикладной уровень'](http://kunegin.com/ref6/lan/2.htm))

###API

    Прежде всего `API-слой` связан с `протоколом` и задача слоя API выплюнуть (в ответ) данные в протокол или принять данные (запрос) из протокола.
    (API-слой ничего НЕзнает кто является клиентом запросов НО `API-слой` может взаимодействовать-поддерживать только с конкретным типом `протокола`...с которым в свою очередь работает клиент)

###Сервисный слой

По сути, вся основная часть программы (ее бизнес-логика) реализована внутри этого `сервисного слой` (это центр всего приложения).
`Сервисный слой` является серверным компонентом и постоянно работает с начала запуска сервера приложения и до момента его остановки...
(Сервисный слой ничего не знает о том куда уходят данные и откуда эти данные приходят...)
Поэтому сервисному слою НЕважно кто будет получателем этих данных НО те данные которые на выходе этого сервисного слоя, могут быть и на входе этого сервисного слоя...
(За получения и доставку данных отвечают `API-слой` и `DAO-слой`. А `сервисный слой` только получает данные и обрабатывает их...)

###DAO

    Все данные которые используются во всем приложении можно разбить на: `постоянные` и `временные` данные:
    - На стороне клиента данные являются временными И изменяются с каждым переходом от одной веб-страницы на другую
    - Чтобы после выключения компьютера эти клиентские данные НЕпропали, эти данные ложаться в базу данных для постоянного хранения
    - Сервисный слой может использовать эти `постоянные данные` из базы данных чтобы избавить клиента от дополнительного заполнения форм ранее уже введенными данными
    По своему назначению `DAO-слой` является слоем который на уровень ниже сервисного слоя И предоставляет API-функции для этого сервисного слоя чтобы связать его с базой данных (источником постоянного хранения данных...)
    (Для DAO-слоя открываются пулы-соединений с базой данных... формируются И отправляются запросы на сервер базы данных А также принимает и возвращает ответ из базы данных в сервисный слой)

###Доменный-слоя и DTO-слой

При транспортировке данных из одной области в другую внутри приложения, программа оперирует конкретными типами объектов (`POJO-классы`) И структура этих объектов тоже должна где-то описываться.
`Доменный-слоя` - служит для описания структуры (`POJO-классов`) тех типов объектов которые используются внутри `Сервисного слоя`.
`DTO-слой` - служит для описания структуры (`POJO-классов`) тех типов объектов которые API выплевывает (в ответ) в протокол или принимает (запрос) в сервисный слой.



Паттерны проэктирования в архитектуре приложения
---

    Прежде всего каждый слой на фоне архитектуры всего приложения имеет свое назначение и поведение:
    - Объекты мгут менять свое поведение на стороне клиента (например заполнение полей формы... это выше API-слоя)
    - На уровне DAO-слоя можно описывать какую-либо структуру для получения данных...
    
    Для применения паттернов внутри архитектуры приложения нужно быть очень осторожным.
    Если паттерн связывает оба слоя так что изменяется исходное поведение компонента внутри слоя - в таком случае последствия приведут к ошибкам в работе программы.

* Плохой тон программирования

`Например: если паттерн 'Билдер' применить к доменному слою - такое поведение повлечет ошибки для выгрузки и иннициализации объектов из базы данных DAO-слоя`

* Хороший тон программирования

`Например: для создания пула соединения паттерн 'Синглтон' использует отдельную утилиту в сервисном слое - такое поведение поможет ограничить от создания избыточных пулов соединений внутри этого приложения`
`Для описания объекта чтобы создать соединение с сервером в момент иннициализации можно применить паттерн 'Билдер' - чтобы выделить объязательные и НЕобъязательные параметры соединения`
`(Для построения POJO-классов в DTO-слое можно применить конвертеры которые не влияют на работу POJO-классов в других слоях)`
