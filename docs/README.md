[Markdown: Help](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) **|** [Markdown support](https://daringfireball.net/projects/markdown/syntax)

[Хоткеи в IntelliJ-IDEA](https://juja.com.ua/java/ide/intellij-idea-hotkeys) ([+](http://eax.me/intellij-idea-hotkeys))


* **(** [Java.Test](Java.Test.txt) **)**
* [EJB делится на 3-типа компонентов](Java%20(авторизация-сервисы).txt#L424) **|** [полезные ответы на вопросы #1](AboutMe.txt#L871) **|** [полезные ответы на вопросы #2](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L153)  **(** [EJB](../src/com/voituk/jpaexample/EJB.md) **|** [Java.Test.1](Java.Test.txt) **|** [Java.Test.2](Java.Test2.txt) **|** [tree_node](../src/com/java/tree_algorithm/tree_node.pdf) **)**
* [Java Perfomance Test](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L2145) **(** [использование памяти процессом Java](https://www.ibm.com/developerworks/ru/library/j-codetoheap) **|** [SystemTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/SystemTest.java) **|** [ServicePerfomanceTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/cities_roads/ServicePerfomanceTest.java) **|** [CollectionsPerformance](https://github.com/JobTest/axiom/tree/develop4.1/src/test/java/example/testtask/townsandroads) **|** [String, StringBuffer and StringBuilder Memory and Runtime Analysis](http://java.globinch.com/java-quick-tips/performance-string-stringbuffer-stringbuilder-memory-runtime-analysis) **|** [Performance factors](http://www.vogella.com/tutorials/JavaPerformance/article.html) **|** [SearchPhrase_PerformanceTest](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/task/SearchPhrase_PerformanceTest.java) **|** [MSL2 (zip)](https://mail.google.com/mail/u/0/?tab=wm#inbox/15e6d13cebc81504) **|** [MockitoTest](https://github.com/JobTest/axiom/tree/develop/cities_roads/src/test/java/example/testtask) **+** [Get size of object in memory](http://www.javapractices.com/topic/TopicAction.do?Id=83) **+** [Memory consumption of popular Java data types – part 2](http://java-performance.info/memory-consumption-of-java-data-types-2) **)**
* [Scala Perfomance Test](http://scalameter.github.io/home/gettingstarted/0.5/configuration/index.html)
* [Коллекции](Коллекции.md) **|** [Collections Framework](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/README.md) **|** [Stack](firefox.txt#L593) **(** [Stack: push/pop/peek](../src/com/voituk/jpaexample/JMS.md#L386) **|** [Java Коллекции](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/prepare)  **|** [пример реализации кэша через LinkedHashMap](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/LRUCacheTest.java) **|** [вставка и обход бинарного дерева в глубину и в ширину](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/TreeTest.java) **|** [Tree Algorithm](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/tree_algorithm/TreeTest.java) **)**
* [Дженерики](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/generic/README.md) **|** [Optional](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/README.md) **|** [Executor](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/concurrent/README.md) **|** [SQL HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/README.md) **|** [SOAP](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/SOAP/README.md)
* [Базы данных](Базы%20данных.md) **(** [JPA и Hibernate в вопросах и ответах](https://habrahabr.ru/post/265061) **|** [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **|** [HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/sql/README.md) **)**
* [PL/SQL](PL-SQL.md)
* [Design Patterns](Design%20Patterns.md)
* [Исключения в Java](Исключения%20в%20Java.md) **(** [TryCatchFinaly](https://github.com/Home-Spring/SpringFileUpload2/blob/master/src/test/java/com/journaldev/spring/TryCatchFinaly.java) **|** [pdf](Исключения%20и%20ошибки.pdf) **)**
* [что нового в java-8](что%20нового%20в%20java-8.md)  **|** [Java8.2](https://github.com/Home-Java8/Java8.2)  **(** [Краткий список нововведений в Java 8](http://microfork.com/whats-new-in-java-8/) **)**
* **(** [10-советов по многопоточному программированию на Java](https://tproger.ru/translations/10-java-multithread-practices) **)**
* [различие между oauth-1 и oauth-2](различие%20между%20oauth-1%20и%20oauth-2.md)
* [Аспектно-Ориентированном Программирование](АОП.md) **(** [Знакомство с АОП](https://habrahabr.ru/post/114649) **|** [Spring АОП](http://www.finecosoft.ru/spring-aop) **)**
* [introduction](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/spring_mvc/introduction.md) **(** [Home-Spring/docs](https://github.com/Home-Spring/docs) **|** spring управлять бинами на лету через xml: [1](https://habrahabr.ru/company/haulmont/blog/248981) **|** [2](https://habrahabr.ru/post/106744) **|** [3](http://java-course.ru/student/book2/spring) **|** [4](http://spring-projects.ru/guides/lessons/lesson-2) **|** [5](https://habrahabr.ru/post/228953) **|** [MVC](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/spring_mvc) **)**
* **(** [сессия](https://github.com/JobTest/axiom/blob/develop4.1/src/main/java/example/testtask/java8/meeting2/java%20developer%20kiev.txt) **)**
* [Аббревиатура SOLID](https://web-creator.ru/articles/solid) **(** `эти принципы позволяют строить на базе ООП масштабируемые ПО с понятной бизнеслогикой` **)**

    1. Принцип единственной обязанности (Single responsibility) `обозначает что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.`
    2. Принцип открытости / закрытости (Open-closed) `декларирует что классы, модули, функции должны быть открыты для расширения, но закрыты для изменения (это означает что эти сущности могут менять свое поведение без изменения их исходного кода).`
    3. Принцип разделения интерфейса (Interface segregation) `гово­рит о том, что слишком толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах которые необходимы им в работе (в итоге при изменении метода-интерфейса не должны меняться клиенты которые этот метод не используют).`
    4. Принцип инверсии зависимостей (Dependency inversion) `модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа моду­лей должны зависеть от абстракций.`
    5. Принцип подстановки Барбары Лисков (Liskov substitution) `функ­ции которые используют базовый тип должны иметь возможность использовать подтипы базового типа не зная об этом.`

![Аббревиатура SOLID](5e55695664a7484684759f990e20dbdf.png)

     При обычной рекурсии - в теле функции остается лежать текущее значение переменной.
     И каждый раз когда функция вызывает саму-себя - клонируется тело этой функции, но уже с другим значением переменной.
     И таких клонов может быть безконечное количество - именно это услоие (наличие безконечного количества клонов) и приводит к переполнение стэка.

```javascript
    static int func(int n){
        if(n==0) return 0;
        return n + func(n-1); //return n+func(--n); //return n+func(n--);
    }
```


     В хвостовой рекурсии - в теле функции никакие переменные вообще не храняться!
     Все значения для переменных передаются только в параметрах функции.
     В теле самой-же функции лежит только оператор-возврата значения. А все значения вычисляются на уровне, в момент передачи параметров.
     То есть, каждый раз когда функция вызывает саму-себя старое тело функции уничтожается! И поэтому клон функции будет всегда один (это значит что переполнения стэка никогда не наступит)

```javascript
    static int add(int nun, int step){
        if(step==0) return nun; //return 1;
        return add((nun+(step-1)), step-1);
    }
```


     Функции высшего порядка - это функция которая принимает в качестве аргументов другие функции или возвращает в качестве результата другую функцию.
     ( Идея состоит в том что функции имеют такой-же статус как и другие объекты данных.
       Использование функций высшего порядка приводит к абстрактным и компактным программам... )

```javascript
    Function<Integer, Integer> f = x -> x + 3;
    BiFunction<Function<Integer, Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
    System.out.println(g.apply(f, 7));
```


     Каррирование - это преобразование функции со многими аргументами в набор функций каждая из которых имеет по одному аргументу.

     Замыкание - ( является глобальной переменной ) это когда в теле функции присутствуют ссылки на переменные которые объявленные вне тела этой функции.



---
1. Есть обычные интерфесы (которые имплементируются в классах);
2. Есть интерфейсы с дефолтными методами ('default' - которое определяют дефолтную реализацию методов еще на уровне интерфейса);
3. Есть функциональные интерфейсы (это интерфейсы только с одним методом);

.

    Так вот, лямбда-выражение - это отложенное определение тела функции на потом (с помощью функциональных интерфейсов...).
    Удобным способом использования их является тот факт, что можно опускать круглые и фигурные дужки (с помощью которых описывается синтаксис для параметра и тела функции...).
    Кроме этого, реализовывать определение тела функции можно и в отдельнм классе (при условии что поля этого класса будут идентичны функционвльному интерфейсу)

```javascript
    interface MyFace2 {
        void hello(String val);
    }

    MyFace2 face2 = val -> { System.out.println(val); };
    face2.hello("Hello!");
```

```javascript
    static class MyClazz3 {
        public static void hello(String val) {
            System.out.println(val);
        }
    }

    MyFace3 face3 = MyClazz3::hello;
    face3.hello("Hello!");
```


---
* ( Java-8 )

'map()' - преобразует данные из одного типа в другой.
          Например, есть 'Publisher' (издатель) и есть много подписчиков 'Subscribe'. Так вот: 'map' делает легкое связывание между двумя этими источниками И
                    позволяет передать данные от одного типа источника 'Publisher' для (других типов источников) всех его зависимых слушателей 'Subscribe'.

     'map()' - может преобразовывать каждый элемент стрима И возвращает только одно значение (а именно - коллекцию).
     'flatMap()' - может преобразовывать каждый элемент стрима НО возвращает поток значений (стрим).


---
* Классы

```javascript
    /**
     * A static{}
     * B static{}
     * A {}
     * B.func=null
     * B {}
     */

    /*
     * #1. первым делом, в классе, будут вызваны статические блоки И в базовом классе и потом в классе наследнике.
     *     (для всех бдлклв правило 'полиморфизма' не действует!)
     */

    /*
     * #2. Полиморфизм - это правило переопределение функции по умолчанию в классах наследниках действует только на функции класса.
     *     Те функции которые переопределенные в классе наследнике по умолчанию применяются для всех базовых классов.
     */

    /*
     * #3. дальше, в классе, будут вызваны обычные блоки И в базовом классе и потом в классе наследнике.
     */

    /*
     * #4. только потом, в классе, будут вызваны конструкторы И в базовом классе и потом в классе наследнике.
     *     Конструкторы это такие себе именнованные блоки, которые ведут себя как обычные блоки, но при этом служат для иннициализации класса в момент его создания.
     */
```


---
* Способы сравнения объектов

```javascript
/**
 *
 * 18. Что такое пул строк?
 * ***********************
 ** Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка,
 *  иначе создается новая строка в пуле, а затем возвращается ссылка.
 ** Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того,
 *  чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.
 *
 * пул строк – это набор строк, который хранится в памяти Java heap.
 * Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
 * Пул строк также является примером паттерна Приспособленец (Flyweight).
 * Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.
 *
 * 19. Что делает метод intern()?
 * *****************************
 * Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка
 * на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.
 * Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
 *
 */
```


---
* Concurrent Collections

```javascript
/**
 *
 * CopyOnWrite коллекции:
 * - CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList
 * - CopyOnWriteArraySet<E> — Имплементация интерфейса Set
 * Улучшенные реализации HashMap, TreeMap с лучшей поддержкой многопоточности и масштабируемости:
 * - ConcurrentMap<K, V> — Интерфейс, расширяющий Map
 * - ConcurrentHashMap<K, V> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей
 * - ConcurrentNavigableMap<K,V> — Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений
 * - ConcurrentSkipListMap<K, V> — Является аналогом TreeMap с поддержкой многопоточности
 * - ConcurrentSkipListSet<E> — Имплементация Set интерфейса
 *
 * - ConcurrentLinkedQueue — синхронно добавляет / удаляет элементы (использует алгоритм для быстрой переборки элементов)
 * - ConcurrentLinkedDequeue — (такой же как и 'ConcurrentLinkedQueue') работает в двух-стороннем порядке FIFO
 */
```


---
* join в HQL

HQL-запрос — это такой запрос который строиться с помощью "Criteria" на уровне самого приложения.

```javascript
    Criteria criteria = session.createCriteria(My.class);
    criteria.get()
            .list()
            .load()
```

**(** [https://forum.hibernate.org/viewtopic.php?f=1&t=1009553](https://forum.hibernate.org/viewtopic.php?f=1&t=1009553) **)** [https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies](https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies)
[https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables](https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables)

```
   Вот важная вещь которую нужно знать о "join fetching":
   - fetch="join" используется только при получении данных через функции "get()" или "load()": с помощью настройки "criteria.setFetchMode('name', FetchMode.LAZY)"
   - fetch="join" использует "OUTHER JOIN" для ПУСТЫХ (nullable) "MANY-TO-ONE" FOREIGN KEY (внешних ключей) и коллекций
   - fetch="join" использует "INNER JOIN" для НЕПУСТЫХ (not-null) "MANY-TO-ONE" FOREIGN KEY (внешних ключей)

   HQL-запросы не учитывают стратегию выборки JOIN-ов определенных в mapping-документе
   Чтобы HQL-запрос мог использовать "LEFT OUTHER JOIN" - нужно явно написать его в своем запросе...
```

```javascript
    @NamedQuery(name = "query1", query = "SELECT DISTINCT o " +
        "FROM Organization o, User u " +
        "JOIN o.roles oRole " +
        "JOIN u.roles uRole " +
        "WHERE oRole.id = uRole.id AND u.id = :uId")
    public class Organization { ...
```

```
  Какие методы есть у класса Object
  ---------------------------------
   1. public final native Class getClass()
   2.             public String toString()
   3.         public native int hashCode()
   4.            public boolean equals(Object obj)
   5.   protected native Object clone() throws CloneNotSupportedException
   6.            protected void finalize() throws Throwable
   7.  public final native void wait(long timeout) throws InterruptedException
   8.         public final void wait(long timeout, int nanos) throws InterruptedException
   9.         public final void wait() throws InterruptedException
  10.  public final native void notify()
  11.  public final native void notifyAll()
```

![HotSpot JVM](untitled3.png)

![HotSpot JVM](untitled.png)

![HotSpot JVM](untitled2.png)

```
  Какие существуют области памяти в Java (HotSpot JVM)
  --------------------------------------
  Есть 3-сегмента:
  1. Stack (Стек)
  2. Heap (Куча)
  3. PermGen (Permanent Generation)
  --------------------------------------
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
            управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	        стэковая память существует лиш на короткое время для работы отдельной под-программы
	        стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	        "java.lang.StackOverflowError" (если память стэка заполнена)
	        "-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	      всякий раз когда создается объект - он хранится в куче
	      объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	      память в куче живет с самого начала до самого конца работы программы
	      "java.lang.OutOfMemoryError" (если память кучи заполнена)
    -- "Permanent Generation" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
                              изменение размера в PermGen – это дорогостоящая и трудоёмкая операция
                              Размер в PermGen можно задать 2-мя параметрами JVM:
                              -XX:PermSize (задаёт минимальный или изначальный размер)
                              -XX:MaxPermSize (задаёт максимальный размер)
	-- "Heap" (основной сегмент памяти где хранятся все ваши объекты):
	          опции JVM определить размер памяти кучи:
	          "-Xms" (минимум)
	          "-Xmx" (максимум)
	          И делится на 2-а подсегмента:
               1. Young Generation (Новая куча)
                  ---- "Eden" (молодое поколение - сюда попадают все новосозданные объекты)
                  ---- "Survivor" (сюда копируются выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
               2. Old Generation (Старая куча)
                  ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
                       Сборка муссора (Garbage Collection - `GC`)
                       --------------
                       - `stop-the-world` (этот алгоритм создаёт то что называется моментом `когда мир остановился`. Во время выполнения GC JVM переводится в состояние паузы...)
                                          суть `GC Stop` заключается в дефрагментации памяти.
                       Существует множество алгоритмов которыми может воспользоваться JVM для проведения GC:
                       - `Mark-Sweep` (Первое – обход графа и установка особого флажка на каждом из достижимых объектов; Второе – сканирование всей памяти и помещение объектов без флажка в список свободного пространства;)
                       - `Copy Collector` (позволяет осуществить все вышеперечисленное только за один проход: когда находим в графе новый объект мы сразу копируем его в другое пространство памяти...)
                       - `Mark-Sweep-Compact` (выполняет `Mark-Sweep`, затем после выполнения действия-sweep, он перемещает объект в памяти чтобы выполнить дефрагментацию и обеспечить непрерывность свободного места...)
```

```
Класс 'Stack' - работает по принципу LIFO (последним пришел - первым ушел). Элементы кладутся в стек «друг на друга», причем взять можно только верхний-элемент, который был положен в стек последним:
push(Object item) - помещает элемент на вершину стека;
pop() - извлекает из стека верхний элемент;
peek() - возвращает верхний элемент, не извлекая его из стека;
empty() - проверяет, не пуст ли стек;
```