[Markdown: Help](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) **|** [Markdown support](https://daringfireball.net/projects/markdown/syntax)

[Хоткеи в IntelliJ-IDEA](https://juja.com.ua/java/ide/intellij-idea-hotkeys) ([+](http://eax.me/intellij-idea-hotkeys))


* **(** [Java.Test](Java.Test.txt) **)**
* [EJB делится на 3-типа компонентов](Java%20(%D0%B0%D0%B2%D1%82%D0%BE%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B).txt#L415) **|** [полезные ответы на вопросы](AboutMe.txt#L871)  **(** [EJB](../src/com/voituk/jpaexample/EJB.md) **)**
* [Java Perfomance Test](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L2145) **(** [использование памяти процессом Java](https://www.ibm.com/developerworks/ru/library/j-codetoheap) **|** [SystemTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/SystemTest.java) **|** [ServicePerfomanceTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/cities_roads/ServicePerfomanceTest.java) **|** [CollectionsPerformance](https://github.com/JobTest/axiom/tree/develop4.1/src/test/java/example/testtask/townsandroads) **|** [String, StringBuffer and StringBuilder Memory and Runtime Analysis](http://java.globinch.com/java-quick-tips/performance-string-stringbuffer-stringbuilder-memory-runtime-analysis) **|** [Performance factors](http://www.vogella.com/tutorials/JavaPerformance/article.html) **|** [SearchPhrase_PerformanceTest](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/task/SearchPhrase_PerformanceTest.java) **|** [MSL2 (zip)](https://mail.google.com/mail/u/0/?tab=wm#inbox/15e6d13cebc81504) **|** [MockitoTest](https://github.com/JobTest/axiom/tree/develop/cities_roads/src/test/java/example/testtask) **+** [Get size of object in memory](http://www.javapractices.com/topic/TopicAction.do?Id=83) **+** [Memory consumption of popular Java data types – part 2](http://java-performance.info/memory-consumption-of-java-data-types-2) **)**
* [Scala Perfomance Test](http://scalameter.github.io/home/gettingstarted/0.5/configuration/index.html)
* [Коллекции](Коллекции.md) **(** [Java Коллекции](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/prepare)  **|** [пример реализации кэша через LinkedHashMap](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/LRUCacheTest.java) **|** [вставка и обход бинарного дерева в глубину и в ширину](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/TreeTest.java) **|** [Tree Algorithm](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/tree_algorithm/TreeTest.java) **)**
* [Дженерики](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/generic/README.md) **|** [Optional](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/README.md) **|** [Executor](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/concurrent/README.md) **|** [SQL HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/README.md) **|** [SOAP](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/SOAP/README.md)
* [Базы данных](Базы%20данных.md) **(** [JPA и Hibernate в вопросах и ответах](https://habrahabr.ru/post/265061) **|** [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **|** [HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/sql/README.md) **)**
* [PL/SQL](PL-SQL.md)
* [Design Patterns](Design%20Patterns.md)
* [Исключения в Java](Исключения%20в%20Java.md) **(** [TryCatchFinaly](https://github.com/Home-Spring/SpringFileUpload2/blob/master/src/test/java/com/journaldev/spring/TryCatchFinaly.java) **)**
* [что нового в java-8](что%20нового%20в%20java-8.md)  **|** [Java8.2](https://github.com/Home-Java8/Java8.2)  **(** [Краткий список нововведений в Java 8](http://microfork.com/whats-new-in-java-8/) **)**
* [различие между oauth-1 и oauth-2](различие%20между%20oauth-1%20и%20oauth-2.md)
* [Аспектно-Ориентированном Программирование](АОП.md) **(** [Знакомство с АОП](https://habrahabr.ru/post/114649) **|** [Spring АОП](http://www.finecosoft.ru/spring-aop) **)**
* **(** [Home-Spring/docs](https://github.com/Home-Spring/docs) **|** spring управлять бинами на лету через xml: [1](https://habrahabr.ru/company/haulmont/blog/248981) **|** [2](https://habrahabr.ru/post/106744) **|** [3](http://java-course.ru/student/book2/spring) **|** [4](http://spring-projects.ru/guides/lessons/lesson-2) **|** [5](https://habrahabr.ru/post/228953) **|** [MVC](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/spring_mvc) **)**
* **(** [сессия](https://github.com/JobTest/axiom/blob/develop4.1/src/main/java/example/testtask/java8/meeting2/java%20developer%20kiev.txt) **)**
* [Аббревиатура SOLID](https://web-creator.ru/articles/solid) **(** `эти принципы позволяют строить на базе ООП масштабируемые ПО с понятной бизнеслогикой` **)**

    1. Принцип единственной обязанности (Single responsibility) `обозначает что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.`
    2. Принцип открытости / закрытости (Open-closed) `декларирует что классы, модули, функции должны быть открыты для расширения, но закрыты для изменения (это означает что эти сущности могут менять свое поведение без изменения их исходного кода).`
    3. Принцип разделения интерфейса (Interface segregation) `гово­рит о том, что слишком толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах которые необходимы им в работе (в итоге при изменении метода-интерфейса не должны меняться клиенты которые этот метод не используют).`
    4. Принцип инверсии зависимостей (Dependency inversion) `модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа моду­лей должны зависеть от абстракций.`
    5. Принцип подстановки Барбары Лисков (Liskov substitution) `функ­ции которые используют базовый тип должны иметь возможность использовать подтипы базового типа не зная об этом.`

![Аббревиатура SOLID](5e55695664a7484684759f990e20dbdf.png)

     При обычной рекурсии - в теле функции остается лежать текущее значение переменной.
     И каждый раз когда функция вызывает саму-себя - клонируется тело этой функции, но уже с другим значением переменной.
     И таких клонов может быть безконечное количество - именно это услоие (наличие безконечного количества клонов) и приводит к переполнение стэка.

```javascript
    static int func(int n){
        if(n==0) return 0;
        return n + func(n-1); //return n+func(--n); //return n+func(n--);
    }
```


     В хвостовой рекурсии - в теле функции никакие переменные вообще не храняться!
     Все значения для переменных передаются только в параметрах функции.
     В теле самой-же функции лежит только оператор-возврата значения. А все значения вычисляются на уровне, в момент передачи параметров.
     То есть, каждый раз когда функция вызывает саму-себя старое тело функции уничтожается! И поэтому клон функции будет всегда один (это значит что переполнения стэка никогда не наступит)

```javascript
    static int add(int nun, int step){
        if(step==0) return nun; //return 1;
        return add((nun+(step-1)), step-1);
    }
```


     Функции высшего порядка - это функция которая принимает в качестве аргументов другие функции или возвращает в качестве результата другую функцию.
     ( Идея состоит в том что функции имеют такой-же статус как и другие объекты данных.
       Использование функций высшего порядка приводит к абстрактным и компактным программам... )

```javascript
    Function<Integer, Integer> f = x -> x + 3;
    BiFunction<Function<Integer, Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
    System.out.println(g.apply(f, 7));
```


     Каррирование - это преобразование функции со многими аргументами в набор функций каждая из которых имеет по одному аргументу.

     Замыкание - ( является глобальной переменной ) это когда в теле функции присутствуют ссылки на переменные которые объявленные вне тела этой функции.



---
1. Есть обычные интерфесы (которые имплементируются в классах);
2. Есть интерфейсы с дефолтными методами ('default' - которое определяют дефолтную реализацию методов еще на уровне интерфейса);
3. Есть функциональные интерфейсы (это интерфейсы только с одним методом);

.

    Так вот, лямбда-выражение - это отложенное определение тела функции на потом (с помощью функциональных интерфейсов...).
    Удобным способом использования их является тот факт, что можно опускать круглые и фигурные дужки (с помощью которых описывается синтаксис для параметра и тела функции...).
    Кроме этого, реализовывать определение тела функции можно и в отдельнм классе (при условии что поля этого класса будут идентичны функционвльному интерфейсу)

```javascript
    interface MyFace2 {
        void hello(String val);
    }

    MyFace2 face2 = val -> { System.out.println(val); };
    face2.hello("Hello!");
```

```javascript
    static class MyClazz3 {
        public static void hello(String val) {
            System.out.println(val);
        }
    }

    MyFace3 face3 = MyClazz3::hello;
    face3.hello("Hello!");
```


---
* ( Java-8 )

'map()' - преобразует данные из одного типа в другой.
          Например, есть 'Publisher' (издатель) и есть много подписчиков 'Subscribe'. Так вот: 'map' делает легкое связывание между двумя этими источниками И
                    позволяет передать данные от одного типа источника 'Publisher' для (других типов источников) всех его зависимых слушателей 'Subscribe'.

     'map()' - может преобразовывать каждый элемент стрима И возвращает только одно значение (а именно - коллекцию).
     'flatMap()' - может преобразовывать каждый элемент стрима НО возвращает поток значений (стрим).


---
* Классы

```javascript
    /**
     * A static{}
     * B static{}
     * A {}
     * B.func=null
     * B {}
     */

    /*
     * #1. первым делом, в классе, будут вызваны статические блоки И в базовом классе и потом в классе наследнике.
     *     (для всех бдлклв правило 'полиморфизма' не действует!)
     */

    /*
     * #2. Полиморфизм - это правило переопределение функции по умолчанию в классах наследниках действует только на функции класса.
     *     Те функции которые переопределенные в классе наследнике по умолчанию применяются для всех базовых классов.
     */

    /*
     * #3. дальше, в классе, будут вызваны обычные блоки И в базовом классе и потом в классе наследнике.
     */

    /*
     * #4. только потом, в классе, будут вызваны конструкторы И в базовом классе и потом в классе наследнике.
     *     Конструкторы это такие себе именнованные блоки, которые ведут себя как обычные блоки, но при этом служат для иннициализации класса в момент его создания.
     */
```


---
* Способы сравнения объектов

```javascript
/**
 *
 * 18. Что такое пул строк?
 * ***********************
 ** Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка,
 *  иначе создается новая строка в пуле, а затем возвращается ссылка.
 ** Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того,
 *  чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.
 *
 * пул строк – это набор строк, который хранится в памяти Java heap.
 * Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
 * Пул строк также является примером паттерна Приспособленец (Flyweight).
 * Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.
 *
 * 19. Что делает метод intern()?
 * *****************************
 * Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка
 * на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.
 * Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
 *
 */
```


---
* Concurrent Collections

```javascript
/**
 *
 * CopyOnWrite коллекции:
 * - CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList
 * - CopyOnWriteArraySet<E> — Имплементация интерфейса Set
 * Улучшенные реализации HashMap, TreeMap с лучшей поддержкой многопоточности и масштабируемости:
 * - ConcurrentMap<K, V> — Интерфейс, расширяющий Map
 * - ConcurrentHashMap<K, V> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей
 * - ConcurrentNavigableMap<K,V> — Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений
 * - ConcurrentSkipListMap<K, V> — Является аналогом TreeMap с поддержкой многопоточности
 * - ConcurrentSkipListSet<E> — Имплементация Set интерфейса
 *
 * - ConcurrentLinkedQueue — синхронно добавляет / удаляет элементы (использует алгоритм для быстрой переборки элементов)
 * - ConcurrentLinkedDequeue — (такой же как и 'ConcurrentLinkedQueue') работает в двух-стороннем порядке FIFO
 */
```


---
* join в HQL

HQL-запрос — это такой запрос который строиться с помощью "Criteria" на уровне самого приложения.

```javascript
    Criteria criteria = session.createCriteria(My.class);
    criteria.get()
            .list()
            .load()
```

**(** [https://forum.hibernate.org/viewtopic.php?f=1&t=1009553](https://forum.hibernate.org/viewtopic.php?f=1&t=1009553) **)** [https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies](https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies)
[https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables](https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables)

```
   Вот важная вещь которую нужно знать о "join fetching":
   - fetch="join" используется только при получении данных через функции "get()" или "load()": с помощью настройки "criteria.setFetchMode('name', FetchMode.LAZY)"
   - fetch="join" использует "OUTHER JOIN" для ПУСТЫХ (nullable) "MANY-TO-ONE" FOREIGN KEY (внешних ключей) и коллекций
   - fetch="join" использует "INNER JOIN" для НЕПУСТЫХ (not-null) "MANY-TO-ONE" FOREIGN KEY (внешних ключей)

   HQL-запросы не учитывают стратегию выборки JOIN-ов определенных в mapping-документе
   Чтобы HQL-запрос мог использовать "LEFT OUTHER JOIN" - нужно явно написать его в своем запросе...
```

```javascript
    @NamedQuery(name = "query1", query = "SELECT DISTINCT o " +
        "FROM Organization o, User u " +
        "JOIN o.roles oRole " +
        "JOIN u.roles uRole " +
        "WHERE oRole.id = uRole.id AND u.id = :uId")
    public class Organization { ...
```



