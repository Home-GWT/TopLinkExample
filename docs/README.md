[Markdown: Help](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) **|** [Markdown support](https://daringfireball.net/projects/markdown/syntax)

[Хоткеи в IntelliJ-IDEA](https://juja.com.ua/java/ide/intellij-idea-hotkeys) ([+](http://eax.me/intellij-idea-hotkeys))


* **(** [Java.Test](Java.Test.txt) **)**
* **(** [Новая Java & Spring - вопросы с подвохом](java_spring-trick_question.md) **)**
* [EJB делится на 3-типа компонентов](Java%20(авторизация-сервисы).txt#L424) **|** [полезные ответы на вопросы #1](AboutMe.txt#L871) **|** [полезные ответы на вопросы #2](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L153)  **(** [EJB](../src/com/voituk/jpaexample/EJB.md) **|** [Java.Test.1](Java.Test.txt) **|** [Java.Test.2](Java.Test2.txt) **|** [tree_node](../src/com/java/tree_algorithm/tree_node.pdf) **)**
* [Security](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/EJB.md#L301) **|** [различие между oauth-1 и oauth-2](различие%20между%20oauth-1%20и%20oauth-2.md) **|** [MY-SECURITY](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/MY-SECURITY.md) **(** [Жизненный цыкл Spring-а](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/Spring.md#L412) **)**
* [Java Perfomance Test](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L2145) **(** [использование памяти процессом Java](https://www.ibm.com/developerworks/ru/library/j-codetoheap) **|** [SystemTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/SystemTest.java) **|** [ServicePerfomanceTest](https://github.com/JobTest/axiom/blob/release/src/test/java/example/testtask/cities_roads/ServicePerfomanceTest.java) **|** [CollectionsPerformance](https://github.com/JobTest/axiom/tree/develop4.1/src/test/java/example/testtask/townsandroads) **|** [String, StringBuffer and StringBuilder Memory and Runtime Analysis](http://java.globinch.com/java-quick-tips/performance-string-stringbuffer-stringbuilder-memory-runtime-analysis) **|** [Performance factors](http://www.vogella.com/tutorials/JavaPerformance/article.html) **|** [SearchPhrase_PerformanceTest](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/task/SearchPhrase_PerformanceTest.java) **|** [MSL2 (zip)](https://mail.google.com/mail/u/0/?tab=wm#inbox/15e6d13cebc81504) **|** [MockitoTest](https://github.com/JobTest/axiom/tree/develop/cities_roads/src/test/java/example/testtask) **+** [Get size of object in memory](http://www.javapractices.com/topic/TopicAction.do?Id=83) **+** [Memory consumption of popular Java data types – part 2](http://java-performance.info/memory-consumption-of-java-data-types-2) **)**
* [Scala Perfomance Test](http://scalameter.github.io/home/gettingstarted/0.5/configuration/index.html)
* [Коллекции](Коллекции.md) **|** [Сложности алгоритмов](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/README.md) **|** [Stack](firefox.txt#L593) **(** [Stack: push/pop/peek](../src/com/voituk/jpaexample/JMS.md#L386) **|** [Java Коллекции](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/prepare)  **|** [пример реализации кэша через LinkedHashMap](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/LRUCacheTest.java) **|** [вставка и обход бинарного дерева в глубину и в ширину](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/TreeTest.java) **|** [Tree Algorithm](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/java/tree_algorithm/TreeTest.java) **)**
* **[Многопоточность](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/multithreading/README.md)** **|** [Java 8 CompletableFuture](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/thread/README.md) **(** [CompletableFuture](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/thread/CompletableFutureTest.java) **)**
* [Arrays / Collections.sort](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/sort/FruitTest.java) **|** [Comparable / Comparator](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/prepare/sort/Fruit.java) 
* [Дженерики](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/generic/README.md) **|** [Optional](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/README.md) **|** [Executor](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/concurrent/README.md) **|** [SQL HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/README.md) **|** [SOAP](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/SOAP/README.md)
* [Базы данных](Базы%20данных.md) **|** Индексы [1](http://www.quizful.net/interview/sql/clustered-index) **,** [2](https://habrahabr.ru/post/141767) **|** [MongoDB](mongodb.md) **(** [JPA и Hibernate в вопросах и ответах](https://habrahabr.ru/post/265061) **|** [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **|** [HAVING](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/sql/README.md) **)** [MongoDB](https://github.com/Home-GWT/TopLinkExample/blob/master/docs/AboutMe.txt#L1411)
* [PL/SQL](PL-SQL.md) **(** [Test1](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/sql/Test1.sql#L46) **)**
* [Design Patterns](Design%20Patterns.md)
* [Исключения в Java](Исключения%20в%20Java.md) **(** [TryCatchFinaly](https://github.com/Home-Spring/SpringFileUpload2/blob/master/src/test/java/com/journaldev/spring/TryCatchFinaly.java) **|** [pdf](Исключения%20и%20ошибки.pdf) **)**
* [что нового в java-8](что%20нового%20в%20java-8.md)  **|** [Java8.2](https://github.com/Home-Java8/Java8.2)  **(** [Stream](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java8/Java8Test2.java) **|** [Краткий список нововведений в Java 8](http://microfork.com/whats-new-in-java-8/) **)**
* **(** [10-советов по многопоточному программированию на Java](https://tproger.ru/translations/10-java-multithread-practices) **)**
* [Аспектно-Ориентированном Программирование](АОП.md) **(** [Знакомство с АОП](https://habrahabr.ru/post/114649) **|** [Spring АОП](http://www.finecosoft.ru/spring-aop) **)**
* [introduction](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/spring_mvc/introduction.md) **(** [Home-Spring/docs](https://github.com/Home-Spring/docs) **|** spring управлять бинами на лету через xml: [1](https://habrahabr.ru/company/haulmont/blog/248981) **|** [2](https://habrahabr.ru/post/106744) **|** [3](http://java-course.ru/student/book2/spring) **|** [4](http://spring-projects.ru/guides/lessons/lesson-2) **|** [5](https://habrahabr.ru/post/228953) **|** [MVC](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/spring_mvc) **)**
* **(** [сессия](https://github.com/JobTest/axiom/blob/develop4.1/src/main/java/example/testtask/java8/meeting2/java%20developer%20kiev.txt) **)**
* [Аббревиатура SOLID](https://web-creator.ru/articles/solid) **(** `эти принципы позволяют строить на базе ООП масштабируемые ПО с понятной бизнеслогикой` **)**
* [Установка JHipster](https://jhipster.ru/installation) **|** [heroku_tutorial_final](heroku_tutorial_final.pdf) **(** [InstallationOfJhipsterInUbuntu16](https://gist.github.com/SpiralOutDotEu/370cd1ea588827bad9254d95139f167e) **|** [heroku_tutorial_final](https://espai.stucom.com/tecnologia/wp-content/uploads/sites/2/heroku_tutorial_final.pdf) **)**


    1. Принцип единственной обязанности (Single responsibility) `обозначает что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.`
    2. Принцип открытости / закрытости (Open-closed) `декларирует что классы, модули, функции должны быть открыты для расширения, но закрыты для изменения (это означает что эти сущности могут менять свое поведение без изменения их исходного кода).`
    3. Принцип разделения интерфейса (Interface segregation) `гово­рит о том, что слишком толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах которые необходимы им в работе (в итоге при изменении метода-интерфейса не должны меняться клиенты которые этот метод не используют).`
    4. Принцип инверсии зависимостей (Dependency inversion) `модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа моду­лей должны зависеть от абстракций.`
    5. Принцип подстановки Барбары Лисков (Liskov substitution) `функ­ции которые используют базовый тип должны иметь возможность использовать подтипы базового типа не зная об этом.`

![Аббревиатура SOLID](5e55695664a7484684759f990e20dbdf.png)

     При обычной рекурсии - в теле функции остается лежать текущее значение переменной.
     И каждый раз когда функция вызывает саму-себя - клонируется тело этой функции, но уже с другим значением переменной.
     И таких клонов может быть безконечное количество - именно это услоие (наличие безконечного количества клонов) и приводит к переполнение стэка.

```javascript
    static int func(int n){
        if(n==0) return 0;
        return n + func(n-1); //return n+func(--n); //return n+func(n--);
    }
```


     В хвостовой рекурсии - в теле функции никакие переменные вообще не храняться!
     Все значения для переменных передаются только в параметрах функции.
     В теле самой-же функции лежит только оператор-возврата значения. А все значения вычисляются на уровне, в момент передачи параметров.
     То есть, каждый раз когда функция вызывает саму-себя старое тело функции уничтожается! И поэтому клон функции будет всегда один (это значит что переполнения стэка никогда не наступит)

```javascript
    static int add(int nun, int step){
        if(step==0) return nun; //return 1;
        return add((nun+(step-1)), step-1);
    }
```


     Функции высшего порядка - это функция которая принимает в качестве аргументов другие функции или возвращает в качестве результата другую функцию.
     ( Идея состоит в том что функции имеют такой-же статус как и другие объекты данных.
       Использование функций высшего порядка приводит к абстрактным и компактным программам... )

```javascript
    Function<Integer, Integer> f = x -> x + 3;
    BiFunction<Function<Integer, Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
    System.out.println(g.apply(f, 7));
```

     Каррирование - это преобразование функции со многими аргументами в набор функций каждая из которых имеет по одному аргументу.

     Замыкание - ( является глобальной переменной ) это когда в теле функции присутствуют ссылки на переменные которые объявленные вне тела этой функции.

```javascript
    /**
     * 'Optional' (проверка на 'null' средствами Java 8, без условных операций...)
     * **********
     * функция может принимать значение либо строка либо null
     * В случае если значение null тогда Optionak должен вернуть альтернативное значение (НЕ null...)
     */
    public Optional<String> func(String value) {

        Optional<String> res = Optional.ofNullable( value );

        return res.orElse("альтернативное НЕпустое значение");
    }
```

```javascript
    /**
     * 'Stream'
     * **********
     * в первом случае:
     * * 'map' преобразует поток stream-ов в (поток) список String-ов
     * * находит первый попашийся элемент с этого списка String-ов
     * * и возвращает элемент типа String
     */
    public String findId() {
        
        List<Client> clients = ...

        return clients.stream()
                .map(client -> client.getTaxId()) // Client -> String
                .findFirst()
                .get(); // String
    }

    /**
     * 'Stream' + 'Optional'
     * *********************
     * во втором случае:
     * * 'map' преобразует поток stream-ов в (поток) список String-ов
     * * находит первый попашийся элемент с этого списка String-ов
     * * и возвращает элемент типа Optional
     * дальше Optional проверяет:
     * * если результат НЕ null тогда возвращаем найденный результат (это для того чтобы предотвратить 'NullPointerException')...
     */
    public String findId() {
        
        List<Client> clients = ...

        Optional<String> taxId = clients.stream()
                .map(client -> client.getTaxId()) // Client -> String
                .findFirst(); // Optional<String>

        return taxId.isPresent() // true / false
                ? taxId.get() // String
                : "НЕнайдено";
    }
```

---
1. Есть обычные интерфесы (которые имплементируются в классах);
2. Есть интерфейсы с дефолтными методами ('default' - которое определяют дефолтную реализацию методов еще на уровне интерфейса);
3. Есть функциональные интерфейсы (это интерфейсы только с одним методом);

.

    Так вот, лямбда-выражение - это отложенное определение тела функции на потом (с помощью функциональных интерфейсов...).
    Удобным способом использования их является тот факт, что можно опускать круглые и фигурные дужки (с помощью которых описывается синтаксис для параметра и тела функции...).
    Кроме этого, реализовывать определение тела функции можно и в отдельнм классе (при условии что поля этого класса будут идентичны функционвльному интерфейсу)

```javascript
    interface MyFace2 {
        void hello(String val);
    }

    MyFace2 face2 = val -> { System.out.println(val); };
    face2.hello("Hello!");
```

```javascript
    static class MyClazz3 {
        public static void hello(String val) {
            System.out.println(val);
        }
    }

    MyFace3 face3 = MyClazz3::hello;
    face3.hello("Hello!");
```


---
* ( Java-8 )

'map()' - преобразует данные из одного типа в другой.
          Например, есть 'Publisher' (издатель) и есть много подписчиков 'Subscribe'. Так вот: 'map' делает легкое связывание между двумя этими источниками И
                    позволяет передать данные от одного типа источника 'Publisher' для (других типов источников) всех его зависимых слушателей 'Subscribe'.

     'map()' - может преобразовывать каждый элемент стрима И возвращает только одно значение (а именно - коллекцию).
     'flatMap()' - может преобразовывать каждый элемент стрима НО возвращает поток значений (стрим).


---
* Классы

```javascript
    /**
     * A static{}
     * B static{}
     * A {}
     * B.func=null
     * B {}
     */

    /*
     * #1. первым делом, в классе, будут вызваны статические блоки И в базовом классе и потом в классе наследнике.
     *     (для всех блоков правило 'полиморфизма' не действует!)
     */

    /*
     * #2. Полиморфизм - это правило переопределение функции по умолчанию в классах наследниках действует только на функции класса.
     *     Те функции которые переопределенные в классе наследнике по умолчанию применяются для всех базовых классов.
     */

    /*
     * #3. дальше, в классе, будут вызваны обычные блоки И в базовом классе и потом в классе наследнике.
     */

    /*
     * #4. только потом, в классе, будут вызваны конструкторы И в базовом классе и потом в классе наследнике.
     *     Конструкторы это такие себе именнованные блоки, которые ведут себя как обычные блоки, но при этом служат для иннициализации класса в момент его создания.
     */
```

```javascript
    /**
     * В интерфейсе можно объявлять поля НО они должны быть обизательно проинициализированны И НЕдолжны быть приватными!
     * (по умолчанию все поля в интерфейсе являются статическими и публичными и финальными)
     */
    public interface MyC {
//        public static final int a; // ошибка - нет иннициализации
//        private int b = 100; // ошибка - нельзя приватное поле
        int a = 100; // нормально!
        String str = "abc"; // нормально!
        Aaa aaa = new Aaa(); // нормально!

        class Aaa {
            private int ego;
            private String name;
            public int getEgo() {
                return ego;
            }
            public void setEgo(int ego) {
                this.ego = ego;
            }
            public String getName() {
                return name;
            }
            public void setName(String name) {
                this.name = name;
            }
        }
    }
```

```javascript
    /**
     * Интерфейс может иметь или НЕиметь вообще методов (интерфейсные - без реализации)
     * Но в интерфейсе запрещается иметь методы с реализацией
     * Интерфейсы в Java используются для МНОЖЕСТВЕННОГО наследования
     * Дефолтные методы интерфейса в Java-8 (наоборот) разрешают НЕпереопределять их в классе-наследнике
     * МОЖНО делать static интерфейс но НЕЛЬЗЯ делать final интерфейс и его методы (НО поля внутри интерфейса являются final)
     * 
     * Абстрактный класс может иметь или НЕиметь вообще методы абстрактные методы или может НЕиметь ниодного вообще любого методы
     * Абстрактные классы в Java используются для ОДНОГО наследования (НО он принуждает что реализация метода должна обизательно быть определена в классе-наследника)
     * Еще абстрактный класс запрещает создавать его экземпляр
     * (Общее между абстракцией и функциональным интерфейсом - то что они все должны быть переопределены в своих наследниках...местах вызова)
     */

    interface A {}

    interface AA {
        int a();
    }

    interface AAA {
        default int a() {
            return 0;
        }
    }

    abstract class B {}

    abstract class BB {
        abstract int a();
    }

    abstract class BBB {
        int a() {
            return 0;
        }
    }
```

```javascript
    /**
     * Статические классы вместе со статическими методами МОЖНО НАСЛЕДОВАТЬ!
     * При этом использование операторов 'new' и 'null' НЕбудет играть никакой роли...потому-что оператор 'static' уже создаст единственный экземпляр для этого приложения И все зависит только от объявленного типа переменной-класса
     * 
     * статические поля и методы МОГУТ вызываться внутри НЕстатических методов!
     * НО НЕстатические поля и методы НЕМОГУТ вызываться внутри статических методов
     */
    public static class MyA {
        public static void func() {
            System.out.println("MyA");
        }
    }

    public static class MyB extends MyA {
        public static void func() {
            System.out.println("MyB");
        }
    }
    
    ///////////////
    MyA.func();
    MyB.func();

    MyA myA = new MyA();
    MyB myB = new MyB();
    MyA myX = new MyB();
    myA.func();
    myB.func();
    myX.func();

    myA = null;
    myB = null;
    myA.func();
    myB.func();
```

    Java работает только на ПОВЫШЕНИЯ ТИПОВ (явное-приведение типов!
    Для коллекций приведение типов работает на ПОВЫШЕНИЯ и ПОНИЖЕНИЕ ТИПОВ! (Но для этого НУЖНО указывать ТИП КОЛЛЕКЦИИ, ИЛИ можно указывать общий интерфейс)
    [здесь](https://github.com/Home-SignUp/utilSlotsActualDB/blob/master/src/test/java/com/java/ExtendTest.java)

```javascript
        /*
         * Java работает только на ПОВЫШЕНИЯ ТИПОВ (явное-приведение типов)!
         * (инначе выбрасывает checked-проверяемое исключение java.lang.ClassCastException)
         */
         A a1 = new B("B1",1);
         aa = bb;
//        B b2 = (B) new A("A2"); // java.lang.ClassCastException
//        bb = (B) aa;            // java.lang.ClassCastException
         
        /*
         * Для коллекций приведение типов работает на ПОВЫШЕНИЯ и ПОНИЖЕНИЕ ТИПОВ!
         * (Но для этого НУЖНО указывать ТИП КОЛЛЕКЦИИ, можно указывать общий интерфейс)
         * (инначе выбрасывает checked-проверяемое исключение java.lang.ClassCastException)
         */
        List<A> aList1 = (List) bList;
        List<B> bList1 = (List) aList;
        List<A> aaList1 = (LinkedList) bbList;
        List<B> bbList1 = (ArrayList) aaList;
//        List<A> aaList1 = (ArrayList) bbList; // java.lang.ClassCastException
//        List<B> bbList1 = (LinkedList) aaList; // java.lang.ClassCastException

        /*
         * Приведение типов для хеш-карт
         */
        Map<String, String> map = new HashMap<>();
        map.put("Hello", "World");
        map.put("Apple", "3.14");
        map.put("Another", "Element");

        // для списков в Java 7
        List<String> keyList = new ArrayList<>(map.keySet());
        List<String> valueList = new ArrayList<>(map.values());

        // для списков в Java 8
        List<String> values = map.values().stream()
                .collect(Collectors.toList());
        
        // для массивов
        String[] arr = map.values().toArray(new String[0]);
        
        // из примитивного типа в список-обвертку и обратно (Java 8):
        List<Integer> intList = null;

        intList.stream().mapToInt(i->i).toArray();            // конвертировать:  List<Integer> -> int[]
        IntStream.of(A).boxed().collect(Collectors.toList()); // конвертировать:  int[] -> List<Integer>
```

    Рефлексивность: сравнение объекта самого-себя - гарантированно возвращает равенство (при условии что объекты неNULL)
    Симметричность: если два объкекты 'A' и 'B' равны - тогда при обратном условии сравнения (либо 'A==B' либо 'B==A') гарантируется их равенство
    Транзитивность: три объекта 'A','B','C'; при двух условиях равенства объектов если 'A==B' и 'B==C' - тогда гарантируется равенство между 'A==C'
    [здесь](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L597)

```javascript
    class C {
        int ego;

        public int hashCode() { return ego; }

        public boolean equals(Object o) {
            if (this == o) return true; // Рефлексивность: сравнение объекта самого-себя
            // Симметричность: если два объкекты 'A' и 'B' равны - тогда при обратном условии сравнения (либо 'A==B' либо 'B==A') гарантируется их равенство
            // Транзитивность: три объекта 'A','B','C'; при двух условиях равенства объектов если 'A==B' и 'B==C' - тогда гарантируется равенство между 'A==C'
            if (o == null || getClass() != o.getClass()) return false;

            C c = (C) o;

            return ego == c.ego;
        }
    }
```

---
* Способы сравнения объектов

```javascript
/**
 *
 * 18. Что такое пул строк?
 * ***********************
 ** Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка,
 *  иначе создается новая строка в пуле, а затем возвращается ссылка.
 ** Тем не менее, когда мы используем оператор new, мы принуждаем класс String создать новый объект строки, а затем мы можем использовать метод intern() для того,
 *  чтобы поместить строку в пул, или получить из пула ссылку на другой объект String с таким же значением.
 *
 * пул строк – это набор строк, который хранится в памяти Java heap.
 * Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк.
 * Пул строк также является примером паттерна Приспособленец (Flyweight).
 * Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.
 *
 * 19. Что делает метод intern()?
 * *****************************
 * Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка
 * на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.
 * Этот метод всегда возвращает строку, которая имеет то же значение, что что и текущая строка, но гарантирует что это будет строка из пула уникальных строк.
 *
 */
```


---
* Concurrent Collections

```javascript
/**
 *
 * CopyOnWrite коллекции:
 * - CopyOnWriteArrayList<E> — Потокобезопасный аналог ArrayList
 * - CopyOnWriteArraySet<E> — Имплементация интерфейса Set
 * Улучшенные реализации HashMap, TreeMap с лучшей поддержкой многопоточности и масштабируемости:
 * - ConcurrentMap<K, V> — Интерфейс, расширяющий Map
 * - ConcurrentHashMap<K, V> — В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей
 * - ConcurrentNavigableMap<K,V> — Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений
 * - ConcurrentSkipListMap<K, V> — Является аналогом TreeMap с поддержкой многопоточности
 * - ConcurrentSkipListSet<E> — Имплементация Set интерфейса
 *
 * - ConcurrentLinkedQueue — синхронно добавляет / удаляет элементы (использует алгоритм для быстрой переборки элементов)
 * - ConcurrentLinkedDequeue — (такой же как и 'ConcurrentLinkedQueue') работает в двух-стороннем порядке FIFO
 */
```


---
JPQL-запрос — используется на уровне DAO слоя...например в Spring-Data @Repository / CrudRepository / JpaRepository
               в случае если метод должен формировать специфический sql-запрос...

```javascript
    @Query("select b from Bank b where b.name = :name")
	Bank findByName(@Param("name") String name);
```

---
* join в HQL

HQL-запрос — это такой запрос который строиться с помощью "Criteria" на уровне Service слоя.

```javascript
    Criteria criteria = session.createCriteria(My.class);
    criteria.get()
            .list()
            .load()
```

**(** [https://forum.hibernate.org/viewtopic.php?f=1&t=1009553](https://forum.hibernate.org/viewtopic.php?f=1&t=1009553) **)** [https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies](https://developer.jboss.org/wiki/AShortPrimerOnFetchingStrategies)
[https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables](https://stackoverflow.com/questions/8399379/hibernate-named-query-join-3-tables)

```
   Вот важная вещь которую нужно знать о "join fetching":
   - fetch="join" используется только при получении данных через функции "get()" или "load()": с помощью настройки "criteria.setFetchMode('name', FetchMode.LAZY)"
   - fetch="join" использует "OUTHER JOIN" для ПУСТЫХ (nullable) "MANY-TO-ONE" FOREIGN KEY (внешних ключей) и коллекций
   - fetch="join" использует "INNER JOIN" для НЕПУСТЫХ (not-null) "MANY-TO-ONE" FOREIGN KEY (внешних ключей)

   HQL-запросы не учитывают стратегию выборки JOIN-ов определенных в mapping-документе
   Чтобы HQL-запрос мог использовать "LEFT OUTHER JOIN" - нужно явно написать его в своем запросе...
```

```javascript
    @NamedQuery(name = "query1", query = "SELECT DISTINCT o " +
        "FROM Organization o, User u " +
        "JOIN o.roles oRole " +
        "JOIN u.roles uRole " +
        "WHERE oRole.id = uRole.id AND u.id = :uId")
    public class Organization { ...
```

```
  Какие методы есть у класса Object
  ---------------------------------
   1. public final native Class getClass()
   2.             public String toString()
   3.         public native int hashCode()
   4.            public boolean equals(Object obj)
   5.   protected native Object clone() throws CloneNotSupportedException
   6.            protected void finalize() throws Throwable
   7.  public final native void wait(long timeout) throws InterruptedException
   8.         public final void wait(long timeout, int nanos) throws InterruptedException
   9.         public final void wait() throws InterruptedException
  10.  public final native void notify()
  11.  public final native void notifyAll()
```

![HotSpot JVM](untitled3.png)

![HotSpot JVM](untitled.png)

![HotSpot JVM](untitled2.png)

```
  Какие существуют области памяти в Java (HotSpot JVM)
  --------------------------------------
  Есть 3-сегмента:
  1. Stack (Стек)
  2. Heap (Куча)
  3. PermGen (Permanent Generation)
  --------------------------------------
  - "Stack" (стэк - хранит только локальные переменные примитивных типов и ссылки на объекты в куче)
            управления памятью осуществляется по схеме LIFO (первый вошел - последний вышел)
	        стэковая память существует лиш на короткое время для работы отдельной под-программы
	        стэк может использоваться только одним потоком исполняемой программой (стэковая память НЕможет быть доступна для других потоков)
	        "java.lang.StackOverflowError" (если память стэка заполнена)
	        "-Xss" (опции JVM определить размер памяти стэка)
  - Куча:
	      всякий раз когда создается объект - он хранится в куче
	      объекты в куче доступна для других потоков, с любой точки программы (объекты в куче используется всеми частями приложения)
	      память в куче живет с самого начала до самого конца работы программы
	      "java.lang.OutOfMemoryError" (если память кучи заполнена)
    -- "Permanent Generation" (статический контент - сюда загружаются статические классы, методы, хранится метаинформация..)
                              изменение размера в PermGen – это дорогостоящая и трудоёмкая операция
                              Размер в PermGen можно задать 2-мя параметрами JVM:
                              -XX:PermSize (задаёт минимальный или изначальный размер)
                              -XX:MaxPermSize (задаёт максимальный размер)
	-- "Heap" (основной сегмент памяти где хранятся все ваши объекты):
	          опции JVM определить размер памяти кучи:
	          "-Xms" (минимум)
	          "-Xmx" (максимум)
	          И делится на 2-а подсегмента:
               1. Young Generation (Новая куча)
                  ---- "Eden" (молодое поколение - сюда попадают все новосозданные объекты)
                  ---- "Survivor" (сюда копируются выжившие объекты после первого прохода сброщика муссора - Garbage Collector "GC" )
               2. Old Generation (Старая куча)
                  ---- "Tenured" (сюда попадают долго-живущие объекты которые выжили после нескольких проходов сброщика муссора - "GC" )
                       Сборка муссора (Garbage Collection - `GC`)
                       --------------
                       - `stop-the-world` (этот алгоритм создаёт то что называется моментом `когда мир остановился`. Во время выполнения GC JVM переводится в состояние паузы...)
                                          суть `GC Stop` заключается в дефрагментации памяти.
                       Существует множество алгоритмов которыми может воспользоваться JVM для проведения GC:
                       - `Mark-Sweep` (Первое – обход графа и установка особого флажка на каждом из достижимых объектов; Второе – сканирование всей памяти и помещение объектов без флажка в список свободного пространства;)
                       - `Copy Collector` (позволяет осуществить все вышеперечисленное только за один проход: когда находим в графе новый объект мы сразу копируем его в другое пространство памяти...)
                       - `Mark-Sweep-Compact` (выполняет `Mark-Sweep`, затем после выполнения действия-sweep, он перемещает объект в памяти чтобы выполнить дефрагментацию и обеспечить непрерывность свободного места...)
```

```
Класс 'Stack' - работает по принципу LIFO (последним пришел - первым ушел). Элементы кладутся в стек «друг на друга», причем взять можно только верхний-элемент, который был положен в стек последним:
push(Object item) - помещает элемент на вершину стека;
pop() - извлекает из стека верхний элемент;
peek() - возвращает верхний элемент, не извлекая его из стека;
empty() - проверяет, не пуст ли стек;
```


```javascript
    /**
     * @see https://javadevblog.com/polnoe-rukovodstvo-po-java-8-stream.html
     * @see https://habrahabr.ru/company/luxoft/blog/270383
     */


    public void testStreamTerminal(){
        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Чтобы создать поток:
         * - stream // из существующего списка
         * - of     // из перечисляющих элементов
         */
        Stream.of("dd2", "aa2", "bb1", "bb3", "cc")
                .forEach(System.out::println);

        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Есть 'терминальные методы' которые ничего НЕврзвращают:
         * ifPresent, forEach
         *
         * Есть 'терминальные методы' которые возвращают:
         * - min, max, average, findFirst, findAny  // Optional
         * - sum, count                             // примитивные типы Java
         * - collect                                // List
         * - reduce                                 // Object
         */
        OptionalInt min = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .min(); // Optional
        OptionalInt max = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .max(); // Optional
        OptionalDouble average = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .average(); // Optional
        OptionalInt findFirst = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .findFirst(); // Optional
        OptionalInt findAny = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .findAny(); // Optional

        int sum = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .sum(); // int
        long count = Stream.of(22, 2, 1, 33, 0).mapToInt(Integer::valueOf)
                .count(); // long

        List<Integer> items = Stream.of(22, 2, 1, 33, 0)
                .collect(Collectors.toList()); // List

        Stream.of(22, 2, 1, 33, 0)
                .forEach(System.out::println);

        min.ifPresent(x -> System.out.println("min = " + x));
        max.ifPresent(x -> System.out.println("max = " + x));
        average.ifPresent(x -> System.out.println("average = " + x));
        findFirst.ifPresent(x -> System.out.println("findFirst = " + x));
        findAny.ifPresent(x -> System.out.println("findAny = " + x));

        System.out.println("sum = " + sum);
        System.out.println("count = " + count);

        ////////////////////////////////////////////////////////////////////////////////////
        /**
         * Stream НЕмогут быть использованы повторно (как только вызывается терминальная операция - поток закрывается)
         */
//        Stream<Integer> streamInt = Stream.of(22, 2, 1, 33, 0);
//        min = streamInt.mapToInt(Integer::valueOf).min(); // операция выполнится успешно
//        max = streamInt.mapToInt(Integer::valueOf).max(); // Вылетит Exception

        /**
         * Чтобы избежать этого, мы должны создать новую цепь для каждой терминальной операции.
         * Каждый вызов конструктора get() создает новый поток, с которым мы можем безопасно работать.
         */
        Supplier<Stream<Integer>> streamInt = () -> Stream.of(22, 2, 1, 33, 0);
        min = streamInt.get().mapToInt(Integer::valueOf)
                .min();
        max = streamInt.get().mapToInt(Integer::valueOf)
                .max();
        average = streamInt.get().mapToInt(Integer::valueOf)
                .average();
        findFirst = streamInt.get().mapToInt(Integer::valueOf)
                .findFirst();
        findAny = streamInt.get().mapToInt(Integer::valueOf)
                .findAny();
        sum = streamInt.get().mapToInt(Integer::valueOf)
                .sum();
        count = streamInt.get().mapToInt(Integer::valueOf)
                .count();
    }


    /**
     *      Терминальные (продвинутые) операции:
     *      COLLECT, reduce
     */
    public void testCollect() {
        /**
         * Превращает элементы Stream-а в List, Set, Map
         * collect // принимает 'Collector' (который состоит из 4-ех операций: поставщик, аккумулятор, объединитель, финишер)
         */
        Collector<Person, StringJoiner, String> PERSON_COOLECTOR = Collector.of(
                () -> new StringJoiner(" | "),          // (1) поставщик
                (j,p) -> j.add(p.name.toUpperCase()),   // (2) аккумулятор
                (j1,j2) -> j1.merge(j2),                // (3) объединитель
                StringJoiner::toString);                // (4) финишер
        String names = persons.stream()
                .collect(PERSON_COOLECTOR);
        System.out.println(names); // ANDREW | IGOR | IRA | VITIA

        List<Person> filtered = persons.stream()
                .collect(Collectors.toList()); // [Andrew, Igor, Ira, Vitia]
        System.out.println(filtered);

        Map<Integer, List<Person>> personsByAge = persons.stream()
                .collect(Collectors.groupingBy(p -> p.age)); // {20=[Andrew], 23=[Igor, Ira], 12=[Vitia]}
        System.out.println(personsByAge);

        Double averageAge = persons.stream()
                .collect(Collectors.averagingInt(p -> p.age)); // 19.5
        System.out.println(averageAge);

        String phrase = persons.stream()
                .filter(p -> p.age >= 18)
                .map(p -> p.name)
                .collect(Collectors.joining(" и ", "В Германии ", " совершеннолетние.")); // В Германии Andrew и Igor и Ira совершеннолетние.
        System.out.println(phrase);
    }


    /**
     *      Терминальные (продвинутые) операции:
     *      collect, REDUCE
     */
    public void testReduce() {
        /**
         * работа 'Reduce' очень схожа на 'Comparator' (он проходит по списку, берет 2-а рядом стоящих элемента и сравнивает их...)
         * Только 'Reduce' позволяет еще дополнительно выполнять другие операции и формировать ответ..
         */

        // Вариант #1:
        persons.stream()
                .reduce((p1,p2) ->      // (1) на вход принимает 2-а рядом стоящих элемента из списка
                        p1.age > p2.age // сравнивает их и формирует результат...
                                ? p1
                                : p2)
                .ifPresent(System.out::println); // Xxx

        // Вариант #2:
        Person person = persons.stream()
                .reduce(new Person(),     // (1) указываем ему какой тип результата нужно возвращать на выходе...
                        (p1,p2) -> {      // (2) на вход принимает 2-а рядом стоящих элемента из списка
                            Person p = new Person();
                            p.age += p1.age + p2.age;
                            p.name += p1.name + " " + p2.name;
                            return p; }); // и формирует результат...
        System.out.format("name = %s; \nage = %s;\n", person.name, person.age);

        // Вариант #3:
        Integer ages = persons.stream()
                .reduce(0,                    // (1) первичная иннициализация значения...
                        (sum,p) ->            // (2) указываем сам элемент и его значение какое нужно брать...
                                sum += p.age,
                        (sum1,sum2) ->        // (3) на вход принимаетзначение из 2-ух рядом стоящих элементов из списка
                                sum1 + sum2); // и формирует результат...
        System.out.println(ages); // 108
    }


    public void testStreamInterim() {
        // filter, map, mapToInt, flatMap, sorted, limit

        /**
         * Все промежуточные методы возвращают только <Stream>
         * - filter, map, mapToInt, flatMap, sorted, limit // Stream
         *
         * Некоторые промежуточные методы принимают <FunctionalInterface>
         * - filter, map, mapToInt, flatMap // <FunctionalInterface>
         */
        Stream.of("dd2", "aa2", "bb1", "bb3", "bb5", "bb2", "cc")
                .filter(s -> s.startsWith("b"))                    // принимает <FunctionalInterface>, возвращает <Stream>
                .sorted((s1,s2) -> s2.compareTo(s1))               // принимает <FunctionalInterface>, возвращает <Stream>
                .limit(3)                                          // принимает 'Long', возвращает <Stream>
                .map(s -> s.replaceAll("b", "")) // принимает <FunctionalInterface>, возвращает <Stream>
                .forEach(System.out::println);

        System.out.println();

        Stream.of(22, 2, 1, 33, 0)
                .sorted()                   // ничего НЕпринимает, возвращает <Stream>
                .mapToInt(Integer::valueOf) // принимает <FunctionalInterface>, возвращает <Stream>
                .forEach(System.out::println);
    }


    /**
     *      Промежуточные (продвинутые) операции:
     *      FLATMAP
     */
    public void testFlatMap() {
        /**
         * ('map' - преобразовывает объекты одного потока в другие объекты для другого потока...)
         * 'flatMap' - (похож на 'map', только) преобразует каждый элемент одного потока в в другие объекты для МНОГИХ других потоков...
         */
        IntStream.range(1, 4)
                .mapToObj(i -> new Foo("Foo" + i))
                .peek(f -> IntStream.range(1, 4)
                        .mapToObj(i -> new Bar("Bar" + i + " <- " + f.name))
                        .forEach(f.bars::add))
                .flatMap(f -> f.bars.stream())
                .forEach(b -> System.out.println(b.name));
    }
```


Java Concurrency (`java.util.concurrent`)
---

* [1](https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java#L1075) **|** [2](https://github.com/Home-SignUp/utilSlotsActualDB/tree/master/src/test/java/com/concurrent)

    > Процесс — это участок программного кода который лежит в области ОЗУ.
    > Поток — это выделенное процессорное время на выполнение программного кода (этого процесса).
    > Критическая секция — когда несколько потоков пытаются одновременно получить доступ к общему рессурсу.
    > Захват монитора - когда один поток получает доступ к ресурсу а другие потоки в это время ожидают освобождения этого ресурса.

> `Runnable` — это интерфейс (с одним методом `run`) внутри которого описывается задача.

> `Thread` — это класс-сервис который запускает задачу в отдельном потоке.
             Таким потоком можно управлять с помощью методов: (`start`/`stop`/`sleep`/`interrupted`) а еще (`join`/`yield`).
> Чтобы решать проблемы с `критическими секциями`: в `Thread` есть методы для блокировки потоков: (`wait`/`notify`).
> Жизненный цикл потока: NEW, RUNNING, BLOCKING, WAITING, TERMINATE

```text
Существует 5-способов синхронизации (`synchronized`) для критических секций между потоков:
1. относительно текущего экземпляра (объекта) класса
2. относительно статического класса

3. (lock-синхронизация) относительно одного объекта

4. оператор `volitale` (позволяет полулчить прямой доступ к данным в памяти, минуя кеш-потока)
5. использование атомарных функций (get/set) 
```

I. Исполнители

> `Callable` — это задачи которые могут быть переданы исполнителям (типа `Runnable`), но (в отличие от `Runnable`) `Callable` может возвращать значение.
                `submit()` НЕждет завершения задачи и исполнитель НЕможет вернуть результат задачи напрямую
> `Future` — поэтому (вместо `Callable`) исполнитель возвращает специальный объект-Future у которого можно запросить результат задачи.
             (`isDone`/`get`) и еще (`invokeAll`/`invokeAny`)

> `ExecutorService` — (интерфейс) сервис-исполнителей (типа `Thread` но есть важное отличие: он никогда НЕостановится, поэтому его останавливать явно)
                       (`submit`/`shutdown`/`shutdownNow`/`awaitTermination`)
> `Executors` — это (класс) предоставляет фабричные методы для создания сервисов-исполнителей
```javascript
Executors.newSingleThreadExecutor(); // вернет исполнителя с пулом в 1-поток
Executors.newFixedThreadPool(10);    // вернет исполнителя с пулом в 10-потоков
Executors.newWorkStealingPool();     // вернет исполнителя с пулом потоков равным количеству ядер машины
```

II. Синхронизация и Блокировки

> `Semaphore` — (более удобен чем `wait`/`notify`) ограничивает количество потоков которые используют `критические секции` (`tryAcquire`/`release`).

> `ReentrantLock` — (типа `wait`/`notify`) реализует то же поведение что и обычные блокировки: (`lock`/`unlock`/`tryLock`).
> `ReadWriteLock` — отдельная блокировка для чтения и для записи (`readLock`/`writeLock`/`readUnlock`/`writeUnlock`).
> `StampedLock` — (похож на `ReadWriteLock`) у этого класса есть методы для `оптимистичной блокировки` (`tryOptimisticRead`/`tryConvertToWriteLock`/`validate`).
```text
Блокировка на чтения запрещает использовать блокировку на запись.

'Оптимистическая блокировка' позволяет другим потокам блокировать ресурс НЕдожидаясь окончания работы.
(После захвата ресурса оптимистическая блокировка является валидной И предыдущая оптимистическая блокировка отправляется спать - уже перестает быть валидной)
ПРОБЛЕМА В ТОМ ЧТО ПОСТОЯНО НУЖНО СЛЕДИТЬ ЗА ВАЛИДНОСТЬЮ ОПТИМИСТИЧЕСКИХ БЛОКИРОВОК.
```

III. Атомарные операции

> `AtomicInteger`, `AtomicBoolean`, `AtomicLong`, `AtomicReference` — (`get`/`incrementAndGet`/`updateAndGet`).

> `LongAdder` — (альтернатива `AtomicLong`)
> `LongAccumulator` — (расширяет `LongAdder`)


[Коллекции](https://habrahabr.ru/post/237043)
---

![Коллекции](65cd6dce50e84d659152c482e5565f3c.png)

Есть два типа коллекций, это список и хеш-карты

> 1. `Collection` — это общий интерфейс для всех коллекций-списка:
> `List` (это интерфейс для списков)
>> `Vector` — в его основе лежит массив. (+) применяется где нужна потокобезопасность; (-) из-за синхронизации работает очень медленно;
>> `ArrayList` — в его основе лежит массив-индекс. (+) быстро добавляет элеметы только в конец списка и по индексу быстро получает доступ к любому элементу; (-) медленно выполняется удаление или любое изменение связанное с размером списка;
>> `LinkedList` — в его основе лежит связи-итератор между элементами. (+) быстро добавляет элеметы в любое место списка и быстро удаляет их; (-) для поиска медленно выполняется перебор элементов;
> `Set` — такие списки НЕсодержат (отсекают) дубликаты элементов (+) исключаются избыточные элементы в списке + отсутствуют утечки в памяти; (-) НЕльзя обновлять уже существующий элемент;
> `Queue` (это интерфейс для очередей) такие списки являются двух-сторонними И позволяют сортировать элемпенты по критерию приоритетности...
>> `ArrayDeQueue` — 
>> `LinkedList` — 
>> `PriorityQueue` — 
> 2. `Map` (это интерфейс для хеш-карт)
>> `HashTable` — в его основе лежит массив списков. (+) применяется где нужна потокобезопасность; (-) из-за синхронизации работает очень медленно;
>> `HashMap` — (контракт между hashCode и equals). (+) позволяет очень быстро выполнять все операции над элементами списка! (-) плохо определенный hashCode и equals ведет к снижению в производительности и к утечке в памяти...;
>> `TreeMap` — (самосортирующие структуры 'Comparable' или 'Comparator' compare или compareTo) (+) быстрый поиск элемента за минимальное количество итераций + позволяет работать с очень большими таблицами; (-) большое время добавление нового элемента;


    Область применения коллекций:
    1. Вся информация хранится в базе данных. Обычно клиент в текущем запросе запрашивает (НЕвсю информацию из базы данных а) только какую-то часть из этого...
       Например строится запрос к базе данных где клиент хочет получить список машин конкретной марки за какой-то период ИЛИ получить машин которые вмещаются на одной странице и отсортированы по дате выпуска...
       Результатом такого запроса на выходе будет получен НЕбольшой список элементов 10-1000 элемеентов.
       Обычно такой полученный список просто отдается клиенту в слой-представления (и никаких операций с таким списком больше НЕвыполняют)
    2. Если элементы в списке очень тяжеловестные в таких случаях очень ресурсоемно-медленно выполнять какие-либо навигационные операции по такому списку...
       Например для сортировки элементов внутри списка чтобы перебрать каждый тяжеловестный элемент списка и сравнить его - это очень ресурсоемкая процедура (потому-что сам элемент очень большой)
       Для этой цели существуют Хеш-Карты (асоциативные массивы, 'Приспособленец' — внутреннее и внешнее состояние элементов) позволяют каждый тяжеловестный элемент ('value') ассоциировать с более легковестным элементом ('key')
       Поэтому Хеш-Карты удобно использовать в операциях для внутренних навигационных-вычисленний (хешировать промежуточные запросы, быстро сортировать элементы в списке...)
    3. (и списки о хеш-карты обычно хорошо применять для внутренних операций где размер таких списков НЕбольшой)
       Но когда размер списка превышает 100.000 - 1.000.000 работать с таким большим списком становится НЕудобно потому-что обычно в запросах никто не использует столько иногоинформации чтобы помнить о всех ключах и элементах
       Для поисковых систем строятся очень большие списки И чтобы быстро получить доступ к любому элементу такого списка (за минимальное количество шагов) для этого строятся специальные поисковые структуры...
       Бинарные-деревья — для построения таких Бинарные-деревьев затрачивается много времени НО такие структуры должны жить долго (удобно можно использовать в поисковых системах, для выполнения математических расчетов...построить кротчайшее расстояние...) 


Слоевая архитектура в приложении (доменный слой, DAO-слой, сервисный слой, DTO, web-слой или API)
---

###Протокол
1. Любое приложение состоит из `клиентской` и `серверной` части.
   * `серверная часть` — это та часть приложения которая работает на стороне рессурсов.
     Например: контроллер на плате устройства 'дисковода' умеет работать с секциями диска...записывать и читать данные...
   * `клиентская часть` — это та часть приложения которая работает на стороне клиента (в конкретной Опреационной Системе или на конкретном компьютере подключенного к сети).
     Например: клиентское приложение 'файлового менеджера' умеет распознавать: 'диски', 'директории', 'программы', 'документы' (а также умеет обращаться с ними: раскрывать директории, запускать программы, читать документы с помощью асоциированной программы...) 
   * и `серверная` и `клиентская` часть являются программами которые запущены и постоянно висят-работают (как сокеты...в режиме ожидания дожидаются команды)
     Каждая из этих программ ничего друг о друге НЕзнает. И чтобы научить их как-то общяться между собой — для этого и существует `протокол`
     Например `файловый протокол` описывает порядок взаимодействия между клиентом и сервером для получения информации из дискового носителя
     (можно помогает-формировать клиентские команды, ходить по директориям, смотреть содержимое, запускать программы на выполнение внутри Операционной Системы, скармливать документы на чтение..., оповещает в случае ошибки на стороне клиента или сервера)
     (`http-протокол`: порядок работы в режиме запрос-ответ, поддерживает 4~типа операций, оповещает в случае ошибки на стороне клиента или сервера, имеет: ['физический уровень', 'сетевой уровень', 'транспортный', 'прикладной уровень'](http://kunegin.com/ref6/lan/2.htm))

###API

    Прежде всего `API-слой` связан с `протоколом` и задача слоя API выплюнуть (в ответ) данные в протокол или принять данные (запрос) из протокола.
    (API-слой ничего НЕзнает кто является клиентом запросов НО `API-слой` может взаимодействовать-поддерживать только с конкретным типом `протокола`...с которым в свою очередь работает клиент)

###Сервисный слой

По сути, вся основная часть программы (ее бизнес-логика) реализована внутри этого `сервисного слой` (это центр всего приложения).
`Сервисный слой` является серверным компонентом и постоянно работает с начала запуска сервера приложения и до момента его остановки...
(Сервисный слой ничего не знает о том куда уходят данные и откуда эти данные приходят...)
Поэтому сервисному слою НЕважно кто будет получателем этих данных НО те данные которые на выходе этого сервисного слоя, могут быть и на входе этого сервисного слоя...
(За получения и доставку данных отвечают `API-слой` и `DAO-слой`. А `сервисный слой` только получает данные и обрабатывает их...)

###DAO

    Все данные которые используются во всем приложении можно разбить на: `постоянные` и `временные` данные:
    - На стороне клиента данные являются временными И изменяются с каждым переходом от одной веб-страницы на другую
    - Чтобы после выключения компьютера эти клиентские данные НЕпропали, эти данные ложаться в базу данных для постоянного хранения
    - Сервисный слой может использовать эти `постоянные данные` из базы данных чтобы избавить клиента от дополнительного заполнения форм ранее уже введенными данными
    По своему назначению `DAO-слой` является слоем который на уровень ниже сервисного слоя И предоставляет API-функции для этого сервисного слоя чтобы связать его с базой данных (источником постоянного хранения данных...)
    (Для DAO-слоя открываются пулы-соединений с базой данных... формируются И отправляются запросы на сервер базы данных А также принимает и возвращает ответ из базы данных в сервисный слой)

###Доменный-слоя и DTO-слой

При транспортировке данных из одной области в другую внутри приложения, программа оперирует конкретными типами объектов (`POJO-классы`) И структура этих объектов тоже должна где-то описываться.
`Доменный-слоя` - служит для описания структуры (`POJO-классов`) тех типов объектов которые используются внутри `Сервисного слоя`.
`DTO-слой` - служит для описания структуры (`POJO-классов`) тех типов объектов которые API выплевывает (в ответ) в протокол или принимает (запрос) в сервисный слой.



Паттерны проэктирования в архитектуре приложения
---

    Прежде всего каждый слой на фоне архитектуры всего приложения имеет свое назначение и поведение:
    - Объекты мгут менять свое поведение на стороне клиента (например заполнение полей формы... это выше API-слоя)
    - На уровне DAO-слоя можно описывать какую-либо структуру для получения данных...
    
    Для применения паттернов внутри архитектуры приложения нужно быть очень осторожным.
    Если паттерн связывает оба слоя так что изменяется исходное поведение компонента внутри слоя - в таком случае последствия приведут к ошибкам в работе программы.

* Плохой тон программирования

`Например: если паттерн 'Билдер' применить к доменному слою - такое поведение повлечет ошибки для выгрузки и иннициализации объектов из базы данных DAO-слоя`

* Хороший тон программирования

`Например: для создания пула соединения паттерн 'Синглтон' использует отдельную утилиту в сервисном слое - такое поведение поможет ограничить от создания избыточных пулов соединений внутри этого приложения`
`Для описания объекта чтобы создать соединение с сервером в момент иннициализации можно применить паттерн 'Билдер' - чтобы выделить объязательные и НЕобъязательные параметры соединения`
`(Для построения POJO-классов в DTO-слое можно применить конвертеры которые не влияют на работу POJO-классов в других слоях)`



[SQL / Кластерные и некластерные индексы](http://www.quizful.net/interview/sql/clustered-index)
---

* `Некластерные индексы` (создаются СУБД по умолчанию):
   Физически данные расположены в произвольном порядке НО логически эти данные упорядочены согласно индексу (такой тип индексов подходит для таблиц где часто изменяются значения).
   Для ОДНОЙ таблицы может быть создано МНОГО некластерных индексов.

* `Кластерные индексы`:
   физически данные упорядочены - что очень повышает скорость выборок данных (но только в случае последовательного доступа к данным).
   Для ОДНОЙ таблицы может быть создан только ОДИН кластерных индекс.

###Каждая таблица InnoDB имеет кластерный ключ

1. Если в таблице задан PRIMARY KEY — это он
2. Если в таблице есть UNIQUE (уникальные) индексы — это первый из них
3. InnoDB самостоятельно создаёт скрытое поле с суррогатным ID размером в 6 байт

![Некластерные индексы](07a06aa6953afd68b5c3e292eb6525b2.png)

![Некластерные индексы](480c30ff21e698f4e5a1fbb39b93919b.png)

![Кластерный индекс](dc32d382d9ea7b7bad94deffdf191bcb.png)

![Кластерный индекс](e09122b8f6974ea66dd675b1286baec7.png)

![Кластерный индекс](fbfa24eb14d65fc3a4b815e4e0e63018.png)



(`Security`) защита управление безопасностью доступа к компонентам
---

[OpenSSL — универсальный криптографический инструмент, построенный вокруг протоколов SSL/TLS и сертификатов X.509](ttp://xgu.ru/wiki/OpenSSL)
[Электронная подпись](https://ru.wikipedia.org/wiki/Электронная_подпись)
[Как работает проверка подписи сертификатов (CA)](http://www.linux.org.ru/forum/security/11544406)
[Подписи в аплетах - как это делается](http://forum.vingrad.ru/faq/topic-157929.html)
[Подпись кода Java: Создание CSR](https://ru.godaddy.com/help/podpis-koda-java-sozdanie-csr-4780)
[Самоподписанные сертификаты для EXE файлов и Java апплетов](http://www.selectcms.ru/news/samopodpisannye-sertifikaty-dlya-exe-fajlov-i-java-appletov)
[Включение SSL на вашем веб-сервере](http://server.arcgis.com/ru/web-adaptor/latest/install/java-linux/enable-https-on-your-web-server-portal-.htm)
[Настройка SSL для TomCat](https://habrahabr.ru/post/134453)
[Установка SSL сертификата: Tomcat](https://www.emaro-ssl.ru/instructions/ssl-installation-tomcat.php)
[Безопасность в J2EE](http://javagu.ru/portal/dt?last=false&provider=javaguru&ArticleId=GURU_ARTICLE_81114&SecID=GURU_SECTION_80693)
[Код написан и подписан - значит, будет жить...](http://www.infocity.kiev.ua/prog/java/content/java014.phtml)
[Учимся готовить: Spring 3 MVC + Spring Security + Hibernate](https://habrahabr.ru/post/111102)
[Решение проблем функциональной совместимости спецификации WS-Security: Часть 4. Добавление конечной точки поставщика J2EE 1.3 в Web-сервис J2EE 1.4](http://www.ibm.com/developerworks/ru/library/ws-securityspec4)
[Symantec Code Signing Certificates](http://www.symantec.com/ru/ru/code-signing)

* Таким образом общая картина безопасности для J2EE-приложения имеет несколько этапов:
  - на уровне протокола-HTTPS (SSL: протокол обвертывает сервер приложения, такой себе промежуточный слой, для передачи данных... например: в момент аудитенфикации, или проверка через цифровую подпись)
    - (SSL): HTTPS-протокол который является надстройкой HTTP-протокола с цифровой пописью...AuthorizationBase64)
  - на стороне сервера приложения (настройка глобальной и локальной безопасности, правила доступа которой строится на сервере приложения: на уровне всего сервера приложений... например: ролевая политика распространяющая на группу пользователей для ограничения доступа к ресурсу)
    1. Использование фильтров, чтобы покрыть клиентские URL-запросы для гарантированной защиты
    2. Установка защищиты на метод в классе (@PreAuthorize, @Security...)
  - XML-анализ DOM-структуры документа JAXB/XStream-парсером (для предварительной проверки целостности документа перед тем как вызывать удаленную процедуру... например: проверка целостности и подлинности локумента)
    - (SOAP...)


* Есть "клиент", желающий общаться с "сервером" в зашифрованном виде (клиент просит у сервера его публичный ключ, после чего его каким-то образом проверяет с имеющимся у него сертификатом (открытый ключ) доверительного центра сертификации (ЦС)):
  - **Закрытый/приватный ключ** является наиболее уязвимым компонентом всей криптосистемы цифровой подписи (злоумышленник, укравший закрытый ключ пользователя, может создать действительную цифровую подпись любого электронного документа от лица этого пользователя. Поэтому особое внимание нужно уделять способу хранения закрытого ключа).
  - При помощи приватного ключа подписывается сертификат, который содержит "публичный/открытый ключ" (открытый ключ, подписанный закрытым ключом СЦ).
  - Сервер в ответ на запрос возвращает ВСЮ ЦЕПОЧКУ сертификатов:
    - цепочка выглядет так <Сертификат Васи> --> <Сертификат конечного CA> --> <Сертификат промежуточного CA> и будем считать, что <Сертификат промежуточного CA> подписан корневым CA.
    - при помощи публичного ключа из сертификата конечного CA проверяет, что сертификат Васи подписан приватным ключем этого конечного CA.
    - если проверка прошла успешно то вся цепочка считается валидной и ей доверяют.
  - **Хранилище ключей** — это место, в котором хранятся сертификаты.

Каждый сервер может генерить "закрытый/приватный ключ" и запрос на получение "сертификата" (.csr/.cer/.crt: публичный/открытый ключ). Любой клиент обладающий "сертификатом" (публичным/открытым ключом) получает полномочия права доступа к серверным ресурсам
Сертификат (публичный/открытый ключ) который генерит сервер-доверитель - является самописным и не имеет к себе никакого доверия (но если избранный сервер своей подписью подпишет сертификат сервера-доверителя - тогда уже такой сертификат будет являться доверенным...)
Если нужно чтобы другой сервер являлся доверителем для избранного сервера тогда нужно чтобы избранный сервер подписал своим приватным ключем открытый ключ другого сервера (то есть, в итоге получиться такая цепочка с подписью сертификатов оригинального и довереных серверов)

    Создайте запрос на подпись сертификата (CSR). Закрытый ключ будет создан и сохранен в хранилище ключей.
    В текущем рабочем каталоге будет создан файл CSR "mycsr.pem".
    Приобретение сертификата подписи кода в разделе (купить сертификат подписи кода)

После подписи кода содержимое JAR-файла: в директории META-INF находится файл `vingrad.sf` — это и есть подпись.

* Существуют корневые сертификаты:
  - Каждый сертифицированный центр является веб-сайтом которые многие доверяют (при том, что сам-же сертифицированный центр тоже может являться доверителем...)
  - такие сертифицированные центры попадают в белый список каждый раз при обновлении веб-браузера или JVM... - это и есть корневые сертификаты
  - после подписи кода в доверенный сетификат попадает запись и корневого сертификата... поэтому если при проверке вся цепочка сертификатов будет валидна - считается что приложению с такой подписью пожно доверять
    - электронная подпись храниться в JAR-файле (.sf), META-INF - это дескриптор в котором описываются требования к запуску java-приложения...


###Подпись кода

Когда разработчик запрашивает цифровой сертификат - центр сертификации идентифицирует его и выпускает сертификат, связанный с корневым сертификатом центра сертификации.
Платформы и устройства содержат в себе корневой сертификат соответствующего центра сертификации (файл "ca-bundle.crt" - корневой сертификат центра выдавшего сертификат) если платформа или устройство доверяет какому-либо центру сертификации, то оно доверят и вашему сертификату, подписанному этим центром сертификации

0. Есть корневые сертифакионные центры (СЦ/CA) - это компании которым большинство решило доверять (каждый сертификацонный центр имеет приватный и публичный ключ - при помощи приватного ключа подписывается сертификат который содержит публичный ключ).
1. Закрытый/приватный ключ нужно создавать на сервере на котором планируется установить сертификат, при этом его нужно создать перед тем как генерировать CSR-запрос (некоторые программы автоматизируют эти задачи).
   Пример:
```bash
   > ssh-keygen -t rsa -C "aleksandr.lazarchuk@privatbank.ua"
   > ~/.ssh/id_rsa
     -----BEGIN RSA PRIVATE KEY-----
     {данные в Base 64}
     -----END RSA PRIVATE KEY-----
   (обычно вместе с закрытым/приватным ключем генериться и публичный ключ для этого-же сервера > ~/.ssh/id_rsa.pub)
```
2. Создаем свое локальное хранилище (.keystore).
   Пример:
```bash
   > keytool -genkey -keyalg rsa -keysize 2048 -alias "Vingrad" -keystore .keystore
```
3. Формируем запрос на получение-выпуск CSR-сертификата Certificate Signing Request (.CRT).
   Пример (для генерации запроса на сертификат нужен приватный ключ, это свойство сертификатов):
```bash
   > keytool -certreq -file mykey.crt -alias "Vingrad" -keystore .keystore
   > mykey.crt
     -----BEGIN NEW CERTIFICATE REQUEST-----
     {данные в Base 64}
     -----END NEW CERTIFICATE REQUEST-----
```
4. Отправляет CSR-запрос (.CRT) сертифакионному центру (СЦ/CA). После этого центр сертификации (СЦ/CA) присылает сертификат (.CER/.CRT/.PEM) - это открытый ключ подписанный закрытым ключом центра сертификации (СЦ/CA)
```bash
     -----BEGIN CERTIFICATE-----
     {данные в Base 64}
     -----END CERTIFICATE-----
```
5. Подписанный сертификат (.CER/.CRT/.PEM) полученный из центра сертификации (СЦ/CA) импортируем в свое локальное хранилище (.keystore)
```bash
   > keytool -import -trustcacerts -keystore .keystore -alias "Vingrad" -file mykey.cer
```
6. Теперь подписываем jar-архив
```bash
   > jarsigner -keystore .keystore myapp.jar "Vingrad"
   В JAR-файле, в директории "META-INF" находится файл с подписью > "vingrad.sf"
```
7. И подписанный сертификат (.CER/.CRT/.PEM) полученный из центра сертификации (СЦ/CA) отправляем всем кто будет проверять... (проверяется он так):
```bash
   > jarsigner -verify -verbose -certs -keystore .keystore myapp.jar
```
8.1 Теперь когда пользователь на своем клиентском ПК попытается запустить такой JAR-файл в этом случае JVM задаст вопрос: "доверяете ли вы данной подписи" (есть выбор Yes/No/Always | Да/Нет/Всегда)
```bash
    > если ответить "ДА" то JAVA-приложение получит все разрешения...
```
8.2 Если в файле "$JAVA_HOME\jre\lib\security\java.policy" прописать строки производителя ПО:
```bash
    > keystore "file:E:/TEMP/TEST/JAR/.keystore";
    > grant {
    >     permission java.io.FilePermission "C:/AUTOEXEC.BAT", "read", signedBy "Vingrad";
    > };
    то пользователю не будет выдаваться запросов и предупреждений JAVA-приложение сразу получит права на все разрешения...
```
9.1 Если запустить JAR-файл как аплет в веб-броузере и ответить "ДА"
```bash
    > в этом случае при загрузке апплета веб-броузер задаст вопрос: "доверяете ли вы данной подписи"
```
9.2 И потом этот подписанный сертификат "vingrad.sf" сохраниться в веб-браузере
```bash
    > "Панель управления" > "Java Plug-In" > "Sertificates" > и там появился наш сертификат (vingrad.sf)
```

* Сертификат является способом распространения публичного ключа шифрования
* Сертификат регламентируется стандартом `X.509`
* Сертификат состоит:
  - из Public-ключа
  - вместе с некоторой идентифицирующей владельца информацией
  - и даты прекращения срока действия ключа
  - также содержит цифровую подпись организации выдавшей сертификат (certificate authority CA)

На практике формат сертификатов таков что в сертификат может входить множество подписей.
Последний сертификат (root-сертификат) в цепочке (удостоверяющий подлинность публичного ключа CA) сам является самоподписанным.
Каждый сертификат в цепочке подтверждает подлинность публичного ключа предыдущего сертификата в цепочке.
  
Если клиент шифрует сообщение публичным ключом сервера (из сертификата сервера) огда клиент может быть уверен что только легальный сервер сможет расшифровать сообщение.
В процессе установления SSL/TLS сессии клиент создает часть сессионного ключа, шифрует сообщение с помощью публичного ключа сервера и передает на сервер.
Если сервер тот за кого себя выдает он сможет расшифровать сообщение с помощью приватного ключа и достать из сообщения сессионный ключ.


1. Конфигурируем SSL-коннектор (server.xml), добавляем:
```xml
   <Connector port="8443" SSLEnabled="true" maxHttpHeaderSize="8192" 
        maxThreads="150" minSpareThreads="25" maxSpareThreads="200"
        enableLookups="false" disableUploadTimeout="true"         
        acceptCount="100" scheme="https" secure="true"
        clientAuth="false" sslProtocol="TLS"
        keystoreFile=".keystore" keystorePass="mystorepassword" keystoreType="JKS"
        keyAlias="tomcat"/>
```
2. Закомментируем строки:
```xml
   <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
   <Listener className="org.apache.catalina.mbeans.ServerLifecycleListener" />
```
   шифрование уже работает!
3. **Двухфазный SSL** — авторизация на сайте по сертификату. Механизм проверки очень прост:
   - необходимо чтобы у сервера нашелся ключ "subject distinguished name" у который будет совпадать с "issuer distinguished name" проверяемым ключем (при этом клиент не обязательно должен обладать таким ключом потому-что можно в диалоговом режиме подтвердить доверие)
     - Когда используются ключи, выданные центром сертификации, у нас уже есть публичный ключ центра и свой, подписанный этим центром.
     - В случае с самоподписанным ключом (именно такие ключи по создаёт keytool) необходимо, чтобы публичный ключ используемый клиентом, был в truststore сервера.
   Чтобы настроить двухсторонюю аутентификацию нужно иметь два сертификата: от сервера и от клиента. Оба сертификата нужно импортировать в хранилище сертификатов на стороне сервера И при этом сертификат сервера сделать доверенным для    сертификата клиента.
   - Итак пускай и сервер и клиент уже имеют собственные приватные ключи.
   - создаем хранилище сертификатов/ключей и формируем CSR-запрос (публичный ключ) для сервера
```bash
     > keytool -genkey -alias tomcat -keyalg RSA -keystore mystore -validity 999 -keysize 512
```
   - теперь (аналогично) создаем хранилище сертификатов/ключей и формируем CSR-запрос (публичный ключ) для клиента
```bash
     > keytool -genkey -alias client -keyalg RSA -keystore myclientstore -storetype PKCS12 -validity 999 -keysize 512
```
   - помещаем публичный ключ в доверенное хранилище (truststore) сервера
```bash
     > keytool -export -alias client -keyalg RSA -keystore myclientstore -storetype PKCS12 -file clientcert
```
   - оба хранилища ключей/сертификатов ("mytruststore" и "mystore") ложим-копируем где лежит сервер приложений
   - Конфигурируем SSL-коннектор (server.xml):
```xml
   <Connector port="8443" SSLEnabled="true" maxHttpHeaderSize="8192" 
        maxThreads="150" minSpareThreads="25" maxSpareThreads="200"
        enableLookups="false" disableUploadTimeout="true"
        acceptCount="100" scheme="https" secure="true"
        clientAuth="true" sslProtocol="TLS"
        keystoreFile="mystore" keystorePass="123456" keystoreType="JKS"
        keyAlias="tomcat"
        truststoreFile="mytruststore" truststorePass="123456" truststoreType="JKS"/>
```

###Шифрование канала

HTTP-протокол предназначен для работы по открытому каналу для передачи данных (без защиты) по принцыпу запрос/ответ (для незащищенного HTTP использует 80 TCP-порт).
HTTPS-протокол (изначально защита канала передачи данных для HTTP-протокола непредусмотрена) для этого была разработана дополнительная надстройка шифрования канала для безопасного способа передачи данных (для защищенного HTTPS использует 443 TCP-порт).

* `SSL` ....... семейство протоколов для установки шифрованного соединения между двумя сторонами желающими обмениваться данными (альтернативой ему является, например, TLS);
                это обмен в процессе которого соединяющиеся стороны договариваются какие механизмы шифрования каждый из них поддерживает
* `RSA` ....... обмен ключами/аутентификация ключей (альтернатива – PSK);
* `RC4_128` ... алгоритм шифрования сообщений и длина ключа (альтернатива –  CBC);
* `MD5` ....... аутентификация/проверка целостности сообщения (альтернатива – SHA);


Полезные утилиты:
- OpenSSL (самая распространенная утилита для генерации открытого ключа (запроса на сертификат) и закрытого ключа)
- CSR Decoder (утилита для проверки CSR и данных, которые в нем содержаться, рекомендую использовать перед заказом сертификата)
- DigiCert Certificate Tester (утилита для проверки корректно самого сертификата)


###Java Authentication and Authorization Service (JAAS)

( *`Аутентификация` ... проверка на существование человека(зарегистрированного) в нашем приложении (является ли он тем, за кого себя выдает)* )
( *`Авторизация` ...... проверка прав аутентифицированного пользователя выполнять конкретные действия* )
* **User** ............. пользователь, информация о человеке, которая храниться у нас в базе или файле
* **Group** ............ группа пользователей,  которая имеет одинаковые характеристики и права доступа
* **Security Realm** ... специальная область отвечающая за аутентификацию пользователя и хранит ее настройки
* **Role** ............. определяет уровень доступа. Определяет какие действия может выполнять пользователь или группа

* В области безопасности `логин/пароль` и `сертификаты` это абсолютно разные и независимые вещи:
  - Каждый `логин/пароль` является приватной информацией польователя, которая служит для аудитенфикации этого пользователя на стороне сервера (каждый пользователь имеет персональный "логин/пароль" - **Principial**)
    - Каждый пользователь принадлежит конкретной группе на стороне сервера. *`Группа` — управляет правилами доступа к данным на уровне всего сервера/домена* (не пользователь...)
    - А *`ролли` — управляет правилами доступа к данным уже на уровне для отдельного приложения/функции/рессурса*...
  - Тогда как *`сертификат` — является доручителем прав доступа к данным, позволяет обращаться между клиентом и сервером в зашифрованом виде* (то есть, существует только один оригинал обладающими правами И существуют много его проучителей которые обладают полномочиями... - это и заложено в идеологию электронной подписи)


1. Добавить пользователя у которого будет право на просмотр скрытой информации (это в настройках сервера приложений либо файл либо база данных, например: для сервера приложений 'Tomcat' это можно сделать в 'conf/tomcat-users.xml')
```xml
     <role rolename="admin"/>
     <role rolename="manager"/>
     <user username="user" password="123456" roles="manager"/>
     <user username="admin" password="12345678" roles="admin,manager"/>
```
2. Аутентификация (это в настройках веб-приложения делаем в WEB-INF/web.xml. 'login-config' - конфигурация аутентификации; 'auth-method' - каким методом проводить аутентификацию;)
   Существует 4-е метода аутентификации:
   1. BASIC ......... используется стандартная форма ввода данных
```xml
       <login-config>
           <auth-method>BASIC</auth-method>
       </login-config>
```
   2. FORM .......... используем свою html форму
```xml
       <login-config>
           <auth-method>FORM</auth-method>
           <form-login-config>
               <form-login-page>/login.html</form-login-page>
               <form-error-page>/error.html</form-error-page>
           </form-login-config>
       </login-config>
       Создаем форму (в HTML-страничке. 'j_security_check' - action при нажатии на submit; 'j_username' - поле имя пользователя; 'j_password' - поле пароля):
       <form action="j_security_check" method="post">
           Input for username <input name="j_username" type="text"> <br>
           Input for password <input name="j_password" type="password"> <br>
           <input type="submit" value="Авторизироваться">
       </form>
```
   3. DIGEST ........ цифровая аутентификация
   4. CLIENT-CERT ... с помощью клиентского сертификата
3.1 Настройка безопасности для веб-приложения (это в настройках веб-приложения делаем в WEB-INF/web.xml. 'security-constraint' - блок ограничений безопасности; 'web-resource-collection' - ресурсы, к которым стоит закрыть доступ; 'url-pattern' - запрос к которому будет применен фильтр безопасности; 'http-method' - метод к которому применим фильтр безопасности; 'security-role' - прописываем роль; 'role-name' - указываем роль; 'auth-constraint' - выставляем роли доступа;)
```xml
       <web-app ...>
           <security-constraint>
               <web-resource-collection>
                   <web-resource-name>secured</web-resource-name>
                   <url-pattern>/secured/*</url-pattern>
                   <http-method>GET</http-method>
                   <http-method>POST</http-method>
               </web-resource-collection>
               <auth-constraint>
                   <role-name>MANAGER</role-name>
               </auth-constraint>
           </security-constraint>
           <security-role>
               <role-name>MANAGER</role-name>
           </security-role>
       </web-app>
```
3.2 Дополнительно использование безопасности в сервлетах (это в настройках класса-сервлета. '@ServletSecurity' - определяет настройки безопасности; '@HttpMethodConstraint' - ограничения для каждого метода доступа; 'value' - http method (GET,POST..); 'rolesAllowed' - роль которая может получить доступ;)
```javascript
       @WebServlet(urlPatterns = "/servlet2")
       @ServletSecurity(httpMethodConstraints = {
           @HttpMethodConstraint(value = "GET", rolesAllowed = "MANAGER"),
           @HttpMethodConstraint(value = "POST", rolesAllowed = "MANAGER")
       })
       public class SecuredServlet2 extends HttpServlet{
           @Override
           protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
               resp.getWriter().write("<h1>Secured Servlet2</h1>");
           }
       }
```

Для связки в зависимости от сервера в приложении используется специальный файл в директории `WEB-INF` который имеет название '*-web.xml'
Например:
- для JBoss, WildFly ... jboss-web.xml (WEB-INF/jboss-web.xml)
- для GlassFish ........ sun-web.xml   (WEB-INF/sun-web.xml)
```xml
    <jboss-web>
        <security-domain>java:/jaas/other</security-domain>
    </jboss-web>
```











* Существует много цифровых сертификатов которые служат для своих целей:
  - SSL сертификаты (защищенное https соединение для веб-сайта)
  - Code Signing сертификаты
  - Website Anti Malware Scanner сертификаты
  - Unified Communications сертификаты
* Самый простой и бесплатный способ получить SSL сертификат:
  - это использовать самоподписный сертификат (можно сгенерировать на веб-сервере, в самых популярных панелях управления хостингом "Cpanel", "ISPmanager", "Directadmin" эта возможность доступна по умолчанию).

* Центров сертификации существует достаточно много, вот перечень самых популярных:
  - "Comodo" (работает с 1998 штабквартира в Jersey City, New Jersey, США)
  - "Geotrust" (основан в 2001, в 2006 продан Verisign, штабквартира Mountain View, California, США)
  - "Symantec" (бывший Verisign в состав которого входит и Geotrust. Купил всех в 2010 году)
  - "Thawte" (основан в 1995, продан Verisign в 1999)
  - "Trustwave" (работает с 1995, штабквартира Chicago, Illinois, США)
Основное отличие между разными центрами сертификации — в цене и в каком количестве браузеров установлен их корневой сертификат (если в браузере нет корневного сертификата этого центра сертификации то посетитель с таким браузером все равно получит ошибку при входе на сайт с сертификатом от такого центра).

* ПОДПИСАНИЕ КОДА ДЛЯ НАСТОЛЬНЫХ КОМПЬЮТЕРОВ:
  - Сертификаты подписания кода для Microsoft Authenticode (файлы .exe, .cab, .dll, .ocx, .msi, .xpi, .xap и ПО в режиме ядра)
  - Сертификаты подписания кода для Java (к файлам .jar и подписание объектов Netscape)
  - Сертификаты подписания кода для Microsoft Office и VBA (для объектов VBA и макросов. Для ПО Microsoft Office)
  - Сертификаты подписания кода для Adobe AIR (к файлам .air или .airi)
* ПОДПИСАНИЕ КОДА ДЛЯ МОБИЛЬНЫХ УСТРОЙСТВ:
  - Сертификаты подписания кода для Windows Phone (для приложений Windows Phone и Xbox 360)
  - Подписание кода для Android (файлов .apk)
  - Authentic Document IDs for Brew (к приложениям Brew)
