[Markdown: Help](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)

* **(** [Java.Test](Java.Test.txt) **)**
* [Коллекции](Коллекции.md)
* [Базы данных](Базы%20данных.md) **(** [JPA и Hibernate в вопросах и ответах](https://habrahabr.ru/post/265061) **|** [PowerDesigner](novye_vozmozhnosti_pd_16_5.pdf) **)**
* [Design Patterns](Design%20Patterns.md)
* [Исключения в Java](Исключения%20в%20Java.md) **(** [TryCatchFinaly](https://github.com/Home-Spring/SpringFileUpload2/blob/master/src/test/java/com/journaldev/spring/TryCatchFinaly.java) **)**
* [что нового в java-8](что%20нового%20в%20java-8.md)  **|** [Java8.2](https://github.com/Home-Java8/Java8.2)  **(** [Краткий список нововведений в Java 8](http://microfork.com/whats-new-in-java-8/) **)**
* [различие между oauth-1 и oauth-2](различие%20между%20oauth-1%20и%20oauth-2.md)
* [Аспектно-Ориентированном Программирование](АОП.md) **(** [Знакомство с АОП](https://habrahabr.ru/post/114649) **|** [Spring АОП](http://www.finecosoft.ru/spring-aop) **)**
* **(** [Home-Spring/docs](https://github.com/Home-Spring/docs) **|** spring управлять бинами на лету через xml: [1](https://habrahabr.ru/company/haulmont/blog/248981) **|** [2](https://habrahabr.ru/post/106744) **|** [3](http://java-course.ru/student/book2/spring) **|** [4](http://spring-projects.ru/guides/lessons/lesson-2) **|** [5](https://habrahabr.ru/post/228953) **)**
* [Аббревиатура SOLID](https://web-creator.ru/articles/solid) **(** `эти принципы позволяют строить на базе ООП масштабируемые ПО с понятной бизнеслогикой` **)**

    1. Принцип единственной обязанности (Single responsibility) `обозначает что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.`
    2. Принцип открытости / закрытости (Open-closed) `декларирует что классы, модули, функции должны быть открыты для расширения, но закрыты для изменения (это означает что эти сущности могут менять свое поведение без изменения их исходного кода).`
    3. Принцип разделения интерфейса (Interface segregation) `гово­рит о том, что слишком толстые интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах которые необходимы им в работе (в итоге при изменении метода-интерфейса не должны меняться клиенты которые этот метод не используют).`
    4. Принцип инверсии зависимостей (Dependency inversion) `модули верхних уровней не должны зависеть от модулей нижних уровней, а оба типа моду­лей должны зависеть от абстракций.`
    5. Принцип подстановки Барбары Лисков (Liskov substitution) `функ­ции которые используют базовый тип должны иметь возможность использовать подтипы базового типа не зная об этом.`

![Аббревиатура SOLID](5e55695664a7484684759f990e20dbdf.png)

     При обычной рекурсии - в теле функции остается лежать текущее значение переменной.
     И каждый раз когда функция вызывает саму-себя - клонируется тело этой функции, но уже с другим значением переменной.
     И таких клонов может быть безконечное количество - именно это услоие (наличие безконечного количества клонов) и приводит к переполнение стэка.

```javascript
    static int func(int n){
        if(n==0) return 0;
        return n + func(n-1); //return n+func(--n); //return n+func(n--);
    }
```


     В хвостовой рекурсии - в теле функции никакие переменные вообще не храняться!
     Все значения для переменных передаются только в параметрах функции.
     В теле самой-же функции лежит только оператор-возврата значения. А все значения вычисляются на уровне, в момент передачи параметров.
     То есть, каждый раз когда функция вызывает саму-себя старое тело функции уничтожается! И поэтому клон функции будет всегда один (это значит что переполнения стэка никогда не наступит)

```javascript
    static int add(int nun, int step){
        if(step==0) return nun; //return 1;
        return add((nun+(step-1)), step-1);
    }
```


     Функции высшего порядка - это функция которая принимает в качестве аргументов другие функции или возвращает в качестве результата другую функцию.
     ( Идея состоит в том что функции имеют такой-же статус как и другие объекты данных.
       Использование функций высшего порядка приводит к абстрактным и компактным программам... )

```javascript
    Function<Integer, Integer> f = x -> x + 3;
    BiFunction<Function<Integer, Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
    System.out.println(g.apply(f, 7));
```


     Каррирование - это преобразование функции со многими аргументами в набор функций каждая из которых имеет по одному аргументу.

     Замыкание - ( является глобальной переменной ) это когда в теле функции присутствуют ссылки на переменные которые объявленные вне тела этой функции.

