
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>                           (Spring изнутри. Этапы инициализации контекста) https://habrahabr.ru/post/222579/
>> (Управление bean-компонентами Spring при конфигурировании на основе Java) http://www.ibm.com/developerworks/ru/library/ws-springjava/
>>                                         (Введение в Spring IoC контейнер) http://spring-projects.ru/guides/lessons/lesson-2/

>>                                                (Вопросы и ответы на собеседование по теме Spring Framework. Часть 1) http://javastudy.ru/interview/jee-spring-questions-answers/
>>                                                (Вопросы и ответы на собеседование по теме Spring Framework. Часть 2) http://javastudy.ru/interview/jee-spring-questions-answers-2/
>>                                                                             (Spring MVC — локализация (выбор языка)) http://javastudy.ru/spring-mvc/localization/
>>                                                                                          (фреймворк Spring Security) http://javastudy.ru/frameworks/spring/spring-security/
>>                        (Spring Security — пример приложения Hello World. Базовые настройки. Spring Security example) http://javastudy.ru/spring-security/spring-security-helloworld/
>>                           (Spring Security — создание группы ролей (group authorities). Создание таблиц базы данных) http://javastudy.ru/spring-security/spring-security-group-authorities/
>>                                                                 (Spring Security — защита методов (method security)) http://javastudy.ru/spring-security/spring-security-method-security/
>> (Spring Security — username password remember me (сохранение пароля пользователя для автоматической аутентификации)) http://javastudy.ru/spring-security/spring-security-remember-me/

>>              (@SessionAttributes. Сессия в Spring MVC) http://www.seostella.com/ru/article/2012/04/26/sessionattributes-sessiya-v-spring-mvc.html
>> (Использование SessionAttributes в Spring MVC проекте) https://habrahabr.ru/post/199048/
>>
>>       (Spring Framework логгирование входа и выхода пользователей) https://urvanov.ru/2015/12/21/spring-framework-логгирование-входа-и-выхода-польз/
>> (Spring Security 3.1: получение списка залогиненных пользователей) http://barbitoff.blogspot.com/2012/10/spring-security-31.html
>>
>> (Spring Security: сброс сессии определенного пользователя) http://barbitoff.blogspot.com/2012/10/spring-security.html

>>   (Краткий обзор Spring Security) http://www.quizful.net/post/spring-security
>> (Как получить юзера после логина) http://ru.stackoverflow.com/questions/350516/Как-получить-юзера-после-логина
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


>> (Spring изнутри. Этапы инициализации контекста) https://habrahabr.ru/post/222579/
    ---------------------------------------------[SPRING CORE]
'BeanDefinition' ... парсирование конфигурации:
                     XmlBeanDefinitionReader получает InputStream и загружает Document через DefaultDocumentLoader.
					 Далее обрабатывается каждый элемент документа и если он является бином, то создается BeanDefinition на основе заполненных данных (id, name, class, alias, init-method, destroy-method и др.).
					 Каждый BeanDefinition помещается в Map. Map хранится в классе DefaultListableBeanFactory.
'BeanFactory' ...... занимается созданием экземпляров бинов.
При конфигурировании на основе Java у нас имеется класс 'AnnotationConfigApplicationContext'.

'ApplicationContext' ... предоставляет базовую функциональность для управления и манипуляции бинами, включая программным способом.

В Java программе (интерфейс) 'ApplicationContext' можно создать следующим образом:
- 'AnnotationConfigApplicationContext' ... при использовании Spring в качестве автономного приложения можно создать, инициализировать контейнер с помощью аннотаций.
- 'ClassPathXmlApplicationContext' ....... второй подход использует xml файл, в котором задаются необходимые настройки, а затем используем класс для загрузки файла и получения объекта контейнера.
- 'FileSystemXmlApplicationContext' ...... аналогичен варианту с xml, но с возможностью загрузки файла конфигурации из любого места файловой системы.
После выхода четвертой версии спринга, у нас появилось четыре способа конфигурирования контекста:
1. Конфигурация через аннотации с указанием пакета для сканирования .............................................. AnnotationConfigApplicationContext(“package.name”)
2. Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration ... AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.
3. Xml конфигурация .............................................................................................. ClassPathXmlApplicationContext(“context.xml”)
4. Groovy конфигурация ........................................................................................... GenericGroovyApplicationContext(“context.groovy”)

Бин в Spring используется для ссылки на любой компонент, управляемый контейнером.
Существует несколько способов работы с классами как Spring Bean (XML конфигурация, Java based конфигурация, Annotation based конфигурация)
В Spring предусмотрен дополнительный механизм связывания @Autowired (чтобы аннотация заработала необходимо указать настройки в конфигурационном файле спринг 'context:annotation-config').
По умолчанию бин задается как 'синглтон' в Spring. Таким образом все публичные  переменные класса могут быть изменены одновременно из разных мест. Поэтому Spring Bean не является потокобезопасным.
Однако поменяв область действия бина на: 'request', 'prototype', 'session' - он станет потокобезопасным (но это скажется на производительности).


>> (Вопросы и ответы на собеседование по теме Spring Framework. Часть 1) http://javastudy.ru/interview/jee-spring-questions-answers/
                                                                         http://javastudy.ru/interview/jee-spring-questions-answers-2/
   (Управление bean-компонентами Spring при конфигурировании на основе Java) http://www.ibm.com/developerworks/ru/library/ws-springjava/
    -----------------------------------------------------------------------[SPRING MVC]
Основным контроллером в Spring MVC является 'org.springframework.web.servlet.DispatcherServlet'. Задается аннотацией @Controller

Для указания контейнеру на класс-бин можно использовать любую из этих аннотаций. Но различные имена позволяют различать назначение того или иного класса:
- @Component используется для указания класса в качестве компонента спринг. При использовании поиска аннотаций, такой класс будет сконфигурирован как spring bean.
- @Controller специальный тип класса, применяемый в MVC приложениях. Обрабатывает запросы и часто используется с аннотацией @RequestMapping.
- @Repository указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DAO.
- @Service указывает, что класс является сервисом для реализации бизнес логики (на самом деле не отличается от Component, но просто помогает разработчику указать смысловую нагрузку класса).

В традиционном XML-подходе для загрузки внешнего XML-файла контекста приложения вы использовали бы класс 'ClassPathXmlApplicationContext'.
'DispatcherServlet' ....... является центральным сервлетом, который получает запросы и направляет их соответствующим контроллерам. В приложении Spring MVC может существовать произвольное количество экземпляров DispatcherServlet, предназначенных для разных целей
                            DispatcherServlet имеет собственную конфигурацию 'WebApplicationContext' - которая определяет характеристики уровня сервлета, такие как контроллеры, поддерживающие сервлет, отображение обработчиков, распознавание представлений, интернационализация, оформление темами, проверка достоверности, преобразование типов и форматирование...
'ContextLoaderListener' ... слушатель при старте и завершении корневого класса Spring 'WebApplicationContext'
                            Основным назначением является связывание жизненного цикла ApplicationContext и ServletContext, а так же автоматического создания ApplicationContext.

Минимальные настройки, чтобы создать приложение Spring MVC:
- Добавить зависимости spring-context и spring-webmvc в проект.
- Указать DispatcherServlet в web.xml для обработки запросов внутри приложения.
- Задать определение spring bean (аннотацией или в xml). Добавить определение view resolver для представлений.
- Настроить класс контроллер для обработки клиентских запросов.

Spring MVC Framework и архитектуру MVC:
- Моделью (Model) .................. выступает любой Java bean в Spring. Внутри класса могут быть заданы различные атрибуты и свойства для использования в представлении.
- Преставление (View) .............. JSP страница, HTML файл и т.п. служат для отображения необходимой информации пользователю. Представление передает обработку запросов к диспетчеру сервлетов (контроллеру).
- DispatcherServlet (Controller) ... это главный контроллер в приложении Spring MVC, который обрабатывает все входящие запросы и передает их для обработки в различные методы в контроллеры.

'ViewResolver' ................... распознаватель представлений. поддерживает распознавание представлений на основе логического имени, возвращаемого контроллером (XML, PDF, JSON, Velocity, JasperReports, и т.д.).
'InternalResourceViewResolver' ... реализация ViewResolver

'MultipartResolver' ............................................... используется для загрузки файлов
'CommonsMultipartResolver' и 'StandardServletMultipartResolver' ... Существуют две реализации MultipartResolver, которые позволяют фреймворку загружать файлы.
                                                                    По умолчанию этот интерфейс не включается в приложении и необходимо указывать его в файле конфигурации.

Spring Framework позволяет создавать Restful веб сервисы и возвращать данные в формате JSON. Spring обеспечивает интеграцию с Jackson JSON API для возможности отправки JSON ответов в restful web сервисе.
В контроллере указать с помощью аннотации @ResponseBody возвращение Object


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

<form-login login-page="/login.jsp" authentication-failure-url="/login.jsp?login_error=1"/>
<access-denied-handler error-page="/accessDenied.jsp"/>
<http-basic/>
<logout logout-success-url="/exitUser.jsp"/>

Authentication auth = SecurityContextHolder.getContext().getAuthentication();
if (!(auth instanceof AnonymousAuthenticationToken)) {
	UserDetails userDetails = (UserDetails) auth.getPrincipal();
}


public String home( HttpSession httpSession ) {
	httpSession.setAttribute("person", new Person("John") );
	httpSession.setAttribute("sheldon", new Sheldon() );
	return "home";
}
@SessionAttributes({"person", "sheldon"})

@SessionAttributes(types = TicketForm.class)

modelAndView.addObject( person );
modelAndView.addObject( sheldon );

model.addAttribute(new TicketForm());

public String confirmation(SessionStatus status) {
	status.setComplete();
	return "booking/confirmation";
}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Core (Dependency Injection):
---------------------------
Spring имеет такой себе контейнер который управляет жизненным цыклом бина (а бин '@Bean' является классом-сущности что хранит в себе состояние объекта...).
А также контейнер расширяет области видимости для жизненного цыкла бина (scope: singleton, prototype, request, session, global-session)
- Сперва контейнеру нужно сконфигурировать бины (через BeanDefinition)
- и только потом создать их выдать эти бины по востребованию (через BeanFactory)
Полученный на выходе бины обладают расширенными свойствами и по конфигурации и по области видимости (в отличие от обычных java-объектов...)

Первым делом нужно подключить загрущик 'LoaderContextListner', который будет с самого начала существования приложения прослушивать его сосояние создавать бины, через '@ConfigurationScan' ('@Configuration')...
После этого станут доступны аннотации (@PostConstruct и @PreDestroy, @Autowired и @Qualifier) для конфигурирования и управления жизненным циклом бина

Дальше можно запросить/загрузить бин у контейнера через 'AnnotationConfigApplicationContext'
! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !
В Spring-CORE
-------------
> ApplicationContext - предоставляет базовую функциональность для управления и манипуляции бинами.
  Иинтерфейс 'ApplicationContext' можно создать через: 'AnnotationConfigApplicationContext', 'ClassPathXmlApplicationContext', 'FileSystemXmlApplicationContext'.
  (BeanDefinition - парсирование конфигурации; BeanFactory - занимается созданием экземпляров бинов;)
> Загрущик LoaderContextListner - связывает жизненный цикл ApplicationContext и ServletContext
  (После этого станут доступны аннотации: @PostConstruct и @PreDestroy, @Autowired и @Qualifier для управления жизненным циклом бина)
- - - - - - -
То есть, в случае при иннициализации полей через @Autowired для создаваемого объекта-бина - эти поля НЕбудут проинициализированы (NullPointerException) БЕЗ загрущика LoaderContextListner.

В Spring MVC
-------------
> DispatcherServlet - является центральным сервлетом, который получает запросы и направляет их соответствующим контроллерам.
  (Помимо 'DispatcherServlet' существует основной/центральный Front-контроллер, который слушает и разпределяет все клиентские запросы на другие контроллеры..)
- - - - - - -
То есть, БЕЗ DispatcherServlet клиентские запросы НЕмогут быть доставлены на наши контроллеры: @Controller или @RestController
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

MVC (Component):
---------------
Model-View-Controller имеет слоистую архитектуру для веб-приложения, которая отвечает за выполнение разных требований (доменный слой, ДАО-слой, сервисный слой, слой представления, веб-слой).
Управляет этими слоями менеджер 'DispatcherServlet'...

Поэтому в MVC каждый бин является компонентом (@Component).
Но чтобы лоическим разделить все компоненты по слоям для этого применяются наследники от (@Component): @Service, @Repository, @Controller


---------------
Реализация Spring-MVC автоматически/НЕявно (уже из коробки) способна поддерживать управление разными слоями:
- диспетчер клиентских-запросов: контроллер (веб-методы) для сервлетов
- распознание/конвертирование данных Модель (json, html)
- автоматический фильтер (ловит: html, htm и перенаправляет на другой обработчик jsp)
- втроенный ексепшин (в случае ошибки перенаправляет на страницу-предупреждения с типовой ишобкой)
- представление (позволяет возвращать данные в форматах: json, html)
- встроенная защита (инструмент который реализует всю логику по: правам доступа, защите веб-ресурсов, способа входа/выхода, ...)
- поддержка сессий (механизм который: создает-удаляет сессию, ложит-удаляет объекты из сессии)





+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>                                 (Руководство по Spring. Введение) http://proselyte.net/tutorials/spring-tutorial-full-version/introduction/
>>                         (Урок 2: Введение в Spring IoC контейнер) http://spring-projects.ru/guides/lessons/lesson-2/
>>                   (Spring изнутри. Этапы инициализации контекста) https://habrahabr.ru/post/222579/
>>                   (Евгений Борисов — Spring-потрошитель, часть 1) https://www.youtube.com/watch?v=BmBr5diz8WA
>>                   (Евгений Борисов — Spring-потрошитель, часть 2) https://www.youtube.com/watch?v=cou_qomYLNU
>> (Простое Spring приложение с использованием аннотации @Autowired) http://dev-blogs.com/simple-spring-application-using-autowired-annotation/
>>                        (Введение в Spring Security. Hello World!) http://www.seostella.com/ru/article/2012/06/27/vvedenie-v-spring-security-hello-world.html
>>                     (Retrofit — библиотека для работы с REST API) http://java-help.ru/retrofit-library/
>>         (Spring для домохозяек. Inversion of Control на практике) http://nikcode.blogspot.com/2011/09/spring-inversion-of-control.html

>> (Создание собственных аннотаций - Annotations #1 - Advanced Java) https://www.youtube.com/watch?v=9BbxPd3GPeU
>> (Аннотации в Java) http://easy-code.ru/lesson/java-annotations
>> () http://www.quizful.net/post/annotations-in-java
>> () http://www.seostella.com/ru/article/2012/05/19/annotacii-v-java-vvedenie.html
>> () http://www.seostella.com/ru/article/2012/05/20/annotacii-v-java-target.html
>> () http://www.seostella.com/ru/article/2012/05/21/annotacii-v-java-retention.html
>> () http://www.seostella.com/ru/article/2012/05/22/annotacii-v-java-documented.html
>> (Аннотации в Java, часть I) https://habrahabr.ru/company/golovachcourses/blog/217595/
>> () https://habrahabr.ru/post/139736/
>> (Конфигурации для аннотации) http://devcolibri.com/1253
>> (Руководство по аннотациям в Java) http://prologistic.com.ua/rukovodstvo-po-annotatsiyam-v-java.html
>> () http://java-online.ru/java-annotation.xhtml
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Создание объекта для Java-класса происходит в несколько этапов:
1. В Java-классе присутствуют поля, которые могут быть либо пустими (NULL) либо уже проинициализированными (во время их объявления).
   Это и есть прототип объекта Java-класса...
2. Когда вызывается конструктор, при этом создается новый экземпляр объекта.
   При вызове конструктора, в его теле можно изменять исходные значение для полей Java-класса (то есть, делать повторную иннициализацию объекта).
3. Этот описанный процесс выполняется автоматически JVM-компилятором.
   Но в этот процесс компиляции можно вклинится и управлять внутри него до того момента когда будет создан Java-объект.
   Такое вклинивание в процесс компиляции возможно с помощю аннотаций...
   Идея применения аннотаций заключается в том чтобы выполнить предварительное тестирование программного кода, перед сборкой-компиляцией проэкта.

Spring-контейнер (из 'Spring Core') представляет собой аналогом JVM-компилятора.
И точно также внутреняя архитектура Spring-контейнер позволяет вклинится в процесс компиляции Java-программы для выполнения предварительных действий, перед созданием Java-объекта.
- изначально все Class-файлы загружаются в 'BeanDifinishion' и храняться там временно просто как прототип объекта Java-класса.
- следующим стоит 'BeanPostProcessor', который вклинивается в процесс компиляции и может предварительно (еще до вызова конструктора) делать иннициализацию полей Java-класса.
- после этого 'BeanFactory' берет-сканирует все прототипы Java-класса и по всем его конструкторам делает-конфигурирует объекты и создает экземпляры от прототипов Java-класса.
- в конце, в результате работы 'BeanFactory' складывает уже готовые экземпляры объектов от прототипов Java-классов в 'IoContainer'
- далее все готовые экземпляры объектов в 'IoContainer' уже на выходе из IoContainer-а наделяются правилом которое описывает область жизненного цикла (singleton, prototype, application, request, ...)


Все аннотации Spring-а которые вклиниваются в процесс компиляции типа: @PostConstruct, @PreDestroy, @Autowired, @Qualifier, ... - выполняются BeanPostProcessor-ом...
И например аннотация '@Autowired', которая служит для поиска и подключени зависимостей тоже работает с помощью BeanPostProcessor-а.
За это отвечает 'context:annotation-config'...

'AnnotationConfigApplicationContext' использует Spring-контейнер для загрузки Java-классов в BeanDifinishion и создание бинов BeanFactory-ом.
Обычно в контекстном файле Spring-а подключаются и конфигурируются все бины.
За это отвечает 'ContextLoaderListener' (он используется на уровне 'Spring Core'...)

А на уровне 'Spring MVC' существует основной контроллер 'DispatcherServlet' - который отвечает за управление всеми компонентами Spring-MVC типа: @Component, @Controller, @Repository, @Service





++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

>> (Синхронизация потоков) http://www.skipy.ru/technics/synchronization.html
Итак, резюме. Если два нестатических метода объявлены как synchronized, то в каждый момент времени из разных потоков на одном объекте может быть вызван только один из них. Поток, который вызывает метод первым, захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:
•Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст.
•Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст
•В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.
Еще одно замечание. Объекты класса Class существуют в единственном экземпляре только в пределах одного ClassLoader-а. Следовательно, если вы установите контекстный загрузчик классов потоку – у разных потоков могут быть разные экземпляры одного и того же класса Class и, следовательно, будет возможен одновременный вызов синхронизированных статических методов. Если эти методы используют одни и те же ресурсы – это может вызвать проблемы.

>> (Синхронизация потоков, блокировка объекта и блокировка класса) http://info.javarush.ru/CynepHy6/2014/10/27/%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0-%D0%B8-%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0.html
4. synchronized в Java реентерабельна это означает, что если синхронизированный метод вызывает другой синхронизированный метод, который требует такой же замок, то текущий поток, который держит замок может войти в этот метод не приобретая замок.
8. В соответствии со спецификацией языка вы не можете использовать synchronized в конструкторе это приведет к ошибке компиляции.
9. Не синхронизируйте по не финальному (no final) полю, потому что ссылка, на не финальное поле может измениться в любое время, а затем другой поток может получить синхронизацию на разных объектах и уже не будет никакой синхронизации вообще. Лучше всего использовать класс String, который уже неизменяемый и финальный.

>> http://www.sql.ru/forum/1065436/potoki-i-staticheskie-metody
>> (Собеседование по Java — многопоточность (вопросы и ответы)) http://javastudy.ru/interview/concurrent/
>> http://java-course.ru/begin/static/

>> (Как ведет себя static метод в многопоточном приложении?) http://ru.stackoverflow.com/questions/19452/%D0%9A%D0%B0%D0%BA-%D0%B2%D0%B5%D0%B4%D0%B5%D1%82-%D1%81%D0%B5%D0%B1%D1%8F-static-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4-%D0%B2-%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D0%BC-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8

public class Singleton{
    private static Cat cat = new Cat();
    public static Cat getInstance(){
           return cat;
    }
}
Получается, что вы можете получать экземпляр класса Cat через Singleton, а можете просто создавать через new Cat сколько угодно, что будет неверно и вы никак не сможете от этого защититься. Поэтому надо делать
public class Cat {
    private static final Cat cat = new Cat();
    public static Cat getInstance(){
           return cat;
    }
}
При таком раскладе достигается эффективная потокобезопасность и получена ленивая инициализация (lazy-load singleton).
public class Cat{
        private Cat() {
        }

        private static class LazyHolder {
                private static final Cat INSTANCE = new Cat();
        }

        public static final Cat getInstance() {
                return LazyHolder.INSTANCE;
        }
}

2) Использование synchronized static метода абсолютно равносильно использованию объекта класса как мьютекса. Следующие два метода работают идентично:
class Example{
    static void foo(){
        synchronized(Example.class){
            //method body
        }
    }
    synchronized static void bar(){
        //method body
    }
}
3) Без использования synchronized в методе или с методом вызов его кода никак не отличается в плане многопоточности от вызова обыкновенного метода.

Здесь действительно будут проблемы с многопоточностью. Поэтому для любых неатомарных операций стоит использовать модификатор synchronized.
public static Cat getInstance(){
       if (cat == null) cat = new Cat();
       return cat;
}

С точки зрения многопоточности нет разницы между статическим и нестатическим методом, если он не помечен как synchronized.


>> (Загрузка классов в Java. Теория) https://habrahabr.ru/post/103830/
Виды загрузчиков
Различают 3-и вида загрузчиков в Java. Это — базовый загрузчик (bootstrap), системный загрузчик (System Classloader), загрузчик расширений (Extension Classloader).
1. Bootstrap — реализован на уровне JVM и не имеет обратной связи со средой исполнения. Данным загрузчиком загружаются классы из директории $JAVA_HOME/lib. Т.е. всеми любимый rt.jar загружается именно базовым загрузчиком. Поэтому, попытка получения загрузчика у классов java.* всегда заканчиватся null'ом. Это объясняется тем, что все базовые классы загружены базовым загрузчиком, доступа к которому из управляемой среды нет.
               Управлять загрузкой базовых классов можно с помощью ключа -Xbootclasspath, который позволяет переопределять наборы базовых классов.
2. System Classloader — системный загрузчик, реализованный уже на уровне JRE. В Sun JRE — это класс sun.misc.Launcher$AppClassLoader. Этим загрузчиком загружаются классы, пути к которым указаны в переменной окружения CLASSPATH.
                        Управлять загрузкой системных классов можно с помощью ключа -classpath или системной опцией java.class.path.
3. Extension Classloader — загрузчик расширений. Данный загрузчик загружает классы из директории $JAVA_HOME/lib/ext. В Sun JRE — это класс sun.misc.Launcher$ExtClassLoader.
                           Управлять загрузкой расширений можно с помощью системной опции java.ext.dirs.

Понятия
Различают текущий загрузчик (Current Classloader) и загрузчик контекста (Context Classloader).
> Current Classloader — это загрузчик класса, код которого в данный момент исполняется. Текущий загрузчик используется по умолчанию для загрузки классов в процессе исполнения. В часности, при использовании метода Class.forName("")/ClassLoader.loadClass("") или при любой декларации класса, ранее не загруженного.
> Context Classloader — загрузчик контекста текущего потока. Получить и установить данный загрузчик можно с помощью методов Thread.getContextClassLoader()/Thread.setContextClassLoader(). Загрузчик контекста устанавливается автоматически для каждого нового потока. При этом, используется загрузчик родительского потока.

Модель делегирования загрузки
Рассмотрим процесс загрузки более детально. Пусть в систем исполнения встретилась декларация переменной пользовательского класс Student.
1) Системный загрузчик попытается поискать в кеше класс Student.
1.1) Если класс найден, загрузка окончена.
1.2) Если класс не найден, загрузка делегируется загрузчику расширений.
2) Загрузчик расширений попытается поискать в кеше класс Student.
2.1) Если класс найден, загрузка окончена.
2.2) Если класс не найден, загрузка делегируется базовому загрузчику.
3) Базовый загрузчик попытается поискать в кеше класс Student.
3.1) Если класс найден, загрузка окончена.
3.2) Если класс не найден, базовый загрузчик попытается его загрузить.
3.2.1) Если загрузка прошла успешно, она закончена ;)
3.2.2) Иначе управление предается загрузчику раширений.
3.3) Загрузчик расширений пытается загрузить класс.
3.3.1) Если загрузка прошла успешно, она закончена ;)
3.3.2) Иначе управление предается системному загрузчику.
3.4) Системный загрузчик пытается загрузить класс.
3.4.1) Если загрузка прошла успешно, она закончена ;)
3.4.2) Иначе генерируется исключение java.lang.ClassNotFoundException.

 Если в системе присутствуют пользовательские загрузчики, они должны
 а) расширять класс java.lang.ClassLoader;
 б) поддерживать модель динамической загрузки.


>> (Загрузка классов в Java. Практика) https://habrahabr.ru/post/104229/

При реализации пользовательских загрузчиков важно помнить следующее:
1) любой загрузчик должен явно или неявно расширять класс java.lang.ClassLoader;
2) любой загрузчик должен поддерживать модель делегирования загрузки, образуя иерархию;
3) в классе java.lang.ClassLoader уже реализован метод непосредственной загрузки — defineClass(...), который байт-код преобразует в java.lang.Class, осуществляя его валидацию;
4) механизм рекурентного поиска также реализован в классе java.lang.ClassLoader и заботиться об это не нужно;
5) для корректной реализации загрузчика достаточно лишь переопределить метод findClass() класса java.lang.ClassLoader.

Реализация по-умолчанию подразумевает следующую последовательность действий:
1) вызов findLoadedClass() для поиска загружаемого класса в кеше;
2) если класса в кеше не оказалось, происходит вызов getParent().loadClass() для делегирования права загрузки родительскому загрузчику;
3) если иерархия родительских загрузчиков не смогла загрузить класс, происходит вызов findClass() для непосредственной загрузки класса.


>> (Классификация и функции загрузчиков классов) http://www.quizful.net/post/Java

Понятно, что прежде чем интерпретировать байт-код, его необходимо загрузить в оперативную память компьютера. Итак, как же загружается самый первый класс?
Все классы в Java загружаются с помощью загрузчиков классов.  Вначале работы программы создается 3 основных загрузчика классов:
1.базовый загрузчик (bootstrap)
2.загрузчик расширений (extention)
3.системный загрузчик (system/application)

Помимо основных загрузчиков классов, существует возможность создания пользовательских загрузчиков классов. О них мы поговорим позже.

> Загрузчики классов являются иерархическими. Загрузчик, который загружает основные системные классы, называется базовым (Bootstrap или Primordial) загрузчиком классов. Именно он загружает внутренние классы JDK  и пакеты java.* (rt.jar и i18n.jar) . Важно заметить, что базовый загрузчик является «Изначальным или Корневым» и частью JVM, вследствие чего его нельзя создать внутри кода программы.
> Итак,  загрузчик расширений – загружает различные пакеты расширений, которые располагаются в директории <JAVA_HOME>/lib/ext или другой директории, описанной в системном параметре java.ext.dirs. Это позволяет обновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик расширений реализован классом sun.misc.Launcher$ExtClassLoader.
> И, наконец, системный загрузчик – загружает классы, пути к которым указаны в переменной окружения CLASSPATH или пути, которые указаны в командном рядке после ключей  –classpath или  –cp. Системный загрузчик реализован классом sun.misc.Launcher$AppClassLoader.

Каждый загрузчик классов (кроме Bootstrap) имеет родительский загрузчик, и в большинстве случаев он запрашивает родительского загрузчика загрузить указанный класс, перед тем как попробовать загрузить его самостоятельно.
Существует так же явный  способ инициировать загрузку требуемого класса. Явное инициирование выполняться с помощью методов ClassLoader.loadClass() или Class.forName(). Например явное инициирование используется при загрузке JDBC драйверов: Class.forName("oracle.jdbc.driver.OracleDriver");

>> (Основы динамической загрузки классов в Java) https://blogs.oracle.com/vmrobot/entry/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2_%D0%B2
















http://help4coding.net/spring-oauth2-authentication-with-rest-request
http://www.unknownerror.org/opensource/jaredhanson/passport/q/stackoverflow/18260230/angular-js-node-js-passport-spring-oauth2-authentication-authorization
http://stackoverflows.top/tech-stack/questions/34742265/spring-oauth2-authentication-with-rest-request
https://habrahabr.ru/post/278411/
https://habrahabr.ru/post/245415/
https://amsterdam.luminis.eu/2015/11/12/integration-testing-a-spring-restful-web-service-secured-with-oauth2/
http://stackoverflow.25lm.com/questions/29034214/spring-security-and-oauth2-generate-token-with-custom-grant-type










