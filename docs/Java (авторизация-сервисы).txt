
===============================================================================================================================
Существует много разного вида информации: текст, картинка, звук, видео, команда, ...
Такую информацию можно разделить на форматы: текстовый формат, формат изображения, видео формат, аудио (звуковой) формат, формат машинных команд (высокого/низкого уровня), ...

Но на дисковом устройстве (носителе) информация любого формата может быть представлена (хранится) только в двоичном виде.
Двоичный символ представляет собой какой-то код. Весь двоичный код условно можно разбить на диапазоны:
- в самом верхнем диапахоне будут лежать машинные команды (на самом низком уровне железа...)
- в следующем диапазоне будут лежить программные команды (на уровне Операционной Системы, высокоуровневые команды...)
- дальше может быть диапазон для символов ввода/вывода (текстовый формат)
- потом может быть формат изображения (это расширение текстового формата...)
- в следующем диапазоне могут хранится спец. знаки аудио формата (частота, громкость, длительность звучания, ...)
- еще более сложное представление это видео формат (сочетание формата изображения с аудио форматом: частота кадров, ...)

Для представления данных (информации) из конкретного выбранного диапазона форматов требуется специальный инструмент - который пробразует спец. символы в понятное для человека представление...
Таким специальноым инструментом могут являтся: текстовый процессор, аудио-видео кодеки, драйвер печати, ...
То есть, инструмент (программа) распознает спец. символы из диапазона формата и представляет их в понятном для человека образе.

--------------------------------------------
При передаче данных через REST (веб) сервис происходит следующее:
> для GET-метода:
  1. выбор инструмента для распознания формата данных;
  2. чтения (считывания) данных в потоке из файла на дисковом устройстве - это когда курсор поочередно фокусируется на каждом следующем фрагменте данных и транслирует эти данные в область представления.
     (то есть, инструмент может представить только какой-то фрагмент из файла на котором он сфокусирован, НО НЕ весь файл целиком...)
	 (тот факт что данные транслируются в потоке обозначает что устройство ничего НЕзнает границы где начинается и когда заканчивается этот объем информации...есть только текущий фокус курсора)
  3. Каждый такой формат по отдельности можно представить как простой объект...поэтому данные трансформируются в виде JSONа и передаются на другую сторону
  4. На другой стороне (все происходит в обратном порядке) конкретно установленное устройство принимает ожидаемый (известный) ему формат данных и продолжает с ним работать...
  5. При трансляции таких данных заранее НЕизвестен размер-объем передачи данных И данные передаются в нарезанных пакетах (где было сфокусирован курсор устройства чтения...)
> HTTP-протокол (в отличие от веб-сервиса) может паралельно (одновременно) передавать и принимать много разных форматов данных...то есть, когда много простых объектов объединяются в один сложный объект
> для POST-метода:
  1. считываются данные из файла которые лежат в двоичной форме и передаются на другую сторону
  2. для приемной стороны уже заранее определяется какой ожидается объем-размер данных получить
  3. (но такие данные, при передачи файла НЕраспознаются И НЕрасшифровываются никаким устройством. Просто данные передаются в том двоичном виде в котором они хранятся...)
  4. (еще используется FTP-протоколом...)
> для PUT-метода:
  1. PUT-метод отличатся о POST-метода тем что передается НЕ вся информация полностью, а только та часть которую нужно обновить...
  2. (такой подход экономит ресурсы сетевого трафика)
> для DELETE-метода:
  1. здесь в основном передается команда что требуется выполнить на другой стороне (например: с помощью команд Операционной Системы удалить какой-то файл...)

===============================================================================================================================
Современное веб-приложение имеет слоистую архитектуру (клиентская часть, сервер приложения и сервер-база данных).
Каждый его слой реализовывается с помощью разных технологий (HTML, JavaScript, PHP, JAVA, SQL, ...).
Для связки разных технологий между этими слоями применяется HTTP-протокол.

Иногда бывает что приимущественно применяется только один тип технологии в разных слоях архитектуры веб-приложения.
Например:
- Когда уже существует требуемая реализация для определенного модуля, но только на другом языке программирования (JAVA), а реализация самого-же серверного приложения использует (PHP).
  Существуют разные фреймворки (библиотеки) которые транслируют-преобразуют классы-объекты из одного языка программирования в другой язык программирования.
    На другой стороне работает 'сокет' который прослушивает конкретный порт. Связь с таким 'сокетом' проходит непосредственно через TCP-протокол (это транспортный протокол самого низкого физического уровня).
  Так вот, передаваемые данные-объект который принимае этот 'сокет' может внедрится на ходу прямо в рабочее приложение и тем самым менять ход работы программы...
Идея в том, что применеие TCP-протокола бывает достаточно для простой передачи данных-объекта чтобы удаленно управлять работой приложения.

Что есть такое Remote Procedure Call (удаленный вызов процедуры):
> Класс-объект представляет собой (целую) программу.
  А методы-функции этого класса-объекта являются отдельными процедурами.
> В ходе работы программы, в области ОЗУ, по очереди в определенном порядке вызываются отдельные процедуры этой программы и выполняют какие-то действия...
> Сложная программа может состоять из множества классов-объектов. Каждый объект хранит свое конкретное состояние и в процессе выполнения в зависимости от этого состояния программа изменяет свой ход работы...
  Таким способом, если внедрить подменить (данные) класс-объект в области ОЗУ для работающей программы - то тогда можно изменить ход выполнения программы...то есть, управлять ходом выполнения программы.
  Именно такой механизм и является - удаленным вызом процедуры.
> Собственно, чтобы выполнить подмену класса-объекта для работающей программы - для этого достаточно просто загрузить данные этого класса-объекта в области ОЗУ.
  Поэтому применение TCP-протокола является более чем достаточно для такой операции...
> Но, в отличии от HTTP-протокола, недостатков TCP-протокол является тот факт что он НЕтакой надежный и более уязвимым к возникновению ошибок...

> TCP-протокол - это протокол самого низкого уровня который позволяет непосредственно выполнять передачу данных (без-о всяких посредников...).
> 'Сокет' это программа которая просто прослушивает конкретный порт и принимает-передает полученные данные (больше ничего с ними неделает...необрабатывает).

> HTTP-протокол - это прослойка между клиенским приложенем и серверным приложением. И серверное приложение и клиентское приложение имеют-используют встроенные собственные 'сокеты'.
  То есть, HTTP-протокол ожидает что должны присутствовать и сервер-приложений и клиентское приложение.
  Это описание правил для реализации механизма запроса-ответа между клиентом и сервером...
  Это рпотокол высокого уровня ('физический уровень' для передачи пакетов двоичных данных, 'сетевой уровень' для определения адресса получателей, 'уровень программной поддержки' для преобразования-распознания двоичных данных в понятную-читабельную форму).
> А также HTTP-протокол гарантирует целостность данных для передачи-доставки. HTTP-протокол распространяется и на сторое клиента и на стороне сервера. А также может автономно определить на каком этапе была допущена ошибка при передаче данных и возвращает код ошибки ЛИБО предоставляет эту роль серверу приложений...

> Таким образом серверное приложение прослушивет все запросы-обращения от клиентских приложений.
> Сервлет - это приложение которое является дополнением для серверного приложения для разных других реализаций-обрабатчиков (которые отсутствуют в стандартной библиотеке сервера приложения...)
  Сервлет имеет функции-методы через которые можно взаимодействовать и управлять работой сервлета.
  По своей сути - сервлет - является (REST) контролером. И поддерживает методы типа: GET, HEAD, POST, PUT, DELETE

> SOAP - это целое семейство разных протоколов. И может поддерживать TCP-протокол, HTTP-протокол.
  Данные состояние класса-объекта может сериализироваться (не только в файл для хранения на дисковом носителе) еще и в XML-файл для передачи его по сети.
  Структура целостности файла XML-документа хорошо описывается и защищена проверкой на валидность...
> В качестве сервера приложения для SOAP является 'Endpoint-сервис', который эмулирует собственный виртуальный сервер приложений И поддерживает только POST-метод.
> А в качестве контроллера выступает сам класс-объект, интерфейсные методы которого вызываются...
> По сути работа SOAP-протокола сводится к передаче файла (это состояние класса что сериализован в XML-документ) и загрузка-подмена класса-объекта для работающего веб-приложения в области ОЗУ...
  Этот механизм и является (эмитирует) - удаленным вызовом процедуры (RPC) на высоком уровне через HTTP-протокол...

> SSH-протокол - это есть трансляция потока через сеть из удаленной рабочей станции.
  То есть, если какая-то программа способна принимать данные и как-то данные выводить - то Операционная Система может сканировать состояние полученной информации от такого устройства и отображать их...
  Дело в том, что любая Операционная Система поддерживает функцию фокусироваться на каком-то выбранном приложении, сканировать получаемую информацию из него и транслировать эти данные для отображения пользователю...
  Это называется - 'рабочий стол' (или терминал).
> Так вот, SSH-протокол 'удаленный рабочий стол', который транслирует поток данных через сеть для пользователя...

===============================================================================================================================
Что такое секюрити:
> 'Куки' - изначально были созданы чтобы хранить клиентские данные которые участвуют в запросах для автоматического заполнения полей клиентской формы, с целью избавить клиента повторно вводить данные что однажды были уже введены...
> 'Сессия' - хранит состояние всех клиентских 'куков' на стороне сервера - чтобы каждый раз НЕпередавать данные по сети И тем самым экономит сетевой трафик...
  Сессия имеет ограничения по времени хранения на сервере...
> Защита клиента состоит из:
  1. Форма авторизации
  2. Клиентский логин-пароль
  3. Группа ролевая политика к которой принадлежит конкретный клиент
>> Первым делом клиент лезет на сервер приложений.
   А сервер приложений перебрасывает клиента на определенное серверное приложение.
   А серверное приложение описывает способ авторизации для клиента...и передает эту информацию для сервера приложений.
   Тогда сервер приложений из своей библиотеки генерит такой тип формы для авторизации клиента и отдает ее клиенту.
   Клиент заполняет эту форму и возвращает ее на серверное приложение.
   Серверное приложение получает данные и использует свой встроенный модуль доступа к базе для проверки наличия такого клиента.
   Вся информация сохраняется в сессии. Если клиент был найден, тогда сервер приложений определяет к какой группе ролевой политике принадлежит этот клиент.
   Все дальнейшие обращения к серверному приложению будут выполняться только через эту ролевую группу.
>> Доступ на самом-же серверном приложения может быть защищен либо для методов-функций, либо по фильтру URL-адрессов.
>> Весь этот длинный путь получения доступа для клиента к серверному приложению собирается и сохраняется в контексте И от туда позволяет вытащить любую информацию об этом клиенте...

Сессия тоже в какой-то степени защищает клиентский доступ для веб-приложения. Но при этом всю доверенность (это идентификатор сессии) получает непосредственно сам клиент.
То есть, если злоумышленик украдет идентификатор сессии у клиента - то это будет значить что злоумышленник будет владеть клиентской довереностью на все время работы с этой сессией.
Такая защита клиентской доверености является уязвимой, потому-что клиентскому приложению тяжело контролировать ее.

> Что такое механихм OAuth - это способ защиты клиентского доступа.
  Всю доверенность получает и контролирует уже НЕ сам клиент а серверное приложение.
> Токен - представляет собой подпись клиента, которая потом идентифицируется на стороне сервера...
> Есть OAuth-сервер - который выдает клиенту его токены ('рефреш-токен' и 'актив-токен')
> OAuth2Tokenizer - это реализация механизма клиентской автоматической аторизации на серверном приложении.
>> НЕавторизированный клиент идет на серверное приложение.
   Серверное приложение проверяет его и перенаправляет на OAuth-сервер для получения клиентских токенов доступа.
   Клиент авторизируется на этом OAuth-сервере, получает (свои) клиентские токены доступа.
   Дальше клиент возвращается на сервер приложений и заходит уже со своими токенами.
   После этого клиент получает доступ к методам серверного приложения.
>> 'рефреш-токен' это механизм авторизации клиента на серверном приложении.
   Рефреш-токен содержит: ссылку на идентификатор рефреш-токена; OAuth-сервер; зашифрованный клиентский ключ-пароль; ключ-дешифратор;
>> 'актив-токен' это клиентская подпись, которая аудитенфицирует личность клиента.
   Актив-токен содержит: имя клиента; время пользования и время истечения срока для токена; роллевую группу куда входит этот клиент; ссылка на идентификатор рефреш-токен.
>> И рефреш-токен и актив-токен хранятся в куках на сторое клиента.
   Но рефреш-токен может отправляться редко-только один раз на сервер. А актив-токен часто-постоянно каждый раз при запросе отправляется на сервер.
   Если злоумышленик перехватить актив-токен клиента - то он сможет только на короткое время им воспользоваться.
   По истечению этого лимитного времени, серверное приложение запросит у клиента его рефреш-токен.
   Если рефреш-токена нет - тогда доступ для такого клиента будет закрыт...
   По рефреш-токену серверное приложение автоматически подключается к OAuth-серверу, получает информацию-подтверждения прав доступа клиента и обновляет данные клиентских токенов...
   Для работы с токенами нужно чтобы сессия была отключена (инначе вся информация будет закешированна внутри сессии по идентификатору сессии)
   В отличии от актив-токена, рефреш-токен очень редко участвует в клиентских запросах и поэтому вероятность что злоумышленик перехватит его будет очень низкая...

===============================================================================================================================
> EJB-бин - служит для временного хранения клиентской информации (между клиентскими запросами...в сессиях)
> Entity-бин - служит для постоянного хранения клиентской информации (позволяет полностью востанавливать ее после сбоя...)
> MDB-бин - отправляет односторонний-клиентский запрос без получения ответа (в случаях когда обработка клиентских запросов бывает долговременная или требуется гарантированная доставка клиентского запроса...).
  ...........................................................................
> API - это интерфейс для взимодействия между серверным приложеним и клиентом...
> Серверное приложение является самым нагруженным слоем веб-приложения, и поэтому оно обычно тормозит работу всего веб-приложения.
  Серверное приложение должно отработать полный цыкл чтобы отдать инфорацию клиенту. И все это время сервер приложения будет удерживать-блокировать активность клиента...
  Чтобы сократить-пропустить этот полный цыкл для отработки на сераерном приложении можно использовать локальный кеш, чтобы экономить время на меж-серверных запросах...
  Еще можно использовать MDB-бин чтобы не заставлять клиента ожидать окончания ответа (просто отправить односторонний-клиентский запрос, без получения ответа...)

Работа механизма взаимо-действия между серверной и клиентской части базы данных аналогична работа механизма протгрывателя видео-плеера:
> Клиент может по разному обрабатывать информацию которая приходит от сервера базы данных:
  -- либо это человек который медленно читает небльшие страницы текста..
  -- либо это программа которая очень быстро проходит по всему длинному списку..
> В любом случае серверная сторона базы данных ничего не знает о своих клиентах.
  И поэтому серверная сторона базы данных всегда работает в режиме потока!
То есть, это значит что при обращении к базе данных, база данных всегда будет возвращать какой-то пакет данных с ограниченным размером.
И как только клиент подтвердит что полученный пакет дпнных был прочитан - тогда сервер базы данных передвинет позицию своего курсора на следующую строку и вернет
следующий пакет данных...Но все это время такая клиентская транзакция будет открыта (пока поток недостигнет конца..)
  Из диска, оператором 'FROM' данные будут считываться из файла пачками в 'КЕШ' базы данных сервера..И после каждого раза этот КЕШ будет очищаться

> Подпись кода существует для защиты (одного) каждого-конкретного пользователя от множества-разных производителей ПО и множества серверов.
  Это выполняется на уровне железа...
  - генерится приватный ключ (для сервера чтобы расшифровывать данные) и публичный ключ (для клиентов чтобы шифровать данные);
  - на базе публичного ключа генерится документ-сертификат (сюда вбивается вся информация об компании) и подается на подпись в сертификационный центр;
  - после подписи полученный сертификат из сертификационного центра добавляется в локальное хранилище (keyStore)
  + эта информация об клмпании добавляется во все распространяемые ПО...
  - дальше нужно keyStore отдать клиенту чтобы клиент подтвердил подлиность компании
  + либо это может сделать API браузера, JAVA, ...
> Чтобы защитить (один) каждый-конкретный сервер от множества разных пользователей - для этого существует авторизация с помощью разных форм на уровне сервера приложений.
  И проверка прав доступа согласно ролевой политике на уровне веб-приложения...
===============================================================================================================================
===============================================================================================================================
>>                                         (ВикипедиЯ TCP/IP) https://ru.wikipedia.org/wiki/TCP/IP
>> (Протокол TCP/IP или как работает Интернет (для чайников)) http://www.ofnet.ru/osnovy-interneta/tcpip.html


> Компьютеры объединяются в локальные сети (в локальной сети компьютеры напрямую видят только друг друга).
  А локальные сети уже соединяются между собой через шлюзы (роутеры, маршрутизаторы).
> Маска подсети предназначена для определения принадлежит ли компьютер-получатель к этой же локальной сети или нет.
  (если компьютер-получатель принадлежит этой же сети что и компьютер-отправитель то пакет передается ему напрямую в противном случае пакет отправляется на шлюз по умолчанию который далее по известным ему маршрутам передает пакет в другую сеть)
> Комбинация: "IP адрес и номер порта" - называется  "сокет".

> Принципы работы TCP/IP-протоколов очень просты и напоминают работу почты:
  - Сначала вы пишете письмо, кладете его в конверт, заклеиваете, на конверте пишете адреса отправителя-получателя, и относите в ближайшее почтовое отделение;
  - Далее письмо проходит через цепочку почтовых отделений до ближайшего почтового отделения получателя;
  - Откуда оно почтальоном доставляется по указанному адресу получателя и опускается в его почтовый ящик (с номером его квартиры или вручается лично);
  - Когда получатель письма захочет ответить то он в ответном письме поменяет местами адреса получателя и отправителя и письмо отправиться к вам по той же цепочке но в обратном направлении;
> Взаимодействие компьютеров и приложений в сети Интернет:
  - Каждый компьютер (он же: узел, хост) в рамках сети Интернет тоже имеет уникальный адрес, который называется IP-адрес (Internet Protocol Address);
  - В конечном счете обмениваются информацией не компьютеры сами по себе, а приложения работающие на них (почтовый сервер, веб-сервер...).
    (для доставки письма недостаточно знать только адрес дома, необходимо еще и знать номер квартиры) Также и каждое программное приложение имеет подобный номер - именуемый номером порта
	(SMTP привязан к порту 25 (отправка письма на почтовый ящик); POP3 привязан к порту 110 (чтение письма из почтовых ящиков); FTP привязан к порту 20 (для передачи данных) или 21 (для управляющих команд); SSH привязан к порту 22 (безопасное соединение с удалённой машиной); HTTP привязан к порту 80 (WEB-сервер) или 8080 (прокси-сервера); DNS привязан к порту 53 (сервер распознавания имен);)
> Программы на домашнем компьютере являются клиентами (например почтовый клиент Outlook, веб-обозреватели IE, FireFox и пр.)
  (номера портов на клиенте не фиксированные как у сервера а назначаются операционной системой динамически. Фиксированные серверные порты как правило имеют номера до 1024, а клиентские начинаются после 1024)

> TCP/IP - это название набора сетевых протоколов (на самом деле передаваемый пакет проходит несколько уровней).
  ------
> IP протокол - это протокол "сетевого уровня". Задача этого уровня доставка ip-пакетов от компьютера отправителя к компьютеру получателю.
                (по-мимо собственно данных пакеты этого уровня имеют ip-адрес отправителя и ip-адрес получателя)
> TCP и UDP - это протоколы "транспортного уровня".
              (транспортный уровень находится над сетевым, на этом уровне к пакету добавляется порт отправителя и порт получателя)
  ---------
> TCP - это протокол с установлением соединения и с гарантированной доставкой пакетов. (-Привет. -Привет. -Поболтаем? -Давай. «повтори, не расслышал»)
> UDP - это протокол без установления соединения и с негарантированной доставкой пакетов. (крикнул что-нибудь, а услышат тебя или нет - неважно).

Уровни стека TCP/IP
-------------------
1. Канальный уровень ...... Ethernet, IEEE 802.11 Wireless Ethernet (это физическая среда и принципы кодирования информации)
2. Сетевой уровень ........ IP (разработан для передачи данных из одной под-сети в другую, пример: ARPANET)
3. Транспортный уровень ... TCP, UDP, SCTP, DCCP (могут решать проблему негарантированной доставки сообщений («дошло ли сообщение до адресата?») а также гарантировать правильную последовательность прихода данных)
4. Прикладной уровень ..... HTTP, RTSP, FTP, DNS (это приложения программного-обеспечения)



>> (Ответы на вопросы на собеседование Web services) https://jsehelper.blogspot.com/2016/04/web-services.html
                                                     http://samolisov.blogspot.com/2013/12/soap-vs-restful.html
													 https://habrahabr.ru/post/158605
													 https://ru.wikipedia.org/wiki/SOAP
>>                                    (REST vs SOAP. Часть 1. Почувствуйте разницу) https://habrahabr.ru/post/131343
>> ( REST vs SOAP. Часть 2. Как проще и эффективнее организовать общение платформ?) https://habrahabr.ru/post/134303
>> (JAX-WS) https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/EJB.md


> что при SOAP-подходе мы оперируем множеством методов и у нас не существует понятия единого интерфейса
  SOAP может использоваться с любым протоколом прикладного уровня: SMTP, FTP, HTTP, HTTPS и др
> HTTP является «пассивным наблюдателем»,


> Все протоколы прикладного уровня являются приложениями. И эти приложения уже являются веб-сервисами... А каждый веб-сервис имеет собственные интерфейсные методы. Например:
  + SMTP-протокол .... для передачи коротких текстовых сообщений
  + FTP-протокол ..... для передачи файлов
  + HTTP-протокол .... открытый протокол для передачи текста с неограниченным размером. В качестве текста можно представить что-угодно (теги, ссылки...)
                       этот протокол имеет собственные методы (GET/POST/PUT/DELETE/...) которые позволяют управлять ресурсами
  + HTTPS-протокол ... сам по себе HTTP-протокол не поддерживает секюрность, это надстройка (дополнительный слой над HTTP-протоколом) которая занимается шифрованией/дешифрованией информации (и за счет такой дополнительной операции сервер будет работать медленее).

> REST ... это прежде всего концепция (НЕпротокол) которая использует свойства только HTTP-протокола для описания формы обмена данными:
           - В качестве данных может выступать любой и-нет рессурс.
		   - Также здесь может быть применен любой формат данных.
		   - за счет своего формата, содержимое данных будет меньше И поэтому передача данных будет вестись быстрее.
		   - Серверная сторона должна находиться постоянно в динамически-активном состоянии.
> RPC .... это старая технология, которая использует механизм именнования функций-процедур для удаленного их вызова (с идентичным именем)
> SOAP ... это механизм который поддерживает: RPC-технологию И семейство разных протоколов:
           - его достоинством является тот факт что он расширяет методы для любого из HTTP-протоколов до неограниченного количества (но работает через POST).
           - его достоинством является тот факт что позволяет одновреммено применять одни и теже RPC-методы для разных протоколов.
		     -- то есть, каждый протокол имеет свои достоинства и недостатки НО SOAP позволяет выбирать именно те протоколы которые по своим достоинствам более подходят ему...








REST (JAX-WS)
=============
-- реализовать REST веб-сервис можно либо через 'Spring' фреймворк либо через 'JAX-RS' библиотеку
-- REST оддерживает такие форматы JSON .... application/json XML ..... application/xml XHTML ... application/xhtml+xml -- метод-обработчик REST веб-сервиса
-------------
//The REST service: @Path, @Produces, @Consumes
//@Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
//@Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
@Path("/greeting")
@Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
@Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
public class GreetingService {
	@GET public Response message() {
		return new Response("Hi REST!");
	}
}


одновременно может принимать несколько форматов. Для этого нужно:
>> аннотировать метод обработчик (аннотация '@Path' говорит о том что это является веб-сервис)
   @Path("/hello/{id}") @GET @POST @PUT @DELETE
>> или класс (аннотация '@Path' говорит о том что это является веб-сервис)
   @Path("/hello")
   public static class Resource {
       @Path("/{id}")
	   public Response removeCustomer(@PathParam("id") String id) { ... }
   }
>> аннотацией метода указать @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON }) @Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
>> а также чтобы в хедере запроса был установлен параметр 'Content-Type'
   Content-Type: application/json Content-Type: application/xml Content-Type: application/xhtml+xml
>> public Response removeCustomer(@PathParam("id") String id) { ... }
>> НО если это (НЕ просто веб-сервис) 'сервлет' - тогда он формирует уже полноценую клиентскую HTML-страницу.
   У сервлета есть такие методы как: init(), destroy(), service(), doGet(..) | doPost(..) | ...
   Тобиш, это уже есть что-то большое...полноценная клиентская веб-страница с гиппертекстом (в то время как веб-сервис возращает только текстовую информацию необходимую для вставки на клиентскую веб-страницу)...


SOAP Web Service (JAX-WS)
=====================[ это правило описывает создание серверной части.. ]
>> https://github.com/Home-SOAP/JAX-WS-RPC
= = = = = = = = = = =
> wsdl.xml
>
	@WebService
	@SOAPBinding(style=Style.RPC)
	public interface WebServiceInterface {
		@WebMethod String getHelloWorldAsString(String name);
	}
>
	@WebService(endpointInterface="com.javacode.ws.server.WebServiceInterface")
	public class WebServiceImpl implements WebServiceInterface {
		@Override
		public String getHelloWorldAsString(String str) {
			...
		}
	}
>
	public class WebServicePublisher {
		public static void main(String[] args) {
		   Endpoint.publish("http://localhost:8888/ws/helloworld", new WebServiceImpl());
		}
	}

1.  нужно создать интерфейс веб-сервиса (WebServiceInterface) аннотацией @WebService
2.  потом имплементировать этот интерфейс веб-сервиса (WebServiceImpl): > регистрируем интерфейс нашего веб-сервиса @WebService(endpointInterface="...")
        в классе (WebServiceImpl) возле аннотации @WebService нужно указать путь где лежит интерфейс 'endpointInterface="com.javacode.ws.server.WebServiceInterface"'...серверная сторона
        в интерфейсе метода клиента (WebServiceInterface) возле аннотации @Action тоже фиксируем путь к интерфейсу метода сервера...клиентская сторона
        в классе имплементации метода (WebServiceImplService) возле аннотации @WebServiceClient и @WebServiceClient где 'targetNamespace' + при создании экземпляра класса в конструкторе 'QName' тоже фиксируем путь к интерфейсу...клиентская сторона
3.  'Endpoint' (WebServicePublisher) - эта утилита которая стартует наш веб-сервис, по указаному url-адрессу (http://localhost:8888/webserive/helloworld) > этот url-адресс должен быть зарегистрирован:
        в самой утилите для запуска веб-сервиса 'Endpoint' (WebServicePublisher)...серверная сторона
        в описании 'WSDL-документе' (wsdl.xml)...серверная сторона
        в классе-имплементации веб-сервиса (WebServiceImplService)...клиентская сторона = если зайти в веб-браузере по этому 'url-адрессу' + добавить '?wsdl' (http://localhost:8888/ws/helloworld?wsdl) тогда в результате будет доступен сам 'WSDL-документ' (собственно можно использовать класс-клиен 'URL', аналог веб-браузеру, чтобы получить доступ через HTTP-протокол и просмотреть/проверить 'WSDL-документ'...) > эта утилита 'Endpoint' позже, уже на сервере приложений, будет заменена дескриптором развертывания 'web.xml' (в котором будет описаны прввила запуска...либо через сервлет, либо через веб-сервис)
4.  Вызов веб-сервиса через клиент:
        через класс 'URL' (утилиту) клиент читаем 'WSDL-документ'...
        ???
        переменная типа интерфейса (WebServiceInterface), на стороне клиента, инициализируется данными полученными из веб-сервиса И через интерфейсный метод веб-сервиса 'getHelloWorldAsString' получаем информацию...

SOAP Web Service (JAX-WS)
=====================[ это правило описывает создание клиентской части.. ]
>> https://github.com/Home-SOAP/JAX-WS-Client
= = = = = = = = = = =
> с помощью библиоотеки 'axis-1.4':
  -- сперва ее нужно скачать и подключить в нашу среду IDE...
  -- потом через 'axis-1.4' сгенерить классы на серверной стороне, котрые потом будут переданы на сторону клиента...
> но сам-же ресурс 'wsdl.xml' будет доступен через веб-протокол по зарегистрированному адрессу (http://localhost:8888/ws/helloworld.wsdl): Endpoint.publish("http://localhost:8888/ws/helloworld", new WebServiceImpl());
> но прежде нужно задеплоить и запустить это веб-приложение веб-сервиса на какой-нибудь сервер приложений...

1.  Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
		@WebService(name="EntityPortMyType",
		            targetNamespace = "http://my.domain.com/ws/definitions")
		@SOAPBinding(style=SOAPBinding.Style.RPC, use=SOAPBinding.Use.LITERAL)
		public interface EntityManager{
			@WebMethod long addEntity();

            @WebMethod
            long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );

            @WebMethod
            void removeEntity( @WebParam(name = "id")long id );
        }

2.  Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
    portName - должен указывать на порт того типа, что прописан в интерфейсе
	targetNamespace - должен быть такой же, как и у интерфейса
	endpointInterface - точно указывать на полное имя реализуемого интерфейса
	wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
	    @WebService(serviceName = "EntityManager",
		            portName="EntityPortMyType",
					endpointInterface = "com.mydomain.webapp.domain.EntityManager",
					targetNamespace = "http://my.domain.com/ws/definitions",
					wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")
		public class EntityManagerImpl implements EntityManager{
			public long addEntity(){
				// method body
				return 0;
			}

			public long findEntity(IdentityType i_type, String identity){
				// method body
				return 0;
			}

			public void removeEntity(long id){
			   // method body
			}
		}

2.  В pom файле проекта необходимо совершить:
	вставить код для jaxws-maven плагина,
	обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть) org.codehaus.mojo jaxws-maven-plugin wsgen ${basedir}/src/main/webapp/WEB-INF/wsdl com.my.domain.webapp.domain.EntityManagerImpl true true com.my.domain.webapp.domain com.sun.xml.ws jaxws-rt 2.1.3

3.  Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
	- Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
	- Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener) com.sun.xml.ws.transport.http.servlet.WSServletContextListener

		<servlet id="ws-entities-servlet">
			<servlet-name>EntityService</servlet-name>
			<servlet-class>
				com.sun.xml.ws.transport.http.servlet.WSServlet
			</servlet-class>
			<load-on-startup>1</load-on-startup>
		</servlet>
		<servlet-mapping id="ws-entities-servlet-mapping">
			<servlet-name>EntityService</servlet-name>
			<url-pattern>/app/entities</url-pattern>
		</servlet-mapping>

4.  Создать файл sun-jaxws.xml Но что же сервлет будет делать с запросом, пришедшим на url-pattern? В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки: <?xml version="1.0" encoding="UTF-8"?>
5.  Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса http://localhost:8080/my-webapp/app/entities?wsdl

6.  .. (Нововведения в стандарте Servlet API 2.5) http://www.quizful.net/post/new-in-servlet-api-v25 (JAX-WS Hello World Example – RPC Style) https://examples.javacodegeeks.com/enterprise-java/jws/jax-ws-hello-world-example-rpc-style/

    @WebService(name="PingService", targetNamespace="http://acme.com/ping")
	@SOAPBinding(style=SOAPBinding.Style.RPC, use=SOAPBinding.Use.LITERAL)
	public class Ping {
		@WebMethod(operationName = "Foo")
		public void foo(){}
	}


)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
Все EJB-компоненты ориентированными на многопоточное исполнение (серверные компоненты можно писать так же как и однопоточные приложения а EJB-технология обеспечивает многопоточное исполнение)

Правила описания JavaBean:
--------------------------
[1] Класс должен иметь конструктор без параметров, с модификатором доступа public.
[2] Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах.
[3] Класс должен быть сериализуем.
[4] Класс должен иметь переопределенные методы equals(), hashCode() и toString().

Сущесвует всего 3-вида бинов (в EJB есть 3-типа компонентов):
=============================================================
1. Session beans (Сеансовый компонент - сохраняют свое состояние между разными клиентскими вызовами)
                 Область действия для вложенных бинов ограничивается пределами своего родительского бина
				 Аннотация @EJB
   -------------
   > Stateful-бин (с состоянием...скоуп - данные хранятся на стороне сервера):
                  (Состояние сохраняется в памяти все время пока клиент использует сессию)
                  (Сеансовый компонент с состоянием не может использоваться несколькими клиентами. Он выделяется только для одного клиента на все время своей жизни)
     >> Local - (расширяет интерфейс javax.ejb.EJBHome) локальный объект класс-бина размещается только на серверной стороне и имеет только методы для реализации кастомерской бизнес-логики
	            В нём есть необходимые для работы методы: create(), find() и remove(), каждый из которых соответствует ejbCreate(), ejbFind() and ejbRemove(), с той же сигнатурой, что указана в реализации конкретного создаваемого бина.
     >> Remote-интерфейс - (расширяет интерфейс javax.ejb.EJBObject) удаленный объект класс-бина размещается на стороне клиента и создается два объекта-бина:
                           [1] 'Локальный' объект класса-бина размещается на стороне сервера (использует серверную JVM) и имеет методы бизнес-логики + методы спецификации: create(),find(),remove() - которые позволяют управлять этим локальным объектом класса-бина.
                           [2] 'Удаленный' объект класса-бина размещается на стороне клиента (использует клиентскую JVM) и имеет только методы бизнес-логики. Удаленный объект класса-бина связывается с локальным объектом класса-бина через RMI-механизм.
                           >>  'Локальный' и 'Удаленный' объект класса-бина нужен для того чтобы безопасно привязываться к интерфейсу, a RMI-механизм гарантирует совместимость интерфейсов через 'Удаленный' объект класса-бина для всех клиентов
                           >>  Состояние удаленного класса-бина храниться на стороне клиента И освобождает локальный объект класса-бина от хранения состояния на стороне сервера
     >> У stateful-бинов существует 4-события жизненного цикла которые мы можем перехватить:
        >>> @PostConstruct - метод который будет вызываться сразу после создании бина
        >>> @PreDestroy - метод который будет вызываться перед его удалением
        >>> @PostActivate - метод который будет вызываться при активации бина
        >>> @PrePassivate - метод который будет вызываться при ДЕактивации бина
   > Stateless-бин (без состояния...скоуп - данные хранятся на стороне клиента)
     >> используются для реализации бизнесс-процессов, которые могут быть завершены за одну операцию
	    (Сеансовые компоненты без состояния имеют более высокую производительность с точки зрения пропускной способности и потребления ресурсов)
        (Применяется для обслуживания большого количества клиентов)
     >> У stateless-бинов существует 2-события жизненного цикла которые мы можем перехватить:
        >>> @PostConstruct - метод который будет вызываться сразу после создании бина
        >>> @PreDestroy - метод который будет вызываться перед его удалением
   > Singleton-бин (гибрид...скоуп)

2. Message-driven beans (MDB - никогда не вызывается напрямую, обычно сервер использует MDB в асинхронных запросах)
   --------------------
   > Для реализации MDB-бина нужно:
	 >> аннотировать класс @MessageDriven
     >> унаследоваться от интерфейса javax.jms.MessageListener
	 >> и реализовать метод onMessage()
	 (Раз клиент не общается непосредственно с MDB, то он его и не создает. Контейнер сам решит, когда и сколько ему требуется MDB для обработки сообщений из данного Destination)
	 (Клиент не общается с ним посредством remote interface) Единственный способ общения – это посылка сообщений – MessageListener.
	 Класс реализует javax.ejb.MessageDrivenBean и javax.jms.MessageListener:
	   >>> ejbCreate(); setMessageDrivenContext(); ejbRemove();
	   >>> onMessage();
   > Режимы работы получателей (адресаты могут получать свои сообщения в синхронном режиме и асинхронном режиме (Queue | Topic):
	 [1] В синхронном режиме - код программы получателя явно вызывает метод получения сообщения (receive). Если сообщение в соответсвующем целевом объекте (queue | topic) отсутствует вызывающий поток будет блокирован до его появления. В спецификации существуют перегрузки метода-'receive()' позволяющие задать период ожидания.
	 [2] В асинхронном режиме - разработчик реализует в классе получателя интерфейс javax.jms.MessageListener. Этот интерфейс содержит всего один метод-'onMessage(...)' который будет вызван при появлении в целевом объекте сообщения. Естественно чтобы это случилось получателя необходимо зарегистрировать в целевом объекте
   > Message-Oriented Middleware (MOM) это распределенная система основанная на асинхронном обмене сообщениями(messages) между компонентами системы.
   > Сообщение может быть (режим доставки сообщения):
     >> сохраняемым (такое сообщение переживет гибель MOM - большей надежности)
	 >> несохраняемым (большей производительности)
   > Модели обмена сообщениями в JMS:
	 [1] 'Point-to-Point' (Queue): применяется когда одному или нескольким компонентам (senders) необходимо послать сообщение только одному компоненту-адресату (receiver)
	 [2] 'Publish-Subscribe' (Topic): применяется когда одному или нескольким компонентам (publishers) необходимо послать сообщение одному или нескольким компонентам-адресатам (subscribers)
   > JMS поддерживает 3-модели подтверждения получения сообщения:
     [1] AUTO_ACKNOWLEDGE (самый простой тип. Там где не требуется очень высокая производительность – этот тип вполне уместен)
	 [2] DUPS_OK_ACKNOWLEDGE (используйте там, где нужна высокая производительность однако минус в данном случае – все неподтвержденные сообщения будут передоставлены вновь)
	 [3] CLIENT_ACKNOWLEDGE (дает разработчику полный контроль над подтверждением получения сообщения)
   > Java Message Service (JMS):
     >> ConnectionFactory – ответственный за создание JMS 'Connection' (javax.jms.QueueConnectionFactory | javax.jms.TopicConnectionFactory)
     >> Connection – абстрактное представление реального соединения между клиентом JMS и MOM (javax.jms.QueueConnection | javax.jms.TopicConnection) ответственный за создание JMS 'Session'
     >> Session – это главная "рабочая лошадка" JMS и используется клиентами для посылки/получения сообщений (javax.jms.QueueSession | javax.jms.TopicSession)
		>>> сессии бывают:
		    >>>> Транзакционные - в этом случае сообщения группируются и отправляются внутри одной транзакции.
			                      (если произошла ошибка то все действия отменяются, вся отправка и получение сообщений которые были внутри транзакций аннулируются)
								  (Возможна кроссдоменная транзакция с использованием JTA)
								  Существует два подхода в использовании транзакций совместно с JMS:
								  [1] применим только внутри JMS (transacted sessions)
								      Интерфейс javax.jms.Session включает два метода: commit() для подтверждения транзакции и rollback() для отката к первоначальному состоянию.
								  [2] используется JTA-транзакции совместно с JMS (например, в составе же транзакции JDBC-запроса | javax.transaction.UserTransaction)
								      Позволяет разработчику включать в единую транзакцию как посылку сообщений, так и запрос к базе данных или EJB
									  (JTA не может быть использован совместно с transacted session)
			>>>> НЕтранзакционные -
		>>> сессия это контекст потока в котором выполняется передача сообщений
		>>> при передаче события (сообщения) выполняется его сериализация
     >> Destination – (пункт назначения) может быть либо 'Queue' либо 'Topic' (в зависимости от используемой модели javax.jms.Queue | javax.jms.Topic):
        >>> MessageProducer – компонент который посылает сообщения (javax.jms.QueueSender | javax.jms.TopicPublisher)
        >>> MessageConsumer – компонент который получает сообщения (javax.jms.QueueReceiver | javax.jms.TopicSubscriber)
     >> Message (все типы сообщений являются подклассами javax.jms.Message):
		>>> ByteMessage – сообщение содержащее поток байтов
		>>> TextMessage – сообщение содержащее строку
		>>> XMLMessage – расширение TextMessage, используется для доставки XMLсообщений
		>>> MapMessage – сообщение, содержащее пары "ключ-значение"
		>>> ObjectMessage – сообщение, содержащее сериализованный обьект
	    >>> StreamMessage – сообщение, содержащее сериализованный поток обьектов
	    Сообщение состоит из:
		 [1] заголовка (хранит мета информацию сообщения, заполняемую автоматически)
		 [2] поля-свойств (схоже с заголовком, но оно заполняется программно, и позже получатель сможет прочитать эту информацию)
		 [3] тела (содержит полезную нагрузку сообщения. Типы унаследованы от интерфейса javax.jms.Message)
   > Способы борьбы с производительностью:
     [1] Приоритеты для сообщений в очереди (0-9)
     [2] Группировать сообщения которые обращаются к тем-же самым данным
     [3] Время активности сообщения
     [4] Максимальный размер очереди
     [5] Каскадные очереди (несколько очередей для разного типа сообщений)
     [6] Асинхронный способ передачи сообщений
     [7] Добавить отправку статистики (гарантия доставки)
   > Ограничение JMS (Java Message Service):
     >> API - определено; а формат сообщений - нет;
     >> JMS (в отличие от AMPQ) не имеет требований к тому как сообщение будет сформировано и передано;
     Каждый JMS-брокер может создавать сообщения различного формата. Они просто должны использовать одно и то же API.
	 'Glassfish','Weblogic','JBoss' - поддерживают возможность реализации JMS
	 Главный недостаток MDB – он может принимать сообщения только из одного Destination
	 Одно из главных преимуществ JMS в том, что посылка сообщения может быть частью транзакции.
   > Преимущества AMPQ (Advanced Message Queueing Protocol):
     >> публикует эти спецификации в доступном для загрузки XML формате (это делает её простой для библиотеки поддерживаемую генерацию API по спецификации; также автоматическую генерацию алгоритмов для сериализации и десериализации сообщений;)
     >> имеет средства обмена маршрутизации и очереди
     Брокеры которые поддерживает AMQP: 'RabbiMQ','ActiveMQ','Qpid'

3. Entity beans
   ------------
   > ORM - механизм сохранения java-объектов в базу данных.
   > JPA - это описание спецификации.
   > EntityManagerFactory - это фабрика сущностей которая загружает и настраивает соединение с базой в среде Java-приложения. А еще 'EntityManagerFactory' создает объекты типа 'EntityManager'.
   > EntityManager - это основной интерфейс который применяется для выполнения CRUD-операций к базе.
        find (SELECT)
     persist (INSERT)
       merge (UPDATE)
      remove (DELETE)
     >> загрузка файла-конфигурации 'persistence.xml' из среды Persistence для коннекта к базе
        EntityManagerFactory factory = Persistence.createEntityManagerFactory("TestStore");
        EntityManager        manager = factory.createEntityManager();
   > Hibernate - это одна из реализаций JPA.
   >> загрузка файла-конфигурации 'hibernate.cfg.xml' из среды Hibernate для коннекта к базе
      SessionFactory - это фабрика сущностей которая загружает и настраивает соединение с базой в среде Java-приложения. А еще 'SessionFactory' создает объекты типа 'Session'.
      Session - (Hibernate сессия) это главный интерфейс взаимодействия Java-приложения и Hibernate который применяется для выполнения CRUD-операций к базе.
      get|list|load (SELECT)
               save (INSERT)
             update (UPDATE)
             delete (DELETE)
      SessionFactory factory = new Configuration().configure("hibernate.cfg.xml").buidSessionFactory();
      Session        session = factory.openSession();
   > Entity - это легковестный объект бизнес логики.

 * > Объекты сессии могут находиться в трёх состояниях:
 *   1. Transient - никогда не сохранялись и не ассоциированы ни с одной сессией (игнорируются);
 *   2. Persistent - ассоциированы с уникальной сессией (включаются);
 *   3. Detached - ранее сохраненные, но не ассоциированы с сессией.

 * >> Четыре статуса жизненного цикла Entity:
 *    1. new (объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных);
 *    2. managed (объект создан, управляется JPA, имеет сгенерированные первичные ключи);
 *    3. detached (объект был создан, но больше не управляется JPA);
 *    4. removed (объект создан, управляется JPA, но будет удален после commit-a транзакции);
 * >> Требования к Entity:
 *    1. класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации;
 *    2. класс должен содержать public/protected конструктор без аргументов (он также может иметь конструкторы с аргументами);
 *    3. класс не может быть enum или интерфейсом;
 *    4. класс не может быть финальным классом;
 *    5. класс не может содержать финальные поля или методы, если они участвуют в маппинге;
 *    6. поля класса должны быть доступны только методам самого класса и не должны быть напрямую доступны другим классам (getter/setter методам или другим методам бизнес-логики в Entity классе);
 *    7. класс должен содержать первичный ключ;
 * >> типы данных допустимы в Entity:
 *    1. примитивные типы и их обертки Java;
 *    2. строки (String) И BigDecimal, BigInteger;
 *    3. любые сериализуемые типы Java (реализующие Serializable интерфейс);
 *    4. enums;
 *    5. entity классы;
 *    6. embeddable классы
 *    7. коллекции;
 * >> Можно использовать типы данных входящих в первичный ключ Entity:Comparable
 *    1. примитивные типы и их обертки Java;
 *    2. строки;
 *    3. BigDecimal и BigInteger;
 *    4. java.util.Date и java.sql.Date;
 * >> Embeddable - встраиваемый класс который не используется сам по себе (только как часть Entity):
 *                 класс должен быть отмечен аннотацией Embeddable;
 *                 классы должны удовлетворять тем же правилам что Entity;
 * >> Mapped Superclass - это класс-родитель от которого наследуются Entity:
 *                        класс должен быть отмечен аннотацией MappedSuperclass или описан в xml-файле;
 *                        он может содержать JPA-анотации;
 *                        такой класс не является Entity;
 *                        и ему не обязательно выполнять все требования установленные для Entity;
 *                        класс не может использоваться в операциях EntityManager или Query;
 *
 * >>> Базовая JPA-аннотация (JPA-маппинг сущности и ее свойств) - указывает на простейший тип маппинга данных (на колонку/таблицы/базы данных, можно указать fetch-стратегию доступа к полю и является ли поле обязательным);
 * >>> Converter JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяют указать класс для конвертации Базового аттрибута Entity в другой тип;
 * >>> Access JPA-аннотация (JPA-маппинг сущности и ее свойств) - имеет два типа доступа к атрибутам (свойствам) Entity:
 *     1. через аннотацию на поле класса;
 *     2. через аннотацию на метод класса;
 * >>> EntityListeners JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет задать класс Listener который содержит сallback-методы обработки событий (PrePersist|PostPersist||PreRemove|PostRemove||PreUpdate|PostUpdate||PostLoad);
 * >>> Cacheable JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет включить или выключить использование кеша второго уровня;
 * >>> Стратегии наследования мапинга в JPA:
 *     1. Single-table - одна таблица на всю иерархию наследования = Минусом является что в общей таблице будут пустые поля для всех других классов-потомков;
 *     2. Joined - (объединяющая стратегия) каждый entity сохраняется в свою таблицу, а все унаследованные колонки записываются в таблицы класса-предка (устанавливается связь relationships между этими таблицами) = Минусом являются потери производительности от объединения таблиц;
 *     3. Table per concrete - каждый отдельный класс-наследник имеет свою таблицу = Минусом является плохая поддержка полиморфизма;
 * >>> Типы связей (relationship) между Entity:
 *     1. OneToOne
 *     2. OneToMany
 *     3. ManyToOne
 *     4. ManyToMany
 *     Каждую из которых можно разделить ещё на два вида:
 *     -  Bidirectional (ссылка на связь устанавливается только с обоих сторон)
 *     -  Unidirectional (ссылка на связь устанавливается только с одной стороны)
 * >>> Fetch стратегии загрузки объектов:
 *     - Fetch-стратегии загрузки объектов в JPA:
 *       1. LAZY (ленивая загрузка - данные поля будут загруженны только во время первого доступа к этому полю)
 *       2. EAGER (данные поля будут загруженны немедленно)
 *     - Fetch-стратегии загрузки объектов в Hibernate
 *       1. Join fetching (получает объекты одним SELECT-ом используя OUTER JOIN)
 *       2. Select fetching (использует уточняющий SELECT чтобы получить объекты)
 *       3. Subselect fetching (использует уточняющий SELECT чтобы получить объекты + будут загружены родительские-объекты и объекты-наследники)
 *       4. Batch fetching (оптимизированный SELECT)

 * >>>> Типы кэша используются в Hibernate:
 *      1. кэш сесии (кэш первого уровня) - на уровне пользовательского-сеанса, только для данного конкретного пользователя.
 *      2. кэш фабрики сессий (кэш второго уровня) - на уровне Java-процесса, является общим для всего приложения и используется чтобы уменьшить трафик с базой данных.
 *         Чтобы указать кэш второго уровня нужно определить hibernate.cache.provider_class в hibernate.cfg.xml
 *         Реализации кэша второго второго уровня:
 *         - EHCache (поддерживает read-only и read/write кэширование, но не поддерживает кластеризацию)
 *         - OSCache (поддерживает read-only и read/write кэширование, поддерживает кластеризацию)
 *         - SwarmCache (поддерживает read-only и нестрогое read/write кэширование)
 *         - JBoss TreeCach (предоставляет полноценный кэш транзакции)
 * >>>> Типы стратегий кэша:
 *      - Read-only (используется когда данные вычитываются но никогда не обновляется)
 *      - Read/write (используется когда данные должны обновляться)
 *      - Нестрогий read/write (гарантирует что две транзакции не модифицируют одни и те же данные синхронно)
 *      - Transactional (полноценное кэширование транзакций...доступно только в JTA окружении)
 * >>>> Методы очистки сессии:
 *      - flush (синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии)
 *      - contains (поиск объекта в кеше сессии)
 *      - evict (удаляет объект из кеша cессии)
 *      - clear (очищает весь кеш)
 * >>>> Варианты настройки кэша второго уровня в JPA из persistence.xml:
 *      1. ALL (все Entity могут кэшироваться в кеше второго уровня)
 *      2. NONE (кеширование отключено для всех Entity)
 *      3. ENABLE_SELECTIVE (кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true), для всех остальных кэширование отключено)
 *      4. DISABLE_SELECTIVE (кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false))
 *      5. UNSPECIFIED (кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию для кэширования)
 *
 * >>>>> Hibernate поддерживает управляемые и не управляемые транзакции (он взаимодействует с БД через JDBC-соединение)
 * >>>>> SQL - (диалект) это язык запросов с простыми-стандартными командами которые поддерживаюся всеми типами баз данных;
 * >>>>> JPQL (Java Persistence query language) - (диалект) это язык HQL-запросов такой же как SQL только (вместо имен и колонок таблиц базы данных) он использует имена классов Entity и их атрибуты;
 * >>>>> В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но так же объекты всех его классов-потомков.
 *       Чтобы исключить такое поведение используется функция TYPE в where условии.
 *       ('JPQL' удобно использовать в именнованных запросах на уровне 'доменного слоя' в классе определения Entity-сущности - потому-что здесь ожидаются стандартные запросы к базе...)
 * >>>>> Criteria - это тоже язык запросов аналогичным JPQL, только запросы основаны на методах и объектах;
 *       ('Criteria' удобно использовать на уровне 'DAO-слоя' - потому-что здесь требуются специфические требования к запросу от 'сервисного слоя'...)

HQL - ???
JPQL - ???
 *       шесть видов блокировок (lock) описаны в спецификации JPA:
 *       @org.hibernate.annotations.Entity(optimisticLock = OptimisticLockType.ALL)
 *       1. NONE - без блокировки
 *       2. OPTIMISTIC (или синоним READ, оставшийся от JPA 1) - оптимистическая блокировка,
 *       3. OPTIMISTIC_FORCE_INCREMENT (или синоним WRITE, оставшийся от JPA 1) - оптимистическая блокировка с принудительным увеличением поля версионности,
 *       4. PESSIMISTIC_READ - пессимистичная блокировка на чтение,
 *       5. PESSIMISTIC_WRITE - пессимистичная блокировка на запись (и чтение),
 *       6. PESSIMISTIC_FORCE_INCREMENT - пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности
 *
 *       Небазовые аннотации Entity:
 *       @NamedQueries({..,..,..,..})
 *       @NamedQuery
 *       @NamedQuery(name = "ContactEntity.findById", query = "select distinct c from ContactEntity c left join fetch c.contactTelDetails t left join fetch c.hobbies h where c.id = :id")


 * Существуют 3-и команды, которые используются для управления транзакциями:
 * 1) COMMIT – для сохранения изменений;
 * 2) ROLLBACK – для отмены изменений;
 * 3) SAVEPOINT – для установки особых точек возврата.
 *
 * 1. READ UNCOMMITED
 *    - в результате отсутствия любых блокировок это приводит к наличии всех проблем: 'Грязного чтения', 'Неповторимого чтения', 'Чтеня фантомов'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      обычно применяется там где НЕважно точность информации (например: получение статистики)
 * 2. READ COMMITED
 *    - в результате применения Update-блокировки это приводит к решению проблемы: 'Грязного чтения'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      улучшает параллельный/одновременный доступ к данным
 * 3. REPEATABLE READ
 *    - в результате применения Shared-блокировки это приводит к решению проблемы: 'Неповторимого чтения'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      применяется когда нужно вставлять новые данные при параллельном/одновременном доступе к данным
 * 4. SERIALIZABLE
 *    - в результате применения eXclusive-блокировки это приводит к решению проблемы: 'Чтеня фантомов'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      применяется когда необходимо очень часто обновлять данные при параллельном/одновременном доступе
 *
 * + 'коллективная блокировка' (Shared) - блокировка в режиме чтения позволяет транзакции: читать строку. Используются для операций считывания (SELECT);
 *                                      - позволяет другим транзакциям читать строку и ставить такую-же Shared-блокировку;
 *                                      - запрещает изменять строку или ставить eXclusive-блокировку;
 * + 'исключительная блокировка' (eXclusive) - блокировка уровня записи позволяет транзакции: читать, обновлять, удалять строку. Используется для операций изменения данных (INSERT, UPDATE, DELETE);
 *                                           - позволяет блокировать строку: на чтение и на запись;
 *                                           - запрещает другим транзакциям блокировать строку;
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * + 'коллективная блокировка' (Shared) - разрешает паралельно установливать другие Shared-блокировки на теже строки в рамках транзакции (до момента завершения транзакции);
 *                                      - блокировки снимаются по мере чтения данных и они могут быть сняты даже до момента завершения транзакции не дожидаясь считывания оставшихся 9 строк;
 *                                        то есть, такая блокировка действует внутри транзации (поэтому она и называется совмещенной)
 * + 'исключительная блокировка' (eXclusive) - данная блокировка не может быть установлена, если существуют какие-либо другие блокировки на ресурсе, т.е. команда будет ждать снятия всех существующих блокировок;
 *                                           - будучи успешно установленной, данная блокировка не позволяет установку новых блокировок любых типов т.е. все запросы, пытающиеся получить доступ к заблокированному ресурсу, будут ожидать снятия монопольной блокировки;
 *                                             то есть, такая блокировка действует в отдельной транзакции до конца ее завершения (поэтому она и является уникальной)
 * + 'блокировка обновления' (Update) - она ведёт себя как что-то среднее между Shared-блокировкой и Exclusive-блокировкой;
 *                                    - логически его можно разделить на два этапа:
 *                                      #1 поиск данных для обновления - на этапе лучше будет установить Shared-блокировку (это позволит другим транзакциям избежать ожидания при чтении данных);
 *                                      #2 обновление найденных данных - и только если данные найдены то преобразовать её в Exclusive-блокировкe и произвести изменение (это сделает невозможным даже чтение данных из других транзакций и используется для операций INSERT, UPDATE, DELETE);
 * + 'блокировка с намерением' (Intent) - (оптимистическая блокировка) служит для оптимизации работы алгоритма установки блокировок;
 *                                      - в основе лежит простая идея:
 *                                        Перед установкой низкоуровневых блокировок (строках, страницах) сначала устанавливаем Intent-блокировку на более высоком уровне (таблицы);
 *                                        Если такой блокировки нет, то мы можем избежать проверки наличия уже существующих блокировок (строках, страницах) и сразу их установить;
 *                                        А если она есть то можно более оптимально принять решение о возможности установки определённой блокировки низкого уровня;
 *                                        - 'гранулярная блокировка' действует на всю таблицу или всю страницу и все строки
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * + Разновидности блокировок по типу блокируемых ресурсов
 *   - Конкретная строка в таблице
 *   - Ключ (один или несколько ключей в индексе)
 *   - Страница
 *   - Экстент
 *   - Таблица и все относящиеся к ней данные (индексы, ключи, данные)
 *   - База (блокируется, когда меняется схема базы)

 * Модели транзакций:
 * – локальная модель ....... управление транзакциями осуществляется менеджером базы данных (а не приложением, то есть, управляем только соединениями но не транзакциями).
 *                            Эту модель можно использовать для доступа через JDBC к данным и хранимым процедурам.
 *                            Нельзя использовать локальную модель для выполнения изменений в базе данных через ОРМ (например: Hibernate, TopLink, Java Persistence API (JPA))
 *
 * – программная модель ..... ответственность за управление транзакциями возлагается на разработчика (мы сами управляем транзакциями которые оказываются изолированными от низкоуровневых соединений с базой данных);
 *                            Разработчик должен самостоятельно получить ссылку на транзакцию от менеджера транзакций, начать ее, затем подтвердить ее, а если возникло исключение – то откатить ее.
 *
 * – декларативная модель ... при работе с этой моделью контейнер самостоятельно начинает, подтверждает и откатывает транзакции.
 *                            Задачей разработчика является только описание поведения транзакций.
 *                            (это наиболее часто применяемая модель, которая известная как модель транзакций управляемых контейнером "Container Managed Transactions" (CMT));
 * Транзакция определяется на уровне соединения с базой данных и при закрытии соединения автоматически закрывается (когда транзакция начинается все команды считаются телом одной транзакции пока не будет достигнут ее конец):
 * 1) "автоматическое" (по умолчанию SQL Server работает в режиме автоматического начала транзакций, когда каждая команда рассматривается как отдельная транзакция - если команда выполнена успешно то фиксируются... инначе - откат);
 * 2) "подразумеваемое" (когда пользователю понадобится создать транзакцию, включающую несколько команд, он должен явно указать транзакцию);
 * 3) "явное" (SQL Server не может находиться в режиме исключительно явного определения транзакций, этот режим работает поверх двух других);

 * В таблицах средней величины использование "ключей" - являеться эфективным способом...
 * Но в очень больших таблицах даже работа с "ключами" являеться (относительно) трудозатратной по времени. И чтобы ускорить этот процесс - есть механизм сортировки...
 * Механизм сортировки создает специальную структуру (иерархического сбалансированного дерева), которая перебирает (не все элементы в подряд) только выборочные элементы по специальному алгоритму (что позволяет сокращать количество операций для достижения такого-же результата).
 * Итак, механизм сортировки ключей/полей, является - "индексом" (то есть, "индекс" это (не альтернатива) являеться дополнением "ключа" для повышения эффективности в очень больших таблицах).
 * – "кластеризованный индекс" ..... применяется для разных полезных полей (столбцов с данными), то есть НЕтребует дополнительных запросов в строку чтобы вытащить инфорацию И может быть отсортирован в заданом порядке... НО на всю таблицу он может быть только один;
 * – "некластеризованный индекс" ... применяется только для ключей (ссылки-указатели на строки), то есть требует выполнения дополнительных запросов в строку чтобы вытащить инфорацию И НЕможет быть отсортирован... Но в каждой таблице может быть много проиндексированных таких полей;
 *
 * Ключи и индексы в базе
 * -----------------------
 * Ключ - это колонка с (легковестными) простыми-уникальными значениями, которые являются как-бы ссылками на строки содержащие полезные объемные-данные
 * Недостатки "ключа" в том что требуется еще делать дополнительные запросы чтобы вытащить полезные данные со строки...
 * 1) Потенциальный ключ (KEY) ....... это любое 1-но поле (колонка) только с полезными данными, которое обладает уникальностью (неповторимостью)
 * 2) Уникальный ключ (UNIQUE) ....... это комбинация полей (колонок) только с полезными данными, которое обладают уникальностью (неповторимостью)
 * 3) Первичный ключ (PRIMARY KEY) ... (может быть только один на всю таблицу) добавляеться новое (специальное) поле-счетчик
 * 4) Альтернативные ключи ........... это все остальные поля (колонки), которые НЕявляются потенциальными, уникальными и первичными ключами
 * 5) Внешние ключи (FOREIGN KEY) .... это поля (колонки) которые ссылаются на первичные ключи в других таблицах (в такой способ связывая между собой таблицы в единую целостность)
 *                                     (поле с полезными данными которое ссылается на другое поле с первичным ключем называется - внешней ссылкой; а первичный ключ на который ссылаются называется - родительским ключом;)
 * На "внешний ключ" накладываются специальные ограничения (CONSTRAINT):
 * – CASCADE .... означает распространение действий родительской таблицы на дочерние, то есть, если значение ключа в родительской таблице изменится то оно автоматически (без специальных запросов) изменится и в дочерних таблицах
 * – RESTRICT ... означает что нельзя редактировать значение ключа или удалять строки из родительской таблицы пока есть соответвующие внешние ключи в дочерних таблицах (это правило является правилом по умолчанию).
 * Необходимо помнить, что единая сущность таблиц, которые связываются внешними ключами, имеют специальные ограничения на изменение таблиц (так чтобы сохранить эту самую единую сущность).
 * -----------------------
 * Индекс - это улучшение "ключа" (но это не замена "ключа").
 * Идея в том что "индекс" применяет сортировку для организации более эффективного поиска-доступа к полезным данным.
 * А также "индекс" может непосредственно работать с полезными данными (то есть, отпадает необходимость в делать дополнительные запросы...) - это еще более ускоряет работу поиска-доступа
 * Работу "индекса" можно описать так:
 * – Интексирование столбца начинается с корневого узла "Root"; двигаясь дальше, на промежуточном уровне, определяется страница с более детальной информацийе "Intermediate"; И уже на самом нижнем уровне выясняеться нужный индекс (листья индекса) "Leaf";
 * Итак, индексы бывают:
 * 1) Кластеризованный индекс ..... это поля (столбцы) которые содержат полезные (реальные) данные-значения в строках - а еще такие проиндексированные поля (столбцы) называются - "кучей";
 * 2) Некластеризованный индекс ... это только 1-но поле (столбец) который является ссылкой-указателем (ключом) на строку;
 * 3) Составной индекс ............ может содержать несколько полей (столбцов - до 16 столбцов их общая длина ограничена 900 байтами);
 * 4) Уникальный индекс ........... это только 1-но поле (столбец) который содержит уникальные-неповторимые полезные (реальные) данные-значения в строках;
 * 5) Покрывающий индекс .......... позволяет запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к строкам самой таблицы;
 * Необходимо помнить что индексирвоание изменяет первоначальную структуру таблицы, поэтому добавление индексов в таблицу сопровождаеться 'ALTER'

+ INDEX (в базе данных)
  ---------------------
  Физически данные хранятся на 8Кб страницах. Сразу после создания, пока таблица не имеет индексов, таблица выглядит как куча (heap) данных.
  Когда вы хотите получить доступ к данным, SQL Server сканирует всю таблицу что бы найти искомые записи.
  SQL Server не знает что в таблице существует только одна запись, удовлетворяющая условию, пока в таблице не существует: 'Unique constraint', 'Unique index' или 'Primary key'.
  В SQL Server индексы хранятся в виде B-деревьев (B-tree). 'B' означает сбалансированное (не путать с бинарным). SQL Server предлагает к использованию два типа индекса: кластерный (clustered) и некластерный (nonclustered).
  Указатель представляет собой 'Row ID' и имеет следующий формат: НомерФайла:НомерСтраницы:ПозицияЗаписи.
  ( правило, когда работаете с SQL Server: запись может быть найдена либо по 'Row ID' когда нет кластерного индекса, либо по 'кластерному ключу' )

  Индексы которые созданные на базе ОДНОГО-поля таблицы:
  > Кластерный индекс - сами данные таблицы являются частью индекса, для таблицы может быть создан только один 'кластерный индекс'.
                        В SQL Server кластерный индекс является уникальным индексом по определению (все ключи записей должны быть уникальные).
	                    Если существуют записи с одинаковыми значениями, SQL Server делает их уникальными, добавляя номера из внутреннего (невидимого снаружи) счетчика.
						( 'Кластерный индекс' является частью 'НЕкластерного индекса' )
  > Не кластерный индекс - cами данные не хранятся в индексе и вынимаются из таблицы, используя 'Row ID' или ключ 'кластерного индекса' (важное правило SQL Server: создавать 'кластерные ключи' нужно как можно более короткими).
                           ( Каждый 'некластерный индекс' использует значения кластерного индекса, > увеличение размера 'кластерного индекса' приводит к многократному увеличению по памяти для всех 'не кластерных индексов' и к снижению количества записей индекса способных уместиться в пределах одной страницы )

  Индекс может быть создан на основании НЕСКОЛЬКИХ-полей:
  > Составной ключ - индекс создан на основании нескольких полей, и любая группа значений по полям составного индекса является уникальной.
                     ( существует только одно ограничение – длина ключа индекса или сумма длин этих полей не должна превышать 900 байтов )
  > Уникальные индексы - гарантирует что каждое значение является уникальным в индексируемом поле
                         ( целостность данных может быть гарантирована или 'Unique constrain' или 'primary key'. В основе обоих лежит уникальный индекс )

  Доступ к записям при наличии или отсутствии индексов
  > В зависимости от наличия/отсутствия индексов и их типов, SQL Server может выбрать различные способы доступа к данным таблицы:
    - Сканирование таблицы. ( Когда индексы не используются и таблица не имеет кластерного индекса. Таблица храниться как куча 'heap' )
	- Выборка данных по 'кластерному индексу'
	- Выборка данных по 'не кластерному индексу'

  Индексы так же имеют и ряд недостатков:
  > Индексы занимают дополнительное место на диске и в оперативной памяти ( каждый раз когда вы создается индекс, сохраняется ключи по порядку...и чем больше/длиннее ключ, тем больше размер индекса )
  > Замедляются операции вставки, обновления и удаления записей

     Полезные индексы
	 ----------------
	 индексирование таблиц будет полезно при поиске записи в таблице с использованием инструкции 'WHERE'
	 например:
	 - запросы поиска диапазона значений;
	 - запросы точного сопоставления определенному значению;
	 - запросы осуществляющие слияние двух таблиц;

	 Недостатки индексирования
	 -------------------------
     Индексы ухудшают производительность системы во время изменений записи
	 Базы данных с большим количеством транзакций для изменения данных будут нуждаться в небольшом количестве индексов для обеспечения более высокой пропускной способности
	 Индексы занимают дополнительное место на диске и в оперативной памяти

	 Построение оптимального индекса
	 -------------------------------
	 (Для выбора оптимального количества индексов необходимо тестирование базы данных и наблюдение за ее производительностью)

	 > Простой индекс – это индекс использующий значения одного поля таблицы.
	   Использовать простой индекс выгодно:
	   1. работа базы данных сильно нагружает жесткий диск. Большие индексные ключи будут заставлять базу данных выполнять большее количество операций ввода-вывода, что ограничивает производительность.
	   2. элементы индекса часто вовлечены в сравнения, меньшие индексы легче сравнивать.
	   Единственная колонка целочисленного типа является лучшим индексом, так как он мал и легок для сравнения.
	   Строки символов требуют посимвольного сравнения и внимания к обработке параметров.

	 > Селективный индекс - это индекс с высоким процентом уникальных значений.
	   Наиболее эффективные индексы – это индексы с малым процентом дублирующихся значений.
	   (уникальный индекс обладает наибольшей селективностью, так как не содержит дублирующихся значений)
	   (пример: телефонный городской справочник в котором каждый имеет фамилию Смит И будет не столь полезен, если записи в нем отсортировать по фамилии)

	 > Покрывающие индексы - индексы состоят из столбца данных по которому построен указателя на соответствующую строку.
	   (покрывающий запрос - все запрашиваемые столбцы могут быть извлечены из одного индекса)
	   "Select Count(*), UnitPrice From Products Group by UnitPrice"
	   Для наиболее важных запросов можна рассмотреть возможность создания покрывающего индекса для лучшей производительности.
	   Такие индексы с большой вероятностью будут составными (и это противопоставляется первому принципу - создавать простые индексы)

	 > Кластерный индекс - специальный индекс где все данные из строки содержаться в индексе.
	   Кластерный индекс наиболее эффективный индекс, если он используется, то покрывает весь запрос.
	   (кластерный индекс можно сравнить с телефонным справочником, потому как каждый элемент индекса содержит всю информацию, которая вам нужна и не содержит ссылок для получения дополнительных данных)
	   (В SQL сервере при создании первичного ключа будет автоматически создан кластерный индекс)
	   Элементы для кластерного индекса содержать все значения столбцов.
	   Если изменить запись и поменять значение столбца в кластерном индексе, база данных будет вынуждена перестроить элементы индекса.

    Итак схема-структура построение коннектов к базе в Java-приложении (Java Enterprice Edition)
    --------------------------------------------------------------------------------------------

    Первым делом нужно сказать о провайдерах-драйвера которые предоставляют соединение непосредственно к серверному приложению базы данных. Есть 3-и распространенных провайдера-драйверов:

        DataSource ... (Spring)
		DBCP ......... (Appache)
		C3PO ......... ()
		Эти провайдеры-драйверов предоставляют драйвера для соединения к серверному приложению базы данных.
		Существует 4-типа (jdbc1/jdbc2/jdbc3/jdbc4) моделей драйверов (платформо-зависимые и платформо-НЕзависимые...)

    Именно сервер приложения управляет соединением к базе данных через провайдер-драйвера. То есть, на сервере приложения через 'Resource' (context.xml) настраиваются параметры соединение к серверу базы данных:
        (поставщик) провайдер-драйверов
        (сам) драйвер
        url подключения к базе данных
        количество выделяемых пулов
        (лимит) тайм-аут по времени выполнения запроса на сервер базы данных
        допустимое количество обслуживаемых клиентов
        уровень изоляции В составе сервера приложений есть модуль который обварачивает своим функционалом провайдера-драйверов и на выдает для клиента свободный пул-соединений. Такая задача за управлением соединением к базе данных ложиться на сервер приложений...

    ORM-фреймворк нужен для того чтобы представить таблицы базы данных в удобной форме для разработчиков в виде классов и объектов в коде приложения (выполняет скрытые sql-запросы для обмена данными). Такой механизм представления могут поддерживатся разными поставщиками: 'Eclipse TopLink', 'Hibernate', 'Persistence' И декларируются в файле 'META-INF/persistence.xml', 'META-INF/hibernate.cfg.xml'... (чтобы передать соединение для подключения к базе данных в декларации для этого используется 'InitialContext') Здесь настраиваются такие параметры как:
        указывать провайдер-ORM-фреймворка
        вывод логирования sql-запросов
        вывод дополнительной статистики
        выбор диалекта для работы с базой данных
        автоматическое... выполнение sql-запросов в базу данных на сохранение/обновления состояния
        автоматическое... выполнение sql-запросов в базу данных на создание /обновление таблиц в самой базе данных
        включение / отключение кеширования
        выбор уровня кеширования
        провайдер-кеширования
        мепинг классов для которых будет применяться кеширование

    В самом-же приложении разработчики работают только из классом-сущностью (Entity: объявить поля + id, отношения между полями в таблицах, фетч-стратегию способа загрузки, именнованные sql-запросы для получения/поиска объекта) Здесь можно применять:
        либо через аннотации в java-классах
        либо через xml-декларацию на каждый класс-сущность (при таком подходе код класса-сущности будет выглядить более чистым...) А также здесь настраиваются такие параметры как:
        блокировки (оптимистическая, пессимистическая - для управления транзакциями из программы...)
        стратегии уровней изоляции (дополнительно переопределить...)
        'META-INF/Context.xml' (который потом автоматически будет подхватываться и использоваться сервером приложения...)

    Провайдеры-КЕШа (кеширования) могут быть разные: 'EHCache', 'OSCache', 'SwarmCache', 'JBoss TreeCach' Каждый провайдер-КЕШа декларируется в разных xml-файлах: ehcache.xml, treecache.xml Существует 2-а основных уровня-КЕШа:
        на уровне сессии (в течении которой выполняется sql-запрос(ы) - это кеш первого уровня)
        на уровне JVM-процесса (в течении работающего приложения - это кеш второго уровня) + на уровне JVM-кластера процесса...
        (еще есть кеш уровня транзакции...) КЕШ первого уровня всегда включенный (его невозможно отключить) КЕШем второго уровня можно управлять. Он используется в случае при минимум обновлений и максимум обращений к базе (поиск по идентификатору, ленивая загрузка, сохранения объекта в базу...) (если в КЕШе первого уровня объект ненаходиться, тогда поиск переходит в КЕШ второго уровня, а после того как объект будет найден - он попадает в КЕШ первого уровня...) КЕШ представляет собой нечто локальная копия виртуальной базы данных, которая служит для уменьшения обращений к базе данных. КЕШ может хранить данные:
        в памяти JVM
        на файловой системе Также существует еще и распределенный КЕШ-кластеров (это объединение нескольких вычислительных машин/серверов и управления ими как одним целым - для разгрузки системы при большом количестве ресурсов) Для КЕШ-кластеров существуют несколько разных способов управления: синхронный / асинхронный... обмен обновлением данных Здесь настраиваются такие параметры как:
        выбор стратегии sql-запросов к которым привязывается КЕШ (read, read-write, нестрогий read-write, transaction)
        (лимит) размер количество кешируемых объектов после которого элементы будут вытесняться
        (лимит) тайм-аут по времени после которого элементы будут удаляться
        тип объекта который будет кешироваться
        определение вычислительных машин / серверов которые работаю в кластере + IP-узла
        (лимит) размер количество кешируемых объектов на нодах (кластерах)
        способ управления (синхронный / асинхронный)
        способ хранения (память JVM, дисковый ресурс) Чтобы управлять КЕШ-кластером нужно на той ноде (вычислительном сервере) установить и запустить КЕШ-модуль (JBossCache, Memcache, Redis, MongoDB) чтобы потом все эти КЕШ-модули на разных нодах-серверах связать между собой... (Регион – это именованный кэш: указатель, на который вы можете ссылать классы и коллекции в настройке поставщика конфигурации и устанавливать политику срока вытеснения, применимую к этому региону) (Имя региона является именем класса, в случае если это кэш класса; или имя класса с именем свойства, в случае КЭШа коллекций)

    Можно использовать настройки соединения к базе данных и внутри самого приложения (jdbc.property, persistence.xml, hibernate.cfg.xml) но в случае только для выпонения тестирования функциональности приложения...


>> (Ответы на вопросы на собеседование Web services) https://jsehelper.blogspot.com/2016/04/web-services.html
>> (Коллекции в Java: о чём многие забывают ** EnumSet и EnumMap) https://habrahabr.ru/post/267389/
>> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JMS.md
>> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/Spring.md
>> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/EJB.md
>> https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java

>> (Понимание AMQP) http://spring-projects.ru/understanding/amqp/
>> (Работа с JMS сообщениями и MDB в JEE tutorial) http://deadlock.org.ua/kit/habr/post/8208
>> (Введение в JMS) http://www.javable.com/columns/serv_side/workshop/14/
>> (Сравнение производительности механизмов ввода-вывода в Java: классического (блокирующего), неблокирующего и асинхронного) http://samolisov.blogspot.com/2013/11/java.html
>> (JMS: Введение в технологию и установка ActiveMQ сервера) http://onedeveloper.ru/article?id=12
>> (Работа с JMS сообщениями и MDB в JEE) https://habrahabr.ru/post/162813/
>> (Java Message Service (JMS) на примере Apache ActiveMQ) http://ddiary.ru/java-message-service-jms-na-primere-apache-activemq/

>> () http://onedeveloper.ru/article?id=7
>> (EJB JAAS) https://books.google.com.ua/books?id=HFgHCgAAQBAJ&pg=PA238&lpg=PA238&dq=ejb+%D1%81%D0%B5%D0%BA%D1%8C%D1%8E%D1%80%D0%B8%D1%82%D0%B8+web.xml&source=bl&ots=Jxjg71ZpL3&sig=KofXauX9XcuN2oRcGQDrC7K-61k&hl=ru&sa=X&ved=0ahUKEwjo2e3H86rPAhWjB5oKHUTWCdIQ6AEIUjAH#v=onepage&q=ejb%20%D1%81%D0%B5%D0%BA%D1%8C%D1%8E%D1%80%D0%B8%D1%82%D0%B8%20web.xml&f=false
>> (Интеграция JAX-RS Token Auth и JavaEE Security) http://www.linux.org.ru/forum/development/11736568
>> (CA Single Sign-On - 12.52 SP2) https://docops.ca.com/ca-single-sign-on/12-52-sp2/en/installing/install-a-ca-sso-agent-for-jboss/configure-the-agent-security-interceptor-to-protect-web-applications-on-jboss-6-x
>> (Application Packaging and Predeployment) http://books.gigatux.nl/mirror/beaweblogic8.1/0672324873_ch07lev1sec1.html
>> (Apply declarative role-based security to EJBs and Web components) http://java.boot.by/ibm-257/ch05s02.html



> Поддержка безопасности в Java EE основанна на службе JAAS (Java Authentication and Authorization Service).
  Механизм JAAS учитывает реалии жизни и использует информацию об аудентификации пользователя на всех уровнях Java EE.
  Оно не несет ответственности за низкоуровневые тонкости как: шифрование паролей, взаимодействие с внешней службой аудентификации, ...
  >> Пользователь входит в приложение через Web-слой.
     Web-слой получает от пользователя информациею об аудентификации и проверяет ее с помощью JAAS.
  >> В случает успеха создается объект 'Principal'.
     В этот момент объекту-Principal присваивается одна или более ролей.
  >> При необходимости объект-Principal передается из Web-слоя в слой EJB-компонентов.
     После этого при обращении к каждому ресурсу (либо из Web-слоя либо из слоя EJB-компонентов) сервер приложений будет проверять право на доступ к ресурсу.

[1] Добавить пользователя у которого будет право на просмотр скрытой информации (это в настройках сервера приложений либо файл либо база данных, например: для сервера приложений 'Tomcat' это можно сделать в 'conf/tomcat-users.xml')
[2] Аутентификация (это в настройках веб-приложения делаем в WEB-INF/web.xml):
    >> 'login-config' - конфигурация аутентификации;
       >>> 'auth-method' - каким методом проводить аутентификацию;
[3] Ролевая полиика (это в настройках веб-приложения делаем в WEB-INF/web.xml):
    >> 'security-role' - конфигурация роли;
       >>> 'role-name' - прописываем роль;
[4] Настройка безопасности для веб-приложения (это в настройках веб-приложения делаем в WEB-INF/web.xml):
    >> 'security-constraint' - блок ограничений безопасности;
       >>> 'web-resource-collection' - ресурсы, к которым стоит закрыть доступ;
           >>>> 'url-pattern' - запрос к которому будет применен фильтр безопасности;
           >>>> 'http-method' - метод к которому применим фильтр безопасности;
       >>> 'auth-constraint' - выставляем роли доступа;
           >>>> 'role-name' - указываем роль;
[5] Дополнительно использование безопасности в сервлетах (это в настройках класса-сервлета):
    + '@ServletSecurity' - определяет настройки безопасности;
    + '@HttpMethodConstraint' - ограничения для каждого метода доступа;
    + 'value' - http method (GET,POST..);
    + 'rolesAllowed' - роль которая может получить доступ;

|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
> Декларативное управление безопасностью:

  ---------------------------------------
<login-config>
	<auth-method>BASIC</auth-method>
</login-config>

<security-role>
	<role-name>ADMIN_ROLE</role-name>
</security-role>

<security-constraint>
	<web-resource-collection>
		<url-pattern>/admin/*</url-pattern>
		<http-method>GET</http-method>
		<http-method>POST</http-method>
	</web-resource-collection>
	<auth-constraint>
		<role-name>ADMIN_ROLE</role-name>
	</auth-constraint>
</security-constraint>

  ---------------------------------------
<security-role>
	<role-name>ADMIN_ROLE</role-name>
</security-role>
<security-role>
    <role-name>MANAGER_ROLE</role-name>
</security-role>
<security-role>
    <role-name>EMPLOYEE_ROLE</role-name>
</security-role>

<login-config>
	<realm-name>admin form</realm-name>
	<auth-method>FORM</auth-method>   // BASIC  FORM  CLIENT-CERT
	<form-login-config>
		<form-login-page>login.jsp</form-login-page>
		<form-error-page>error.jsp</form-error-page>
	</form-login-config>
</login-config>

<security-constraint>
	<display-name>Confidential</display-name>
	<web-resource-collection>
		<web-resource-name>Confidential Resources</web-resource-name>
		<url-pattern>/admin/*</url-pattern>
		<http-method>GET</http-method>
		<http-method>POST</http-method>
	</web-resource-collection>
	<auth-constraint>
		<description></description>
		<role-name>ADMIN_ROLE</role-name>
		<role-name>MANAGER_ROLE</role-name>
	</auth-constraint>
	<user-data-constraint>
		<transport-guarantee>CONFIDENTIAL</transport-guarantee>   // NONE  INTEGRAL  CONFIDENTIAL
	</user-data-constraint>
</security-constraint>

<method-permission>
	<role-name>ADMIN_ROLE</role-name>
	<method>
		<ejb-name>BankEjb</ejb-name>
		<method-name>getBankOpenHour</method-name>
	</method>
</method-permission>

> Программное управление безопасностью:
  -------------------------------------
  >> @DeclareRoles - перечисляет роли для проверки прав доступа к EJB-компоненту
  >> @RolesAllowed - сообщает контейнеру список ролей которым позволено обращаться к методу EJB-компонента (может применятся либо к отдельному методу либо ко всему классу)
  >> @PermitAll - открывает доступ сразу ко всем
  >> @DenyAll - закрывает доступ сразу ко всем (делает недоступным класс или метод для любой роли)
  >> @RunAs - позволяет выполнить команду от имени другого пользователя (можно временно присвоить пользователю с одной-ролью привилегии с другой ролью)

@WebServlet(urlPatterns="/my-servlet")
@ServletSecurity( httpMethodConstraints={@HttpMethodConstraint(value="GET", rolesAllowed="ADMIN_ROLE"), @HttpMethodConstraint(value="POST", rolesAllowed="MANAGER_ROLE")} )
	public class SecuredServlet2 extends HttpServlet{
		@Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			resp.getWriter().write(...

class MyClass {
	@RolesAllowed("ADMIN_ROLE")
	public String getBankOpenHour() {
	  ...
	}
}

@DeclareRoles("ADMIN_ROLE")
class MyClass {
  ...
}

> Для JAX-RS части есть самодельная система аутентификации:
  ---------------------------------------------------------
  >> public class User implements java.security.Principal - сущность для юзера
  >> public class AppSecurityContext implements javax.ws.rs.core.SecurityContext - контекст для jax-rs
  >> @NameBinding public @interface Authenticated - аннотация для отметки, что метод или класс требует входа в систему
  >> public class SecurityFilter implements javax.ws.rs.container.ContainerRequestFilter - фильтр проверяющий HTTP-заголовок на наличие токена и устанавливающий запросу соответствующий SecurityContext (или вызывающий abortWith, если аутентификация не удалась)
> Из 'SecurityContext' можно:
  - 'getCallerPrincipal' дает доступ к объекту 'Principal'
  - 'isCallerInRole' проверить обладает ли вызывающий код правами роли
  - 'SecurityException' возбудить исключение при нехватке прав
> 'Principal'
  - 'getName' возвращает имя пользователя с привилегиями которого выполняется код (также может вернуть произвольную строку имеющую смысл к аудентификации, имя роли/группы...)
> Интерцептор - возможность помечать методы которые будут вызываться до и после любых прикладных методов EJB-компонента
- '@AroundInvoke' помечает метод как интерцептор
- '@Interceptors' назначает другой метод-интерцептор для этого метода

@Resource
private SessionContext context;  // это реальная информация то что лежит в контексте сервера приложений (после того как система нас авторизирует...)

public void cancelBid(Bid bid) {  // эту информацию мы можем вытянуть из конкретного места (которое нас интересует...)
	if( !context.isCallerInRole("ADMIN_ROLE") && !context.isCallerInRole("MANAGER_ROLE")
        && (!bid.getBidder().getUsername().equals( context.getCallerPrincipal().getName() ))
		&& bid.getBidDate().getTime() >= 123456789 ){
		throw new SecurityException("You do not have permission to cancel an order");
	}
}




>>> (JAVA EE:Разработка web-приложения. JPA. EJB. JSTL) http://onedeveloper.ru/article?id=7
>>> ( Spring Framework без XML… совсем!) https://habrahabr.ru/post/112488/

)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
@CrossOrigin
@RequestMapping(value = "/obyavlenie/image/{fileId}", method = RequestMethod.GET)
public ResponseEntity<InputStreamResource> imageDownload(@PathVariable String fileId, @RequestParam(required = true, defaultValue = "large") String cachedSize){
	return ResponseEntity.ok()
			.contentLength(gridFSDBFile.getLength())
			.contentType(MediaType.parseMediaType(gridFSDBFile.getContentType()))
			.header("Content-Disposition", "attachment; filename=" + gridFSDBFile.getFilename())
			.body(new InputStreamResource(gridFSDBFile.getInputStream()));
}

@CrossOrigin
@RequestMapping(value = "/obyavlenie/image", method = RequestMethod.POST)
public ResponseEntity<CreatedObjResp> imageUpload(@RequestParam MultipartFile file){
	FileUploadWrapper fileUploadWrapper = new FileUploadWrapper();
	try {
		fileUploadWrapper
				.setInputStream(file.getInputStream())
				.setContentType(file.getContentType())
				.setFilename(file.getOriginalFilename());
	} catch (IOException ex){
		return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
	}
	return new ResponseEntity<>(new CreatedObjResp(uploadedFileId), HttpStatus.CREATED);
}








Criteria
static конструктор
Реплика базы...
regiexp...
FOREIGN KEY (`userid`) REFERENCES users(`userid`)   http://asmodeus.com.ua/library/soft/mysql/innodbpk.html
REST Spring
++++++++++++++++++++++++++++++++++++++++++++++++++++++
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users_group tug RIGHT OUTER JOIN tomcat_users tu ON tug.group_name=tu.group_name LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin' AND (tug.group_name='Biplane-Cashier' OR tug.group_name='Biplane-Admin');
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT DISTINCT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT DISTINCT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT JOIN FETCH tu.user_fio fio LEFT JOIN FETCH tu.group_name g;
SELECT tu.user_name AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT tur.user_name AS roles FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles, COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles, COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu WHERE tur.role_name='admin';

 * >>>>> Hibernate поддерживает управляемые и не управляемые транзакции (он взаимодействует с БД через JDBC-соединение)
 * >>>>> SQL - (диалект) это язык запросов с простыми-стандартными командами которые поддкрживаюся всеми типами баз данных;
 * >>>>> JPQL (Java Persistence query language) - (диалект) это язык HQL-запросов такой же как SQL только (вместо имен и колонок таблиц базы данных) он использует имена классов Entity и их атрибуты;
 * >>>>> В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но так же объекты всех его классов-потомков.
 *       Чтобы исключить такое поведение используется функция TYPE в where условии.
 *       ('JPQL' удобно использовать в именнованных запросах на уровне 'доменного слоя' в классе определения Entity-сущности - потому-что здесь ожидаются стандартные запросы к базе...)
 * >>>>> Criteria - это тоже язык запросов аналогичным JPQL, только запросы основаны на методах и объектах;
 *       ('Criteria' удобно использовать на уровне 'DAO-слоя' - потому-что здесь требуются специфические требования к запросу от 'сервисного слоя'...)
 * >>>>> преимущства от использования Hibernate:
 *       1. прозрачный механизм связи БД и POJO;
 *       2. HQL;
 *       3. автоматическая генерация primary key;
 *       4. кэш: Session Leve, Query и Second level;
 *       5. производительность: ленивая инициализация, выборка outer join;



** >> (OAuth2 JDBC, Spring Security) http://www.javist.info/?p=1
                                     http://websystique.com/spring-security/secure-spring-rest-api-using-oauth2/
      (Spring Boot and OAuth2) https://spring.io/guides/tutorials/spring-boot-oauth2/
	  (Spring REST API + OAuth2 + AngularJS) http://www.baeldung.com/rest-api-spring-oauth2-angularjs
	  https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v
>> (OAuth 2.0 простым и понятным языком) https://habrahabr.ru/company/mailru/blog/115163/
** >> (OAuth 2.0 and the Google OAuth Client Library for Java) https://developers.google.com/api-client-library/java/google-oauth-java-client/oauth2
                                                               https://jersey.java.net/documentation/latest/security.html
															   https://db-blog.web.cern.ch/blog/emil-kleszcz/2016-08-java-web-application-based-oauth2

* >> (2. Introduction to the Spring Framework) http://docs.spring.io/spring/docs/current/spring-framework-reference/html/overview.html
                                               http://stephanebegaudeau.tumblr.com/post/48776908163/everything-you-need-to-understand-to-start-with
** >> (Курс - Angular JS) http://edu.cbsystematics.com/ru/courses/description/angular_js
                          http://thewebland.net/angularjs-tutorial/angularjs-references/
** >> (Введение в Angular JS. Примеры) http://webformyself.com/vvedenie-v-angular-js/


https://jersey.java.net/documentation/latest/security.html
https://developers.google.com/api-client-library/java/google-oauth-java-client/oauth2
http://docs.spring.io/spring/docs/current/spring-framework-reference/html/overview.html
https://docs.angularjs.org/guide/introduction




