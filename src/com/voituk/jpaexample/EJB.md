
   (Java EE - что это, ее неполное составляющее) http://reka-neva.blogspot.com/2014/08/java-ee.html
        (Общие сведения о технологиях EJB и JPA) http://javasource.ru:5050/articles.xhtml?artlink=general-information-about-ejb-jpa
                                              () http://umk3.utmn.ru/files/0000096543.pdf
                                              () http://www.des4web.ru/e-Shop/gl10.html
(Как HTTPS обеспечивает безопасность соединения) https://habrahabr.ru/post/188042/
                              (Архитектура REST) https://habrahabr.ru/post/38730/
    (Создание приложения J2EE с помощью EJB 3.1) https://netbeans.org/kb/docs/javaee/javaee-entapp-ejb_ru.html
                                              () https://habrahabr.ru/post/131343/
    (Лучше иногда падать, чем никогда не летать) http://www.warenhaus.com.ua/?p=1088
 ----------------------------------------------

> Технология Enterprise JavaBeans (EJB) ... реализация защищённого взаимодействия для распределённых открытых систем с помощью технологии Enterprise JavaBeans.
                                            это архитектурное решение, модель для распраделенного вычисления (все службы, предоставляемые этой технологией, остаются прозрачными для разработчика).
  J2EE-приложение состоит из:
  - Веб-уровень ...... (Веб-модуль: представление клиентских веб-страниц)
  - Бизнес-уровень ... (сервис/служба которая согласно бизнес плану предоставляет запрашиваемую информацию)
  - EJB-модуль ....... (Бин: кратко/временно хранимые объекты - компоненты используемые 'бизнес-уровнем', прослойка между 'EIS-уровень' и 'бизнес-уровнем')
  - EIS-уровень ...... (долго хранимые объекты: база данных)

>> EJB предоставляет три вида сеансных компонентов:
  - 'Stateful' - с поддержкой состояния: состояние компонента сохраняется между вызовами методов ("Состояние" - это значения переменных экземпляра).
  - 'Stateless' - без поддержки состояния: такие компоненты используется для операций, происходящих в течение одного вызова метода (при завершении выполнения метода состояние, зависящее от клиента, не сохраняется).
  - 'Singleton' - одноэкземплярный сеансный компонент создается в приложении в единственном числе и существует в течение всего жизненного цикла приложения.
  + + + + + + + + + + + + + + + + + + + + + + + [ Технологии JavaEE ]
  Технология Enterprise JavaBeans (EJB) - это высокоуровневая технология создания распределенных приложений которая использует низкоуровневый API (базирующаяся на использовании компонентов) для управления транзакциями.
                                          При создании распределенных систем её бизнес-логика реализована на уровне этих Компонентов.
  EJB-компоненты выполняются под управлением EJB-сервера который выполняет роль связующего звена между контейнерами и операционной средой.
  EJB-сервер обеспечивает доступ EJB-контейнерам к системным сервиса:
  - Создание пула ..................... (для каждого компонента EJB платформа EJB создает пул совместно используемых клиентами экземпляров компонента)
  - Многопоточная ориентированность ... (EJB делает все компоненты ориентированными на многопоточное исполнение и высокопроизводительными)
  - Транзакции ........................ (EJB поддерживает управление объявленными транзакциями которое позволяет добавить транзакционное поведение к компонентам путем настройки а не программирования)
  - Безопасность ...................... (EJB поддерживает интеграцию с интерфейсом API службы проверки подлинности и авторизации Java JAAS)
  + Lifecycle Management .............. EJB-контейнер автоматически управляет жизненным циклом объекта.
  + State Management .................. EJB-контейнер автоматически управляет состоянием объекта.
  + Security .......................... EJB контейнер автоматически производит все проверки безопасности.
  + Transactions ...................... EJB-контейнер может автоматически управлять стартом, откатом, записью транзакций по требованию бина.
  + Persistence ....................... EJB-контейнер автоматически управляет сохранением данных.
  
  

> JAX-RS ........................ API для разработки RESTful Web Services.
> JAX-WS ........................ API для разработки Web Services на основе SOAP и WSDL.
> JAX-RPC ....................... API для разработки Web Services через протокол RPC.
> SAAJ .......................... API низкого уровня для работы с SOAP Web Services, а так-же позволяет прикреплять приложения к месседжам SOAP.


                                            SOAP – это целое семейство протоколов и стандартов
>> Протокол SOAP (Simple Object Access Protocol) — определяет стандарты для кодирования различных типов данных и соглашений о представлении вызывающих методов в удаленных объектах.
                                                  Это «легкий»протокол для обмена сообщениями между объектами в распределенной среде, с использованием XML и передачи простого (plain) текста через стандартный порт HTTP сообщения SOAP могут передаваться через брандмауэры.
>> REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем
                                            это не протокол и не стандарт (SOAP и REST – не конкуренты), а архитектурный стиль


>> Как правило, запросы передаются посредством обычного HTTP, в котором и запрос клиента, и ответ сервера передаются в открытом виде.
   Когда по каналу связи передается важная информация (пароли,кредитные карты) необходимо обеспечить меры предотвращающие прослушивание таких соединений.
   - Transport Layer Security (TLS) - наследник SSL - протокол часто применяемый для обеспечения безопасного HTTP соединения (HTTPS).
                                      TLS расположен на уровень ниже протокола HTTP (это означает что в процессе выполнения запроса сперва происходят все вещи связанные с TLS-соединением и уже потом все что связано с HTTP-соединением).
TLS - гибридная криптографическая система, она использует несколько криптографических подходов:
      1) Асиметричное шифрование (криптосистема с открытым ключом) для генерации общего секретного ключа и аутентификации (удостоверения в том что вы - тот за кого себя выдаете).
      2) Симметричное шифрование, использующее секретный ключ для дальнейшего шифрования запросов и ответов.

Отличие ролей от групп:
- Членство в группе - статическое
- Роли могут быть динамическими









* (j2ee Создание SSL-сертификата) https://www.ibm.com/developerworks/ru/library/ac-iscssl1/
                                  http://www.cyberforum.ru/java-j2ee/thread528888.html
*                                 http://javagu.ru/portal/dt?last=false&provider=javaguru&ArticleId=GURU_ARTICLE_81612&SecID=GURU_SECTION_80693

* (10 заметок о модификаторе Static в Java) http://info.javarush.ru/translation/2014/04/15/10-заметок-о-модификаторе-Static-в-Java.html
                                            https://habrahabr.ru/post/133237/
                                            http://www.quizful.net/post/java-fields-initialization
                                            
* (Database Connection Pool) https://m.habrahabr.ru/post/101342/
                             https://m.habrahabr.ru/post/87973/
*            (Кэш Hibernate) http://articles.javatalks.ru/articles/26

* http://reka-neva.blogspot.com/2014/08/java-ee.html
*                http://www.warenhaus.com.ua/?p=1088
*                http://www.warenhaus.com.ua/?p=1093
*                http://www.warenhaus.com.ua/?p=1095 >> https://github.com/TalismanFR/MyBlog/blob/article9/myblog/src/java/controller/private_controller.java

* (SSL и ISC: Часть 1. Что такое протокол SSL и зачем он нужен?) https://www.ibm.com/developerworks/ru/library/ac-iscssl1/
                                                                 http://javagu.ru/portal/dt?last=false&provider=javaguru&ArticleId=GURU_ARTICLE_81612&SecID=GURU_SECTION_80693











##J2EE-приложение

Первым делом сама Операционная Система уже реализует все требуемые функции локально (на компьютере).


Сервер приложений управляет выполнением Java EE компонентами.
Java EE компоненты выполняются в контейнерах сервера приложений.
Контейнеры являются интерфейсом между компонентом и низкоуровневой функциональностью, которая поддерживает компонент, также предоставляя стандарнтые сервисы (Security, JTA, JNDI, Web Services, JMS, JPA и другие), которыми могут воспользоваться компоненты.

Технология Enterprise JavaBeans определяет набор универсальных компонентов предназначенных для многократного использования - называются Enterprise beans.
При создании распределенных систем её бизнес-логика реализована на уровне этих компонентов.


[Java EE сервер приложений](http://dou.ua/lenta/articles/java-ee-application-server/)
[Лучше иногда падать, чем никогда не летать](http://www.warenhaus.com.ua/?p=1088)

![jeearchitecturediagram](http://dou.ua/wordpress/wp-content/uploads/2008/11/jeearchitecturediagram.jpg)

. http://java-course.ru/student/book2/scheme/
. http://java-course.ru/student/book2/hibernate-first/
. http://java-course.ru/student/book2/data-structure/
. http://reka-neva.blogspot.com/2014/08/java-ee.html
. http://www.warenhaus.com.ua/?p=1093
. http://www.warenhaus.com.ua/?p=1095

https://netbeans.org/kb/docs/javaee/javaee-gettingstarted_ru.html
https://netbeans.org/features/java-on-server/java-ee_ru.html

*** [Java для белок ** Основы EJB: часть 1](http://j4sq.blogspot.com/2011/10/ejb-1.html)
** [EJB контейнер предоставляет следующие сервисы:](http://onedeveloper.ru/article?id=7)
** [Контейнер, в частности, обеспечивает:](http://www.interface.ru/home.asp?artId=4223)
*** [Методология построения корпоративных информационных систем на основе технологии EJB](http://www.javaportal.ru/java/articles/infsysejb23.html)

----------[ http://www.javaportal.ru/java/articles/infsysejb23.html ]
> JNDI (Java Naming Directory Interface) - эта служба позволяет Вашим клиентскими приложениям находить на сервере приложений EJB компоненты по их имени
> Transaction Service - этот сервис предоставляет похожие услуги транзакций как в обычных реляционных базах данных только вместо SQL-запросов вызываете методы изменяющие состояния компонентов
> Security Service - сервис безопасности ограничивает доступ к EJB компонентам
> JMS (Java Message Service) - сервис асинхронных сообщений, берет всю ответственность за доставку и хранения очередей сообщений, что значительно разгружает клиентские приложения
> Контейнер - предоставляет среду в которой могут функционировать Ваши компоненты EJB:
  >> Разбор XML-описания компонента EJB (deployment descriptor) и поддержка конфигурации, описанной в этом XML-файле
  >> Управление жизненным циклом компонента EJB
  >> Разбалансировка нагрузки компонентов EJB и управление пулом таких объектов
  >> Управление транзакциями (СУБД) в компонентах EJB
  >> Управление безопасностью доступа к компонентам
----------[ http://citforum.ru/internet/javascript/enterpjavabeans.shtml  http://javatalks.ru/topics/27260  http://ejb.javadev.ru/SessionBeans.php  https://abhirockzz.wordpress.com/2015/02/19/valid-cdi-scoped-for-session-ejb-beans  http://www.comprice.ru/articles/detail.php?ID=42576&print=true  ]
Сессионные EJB бины и сеанс (сессия клиента) это разные вещи которые пытаются объеденить, они дополняют друг-друга чтобы расширить функциональные возможности...
Сессионный EJB бин - это класс с набором своих методов и полей.
Сеанс (сессия) - это состояние полей клиентской формы, которые храняться в файле на стороне сервера.

  Класс-бина содержит набор методов.
  Когда клиентский запрос вызывает такой класс-бина, при этом создается новый объект.
> Но за каждый-один запрос клиент может вызвать только один-метод из объекта класса-бина. После того как метод будет выполнен объект класса-бина освобождается и удаляется... - так работает Stateless-бин
  Поэтому в этом случае основную роль играют методы класса-бина - то есть интерфейс класса-бина (а не сам класс-бин).
> Объект Stateful-бина (в отличии от Stateless-бина) не удаляется после того как метод будет выполнен, а продолжает существовать И при этом хранит свое состояние между отдельными клиентскими запросами.
  (Этот момент важно непутать с бинами Spring-а: там за каждый-один клиентский запрос объект будет существовать пока клиент с ним работает И можно вызывать много разных методов этого объекта...)
> Обычно Stateless-бин применяется для веб-сервисов (API) которые завершаются в одну операцию
> Обычно Stateful-бин применяется для работы в клиентском сеансе (сессии).
  Тоесть, объект Stateful-бина привязывается к клиентскому сеансу (сессии) и удержывается на все время пока существует открытый клиентский сеанс (сессия).
  При обращении через клиентский веб-броузер, он (программа веб-броузера) держит у себя поле ID-сессии и автоматически включает его в передачу с клиентским запросом
  Таким образом по ID-сессии сервер определяет жизненую активность клиентского сеанса (на серверной стороне) И пока сеанс живой объект Stateful-бина продолжает жить...
> Класс-бина реализует бизнес-логику через свои методы.
  Локальный (Local) класс-бина - это (EJB-компонент) такой объект который размещается только на серверной стороне...в EJB-контейнере И имеет только методы для реализации бизнес-логики
  Удаленный (Remote) класс-бина - это такой объект который размещается на стороне клиента.
  В этом случае создается два объекта класса-бина:
  - один удаленный объект класса-бина размещается на стороне клиента (использует клиентскую JVM) и имеет только методы бизнес-логики. Удаленный объект класса-бина связывается с (EJB-компонентом) локального объекта класса-бина через RMI-механизм...
  - другой локальный объект класса-бина размещается на стороне сервера (использует серверную JVM) и имеет методы бизнес-логики + методы спецификации которые позволяют управлять этим (EJB-компонентом) локального объекта класса-бина
  Зачем нужен 'Локальный' и 'Удаленный' объект класс-бина: для того чтобы безопасно привязываться к интерфейсу
  (испольнительным объектом в такой структуре является локальный EJB-компонент класса-бина и он может изменять свой интерфейс-методы ЕСЛИ разные клиенты привязываются к этому интерфейсу это может привести к несовместимости интерфейсов ПОЭТОМУ RMI-механизм гарантирует совместимость интерфейсов через 'Удаленный' объект класса-бина для всех клиентов...)
  Еще особенность Удаленного (Remote) класса-бина в том, что его состояние храниться на стороне клиента. Он используется в паре только с объектом Stateful-бина И освобождает Локальный объект класса-бина от хранения состояния на стороне сервера
> (CDI scope) Жизненный цикл для вложенных объектов классов-бинов зависит-ограничен областью своего родителя
  - Если внутри, методами объекта Stateful-бина вызвать Stateless-бин > в этом случае объект Stateless-бина будет уничтожен сразу-же после того как отработает только один его метод (при этом объект Stateful-бин останется жить...)
  - Если внутри, методами объекта Stateless-бина вызвать Stateful-бин > в этом случае объект Stateful-бина будет уничтожен вместе с объектом Stateless-бина (поскольку только объект Stateless-бина будет хранить ссылку на объект Stateful-бина...)
> AJAX (в отличие от программы веб-броузера) НЕпредназначен для работы с сеансом (сессией)
  (HTTP-протокол является синхронным он привязывается к клиенту/сеансу поэтому работает медленее дожидаясь ответа; SMPT-протокол является асинхронным поэтому работает быстрее НЕдожидаясь ответа но гарантирует доставку;)
  HTTP-протокол поддерживает сеансы (сессии). По умолчанию сеанс (сессия) включена на стороне сервера И длиться 30-минут.
  Но для того чтобы иметь возможность использовать этот сеанс (сессию) нужно получить ID-сессии клиента (не зная ID-сессии нельзя воспользоваться сеансом (сессией))
  Программа веб-броузера автоматически это получает и отправляет ID-сессии клиента в клиентских запросах....
  Клиентские запросы которые проходят через AJAX тоже могут инициализировать сенс (сессию) сессию на стороне сервера НО AJAX неможет авоматически получать ID-сессии клиента
  Если принудительно включить ID-сессии клиента в клиентские запросы которые проходят через AJAX > тогда сеансом (сессией) тоже можно будет воспользоваться (НО такой принудительный подход непредвиденный и неправильный...)
> По своей природе 'Сесионные компоненты' являются времеными - они временно хранят информацию о состоянии клиентских запросов на стороне сервера И если случиться сбой на стороне сервера тогда состояние 'Сесионных компонентов' НЕвостанавливается
  EntityBeans по своей природе являются долгосрочными - они хранят информацию о состоянии на стороне базы данных  И если случиться сбой на стороне сервера тогда состояние 'EntityBeans компонентов' можно востанавливить!

> Локальный-объект - это реализация интерфейса, который расширяет интерфейс javax.ejb.EJBHome. В нём есть необходимые для работы методы create(), find() и remove(), каждый из которых соответствует ejbCreate(), ejbFind() and ejbRemove(), с той же сигнатурой, что указана в реализации конкретного создаваемого бина. Также здесь представлены методы для получения метаданных этого бина
  Интерфейс EJBHome определяется в спецификации так:
	public interface javax.ejb.EJBHome extends Remote {
		public abstract void remove (Handle handle) throws RemoteException, RemoveException;
		public abstract void remove (Object primaryKey) throws RemoteException,RemoveException;
		public abstract EJBMetaData getEJBMetaData() throws RemoteException;
	}
> Удаленный-объект - это видимый в сети объект с собственной стуктурой и наполнением, действующий как proxy бина. Имеющийся у бина remote-интерфейс 'javax.ejb.EJBObject' расширяет интерфейс делая, таким образом, класс EJBObject специфическим для данного класса бина.
----------[ http://j4sq.blogspot.com/2011/10/ejb-1.html  http://www.intuit.ru/studies/courses/571/427/lecture/9707  http://devcolibri.com/2044 ]
EJB делится на 3-типа компонентов:
> Session beans
  могут находиться в одном из двух состояний либо Stateful либо Stateless
  Область действия разных сессионных бинов (вложеного бина) ограничивается пределами выше стоящего своего бина
  >> Stateful-бины автоматически сохраняют свое состояние между разными клиентскими вызовами
     // @StatefulTimeout(value=5, unit=TimeUnit.SECONDS)
     (Состояние сохраняется в памяти все время пока клиент использует сессию)
     (Сеансовый компонент с состоянием не может использоваться несколькими клиентами. Он выделяется для одного клиента на все время своей жизни)
     У stateful бинов существует 4-события жизненного цикла которые мы можем перехватить (Жизненный цикл EJB3):
     >>> @PostConstruct - метод который будет вызываться сразу после создании бина
     >>> @PreDestroy - метод который будет вызываться перед его удалением
     >>> @PostActivate - метод который будет вызываться при активации бина
     >>> @PrePassivate - метод который будет вызываться при ДЕактивации бина
     Stateful-бин (с состоянием) Удаленный объект класса-бина может иметь один метод-спецификации для управления локальным (EJB-компонентом) класса-бина: 'create()', 'find()', 'remove()' и еще несколько таких методов дополнительно с аргументами
  >> Stateless-бины используются для реализации бизнесс-процессов, которые могут быть завершены за одну операцию
     (Сеансовые компоненты без состояния имеют более высокую производительность с точки зрения пропускной способности и потребления ресурсов)
     (Применяется для обслуживания большого количества клиентов)
     У stateless и MDB бинов существует 2-события жизненного цикла которые мы можем перехватить (Жизненный цикл EJB3):
     >>> @PostConstruct - метод который будет вызываться сразу после создании бина
     >>> @PreDestroy - метод который будет вызываться перед его удалением
     Stateless-бин (без состояния) должен иметь только один метод с таким-же именем и без аргументов
  >> Singleton-бины - гибрид общий для клиентов но хранит состояния
     работают по аналогии как статические методы...они могут быть вызваны разными клиентами при этом хранят состояние одинаково для всех клиентов (такой себе глобальный объект...)
  >>> Local - относится к интерфейсу и говорит, что bean реализующий интерфейс доступен локально
              (используется одна и таже виртуальная машина)
  >>> Remote - относится к интерфейсу и говорит, что bean доступен через RMI (Remote Method Invocation). опциональная аннотация, которая используется с stateful бинами. Метод, помеченный как Remove говорит контейнеру, что после его исполнения нет больше смысла хранить bean, т.е. его состояние сбрасывается
               (используеются разные виртуальные машины (даже если на одном хосте))
> Message-driven beans
  >> клиенты никогда не вызывают MDB напрямую, обычно сервер использует MDB в асинхронных запросах
> Entity beans (Entities и Java Persistence API)
  >> новый механизм работы с persistence - возможность автоматически сохранять объекты в реляционной БД используя технологию объектно-реляционного маппинга (ORM):
     >>> конфигурации маппинга сущностей приложения и их отображения в таблицах БД
     >>> EntityManager API - стандартный API для CRUD (create, read, update, delete) операций над сущностями
     >>> Java Persistence Query Language (JPQL) - для поиска и получения данных приложения
  Удаленный объект класса-бина может иметь методы-спецификации для управления локальным (EJB-компонентом) класса-бина: 'create()', 'find()', 'remove()'
----------[ http://javasource.ru:5050/articles.xhtml?artlink=general-information-about-ejb-jpa ]
> EJB делает все компоненты ориентированными на многопоточное исполнение и высокопроизводительными.
  Серверные компоненты можно писать так же, как и однопоточные настольные приложения. Многопоточное исполнение обеспечивается технологией EJB.
> Для каждого компонента EJB платформа EJB создает пул совместно используемых клиентами экземпляров компонента.
  В любой момент времени каждый экземпляр из пула может использоваться только одним клиентом.
> EJB поддерживает управление объявленными транзакциями, которое позволяет добавить транзакционное поведение к компонентам путем настройки, а не программирования.
> Безопасность: EJB поддерживает интеграцию с интерфейсом API службы проверки подлинности и авторизации Java (JAAS)
------------------------------------------------------------------------------------------------------------------
.. Библиотека - это набор классов с уже готовой реализацией
                (разработчик подключает такую библиотеку в свой код И использует только интерфейс-методы библиотечных классов...)
                В принцыпе сама по себе библиотека она ничего полезного неделает (она применяется только для реализации других разрабатываемых модулей...)
.. API - это (НЕ библиотека) прежде всего Веб-сервис в котором уже заложена какая-то бизнес-логика
         Прежде всего API это уже работающее-живое приложение веб-сервиса (обращаясь к API веб-сервиса в результате разработчик может получить уже реальный ответ...)
         API это НЕ библиотека И чтобы подключить API к своему приложению это можно сделать с помощью вызова удаленных процедур (технология RPC), например через SOAP-реализацию
         (используя SOAP-реализацию для обращения к Веб-сервису, такаим образом разработчику нужно знать только удаленные методы - интерфейс класса << и нестолько важно где работает и как подключиться по URL к этому Веб-сервису, потому-что за эти настройки автоматически генерит AXIS2-утилита, НЕразработчик)

1. Сессионые бины, управление жизненным циклом компонента EJB
   - Понимание того что каждый клиентский HTTP-запрос всегда является одиночным/одтельным.
     Это значит что два отдельных клиентских HTTP-запроса, идущих по попорядку, НЕсохраняют состояние одного и того-же объекта между собой...
     Для того чтобы объект, который был создан в разных клиентский HTTP-запросах, сохранял свое состояние между разными HTTP-запросами - это достигается с помощью механизма сериализации
   - Время создание объект, иннициализация объекта, время удаление объекта, период жизни-существование объекта - этот процес контролируется сессионными бинами

2. EntityBean (бины сущностей), управление транзакциями
   - (Persistence) представляет таблицы базы данных в виде (Java) объектов класса
   - Выполнение запросов на выборку или запись данных в базу выполняется с помощью SQL-инструкций
     Получение или сохранение сущности из базы данных в объект-класса выполнение контролируется автоматически 'Entity Bean' ...по запросу 
   
3. Передача-обмен сообщениями (Java Message Driven)
   - Понимание того что для веб-приложений всегда существует 'серверная сторона' и 'клиентская сторона'
     И 'серверная сторона' и 'клиентская сторона' представляет собой компютер с установленной Операционной Системой.
     То есть, на уровне Операционной Системы уже реализованы необходимые для работы функции...
   
   - На 'клиентской стороне' стоит (клиентская JavaScript) виртуальная Java-машина, AJAX через JVM (асинхронные Java...XML...объекты) обращается к Операционной Системе и через которую выполняются клиентские обращения к серверу...
     А также на 'клиентской стороне' есть программа веб-браузера, которая умеет иммитировать клиентские обращения к серверу и работает тоже с помощью Операционной Системы
   - На 'серверной стороне' стоит (серверная Java) виртуальная Java-машина, которая обращается к Операционной Системе и через которую выполняются серверные обращения к клиентам...
     А также на 'серверной стороне' есть сервер приложения - который теоритически позволяет создавать/строить все необходимые компоненты замещая реализацыю и работу обычного серверного приложения...

   - 'Сокет' - отвечает за поддержку/выполнение клиентских и серверных функций (это такое себе гнездо, которое позволяет соединить клиентское приложение с серверным приложением...)
   - 'Протокол' - это просто набор правил, которые служат для передачи данных-объектов между клиентом и сервером...
     Существуют разные протоколы, например протоколы для передачи данных в интернет (TCP/IP):
        (протоколы 'сеансового уровня' и 'уровня представления' - отсутствуют)
        (на транспортном/прикладном уровне)
     -- HTTP (применяется для синхронной передачи любых-больших текстовых сообщений)
     -- FTP (применяется для передачи файлов и представления файловой системы)
        (другие)
     -- SMTP (JMS-MQ: применяется для асинхронной передачи коротких текстовых сообщений... в отличии от веб-сервисов, jms является более надежным механизмом доставки сообщений)
     -- HTTPS (надстройка HTTP-протокола, применяется для шифрования канала передачи данных через HTTP-протокол: цифровой пописью,... Обычно шифруются клиентские данные-формы из веб-браузера)
     -- DBMS (семейство протоколов 'ODBC/JDBC/ADO/DAO/RDO/DBE' применяется для универсального доступа к данным хранящихся на разных СУБД используя единый SQL-стандарт)
     -- SSH (применяется для удаленной работы на уровне системных команд)
     Поэтому чтобы построить клиент-серверное приложение нужно:
     > реализовать сокет;
     > выбрать каким протоколом будет обеспечиваться поддержка передачи данных;
     > серверная часть должна иметь реализацию набора функций для обработки клиентских обращений; клиентская часть должна иметь реализацию для выполнения/формирования-запроса клиентских обращений и возможность их представления;

   - Также существуют и разные форматы данных (которые передаются):
     -- JSON (данные в простой текстовой форме)
     -- XML (это тоже текстовая форма НО здесь применяется механизм-анализа структуры разметки...что позволяет следить за подлиностью данных)
     -- HTML (это тоже текстовая форма НО здесь применяется теги для превращения текста в гипертекст в веб-браузере...)
   - Чтобы представить/отрисовать клиентскую веб-страничку согласно стилям и прочее... в веб-браузере - применяется HTML-формат данных
   - Чтобы запросить/получить клиентскую информацию согласно бизнес-логике веб-приложения (этим занимаются веб-сервисы из API...) - применяется JSON/XML-формат данных
        (удаленный вызов процедур)
     -- В отличии от jms, веб-сервисы применяется для синхронной передачи текстовых сообщений.
     -- Любые/все передаваемые данные в текстовых сообщениях являются объектами и соответственно обрабатываются как объекты.
     -- REST (концепция JAX-RS) может использовать: XML/SON; только HTTP (синхронно); GET/POST/PUT/DELETE; + в основе лежит концепция ресурсов + интерфейс ограничен GET/POST/PUT/DELETE операциями HTTP-методам
     -- RPC (удаленный вызов процедур и удаленных методов JAX-RPC) только HTTP (игнорировал привязку HTTP); асимметричность (одна из сторон является инициатором); синхронность (выполнение вызывающей процедуры приостанавливается с момента выдачи запроса и возобновляется только после возврата из вызываемой процедуры); + от HTTP-метода не зависит + разработчик сервиса описывать API/методы + поддерживает шифрование SOAP
     -- SOAP (семейство протоколов/стандартов JAX-WS, расширение JAX-RPC: Simple Object Access Protocol — протокол обмена структурированными сообщениям для реализации удалённого вызова процедур 'RPC') может использовать: только XML; как организовать передачу сообщений FTP/SMTP/HTTP/HTTPS  (../асинхронно/синхронно/..); только POST; + строгая типизация данных + разработчик сервиса описывать API в файле формата 'WSDL' + использует интерфейсы основанные на объектах и методах

4. Защита (Security), управление безопасностью доступа к компонентам
   (это НЕ на уровне протокола (SSL): HTTPS-протокол который является надстройкой HTTP-протокола с цифровой пописью...AuthorizationBase64)
   - это есть: описание динамической-структуры ролевой политики прав доступа; группы пользователей; способа аудитентификации, ...
     (1) Использование фильтров, чтобы покрыть клиентские URL-запросы для гарантированной защиты
     (2) Установка защищиты на метод в классе...
   - (это на уровоне сервера приложений строиться безопасность)
     -- поскольку на сервере приложений может находиться много разных приложений И для каждого отдельного приложения поддерживается своя независимая защита...поэтому:
        > существует глобальные правила безопасности, которые определяются одинаково для всех приложений на этом сервере, это (динамическая): ролевая политика прав доступа (ограничивает доступ по типу операций)
     -- пользователи или группа пользователей (куда входит этот пользователь) могут иметь разные права в разных приложениях...поэтому:
        > существует локальные правила безопасности, которые определяются по разному для отдельных приложений на этом сервере (на какой-то метод или URL-ресурс ограничивается доступ к этому приложению для отдельного пользователя...)
     Таким образом общая картина безопасности для J2EE-приложения имеет несколько этапов:
     > на уровне протокола-HTTPS (SSL: протокол обвертывает обвертывает сервер приложения, такой себе промежуточный слой, который защищает доступ ко всему серверу приложения)
     > на стороне сервера приложения (настройка глобальной и локальной безопасности, правила доступа которой строится на сервере приложения: на уровне всего сервера приложений; на уровне отдельно взятого приложения;)
     > XML-анализ DOM-структуры документа JAXB/XStream-парсером (для предварительной проверки целостности документа перед тем как вызывать удаленную процедуру

5. Паралельные процессы, управление пулом объектов (компонентов EJB) разбалансировка нагрузки

X. Сеанс (сессия) в J2EE-приложении
   - (это НЕ сессионные компоненты EJB)
     (сессионные компоненты EJB - управляют жизненным цыклом объектов-бинов на стороне сервера)
     Сеанс (сессия) - устанавливает и сохраняет сеанс-состояние между клиентом и сервером. Дело в том что сеанс (сессия) НЕявляется составляющей протокола (FTP/SMTP/HTTP/HTTPS) - это надстройка HTTP-протокола.
     Сеанс (сессия) создается при первом обращении 
----------[ http://www.javaportal.ru/java/articles/Java_Server_Pages.html ]
     Если для связи с клиентом используется HTTP-протокол тогда для каждого сеанса (по умолчанию) создается объект-session позволяющий сохранять информацию об этом клиенте в интервале между его обращениями к серверу.
     (Если атрибут-session был указан со значением 'false' - это позволяет отказаться от создания объекта-сессии И использовать освободившиеся ресурсы сервера)
----------[ http://jperm.wikia.com/wiki/Управление_сеансами_в_Java ]
     HTTP-протокл работает по своей природе как запрос-ответ. В HTTP-протоколе нет возможностей для сохранения и изменения информации о предыдущих посещениях клиента. Но иногда надо хранить информацию между запросами.
     Есть три способа отслеживания сессии:
     1) cookies
     2) переопределяемый URL (используется response.encodeURL() для каждой ссылки который вставляет идентификатор сессии в каждый URL) 
     3) спрятанные поля HTML-страницы (в виде скрытых полей в форме) 
----------[ http://crypto.pp.ua/2010/06/seans-sessiya-v-java/ ]
     Чтобы открыть новый сеанс используется метод 'getSession()' - извлекает из переданного в сервлет запроса объект-сессии
     Если входной параметр равен 'true' то сервлет-контейнер проверяет наличие активного сеанса установленного с данным клиентом. В случае успеха метод возвращает дескриптор этого сеанса. В противном случае метод устанавливает новый сеанс: 
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException {
    HttpSession session = request.getSession(true);
}
     Чтобы сохранить значения переменной в текущем сеансе, используется метод 'setAttribute()'
session.setAttribute()
     Чтобы прочесть – 'getAttribute()'
session.getAttribute()
     Чтобы удалить – 'removeAttribute()'
session.removeAttribute()
     Чтобы вернуть уникальный идентификатор который получает каждый сеанс при создании 'getId()'
session.getId()
     Метод 'isNew()' - возвращает 'false' для уже существующего сеанса и 'true' для только что созданного
     Чтобы завершить сеанс можно методом 'invalidate()'
     Также сессиями можно управлять <session-config> в web.xml
<session-config>
    <session-timeout>
    20
    </session-timeout>
</session-config>
----------
     Итак при первом обращении через HTTP-протокол сервер приложения создает сеанс (сессию).
     Сессия (сеанс) создается на стороне сервер как файл с данными... Такой файл имеет уникальное имя - которое является идентификатором сеанса... И такое имя файла (идентификатором сеанса) возвращается клиенту...
     Время сессии (сеанса) начинает истекать с момента последней активности клиента с сервером. 

   - На клиентской стороне есть:
     -- клиентская программа веб-браузера (которая может хранить-управлять поле идентификатора-сессии) позволяет держать идентификатор-сеанса И по идентификатор-сеанса получать-востанавливать состояние полей формы...
        Таким образом для клиентской программы веб-браузера сессии (сеансы) являются полезными!
     -- клиентская виртуальная Java-машина (JavaScript). Собствено AJAX-запросы (которые работает на JavaScript) обращаются к веб-сервису...
        AJAX-запросы которые обращаются по HTTP-протоколу к веб-сервису тоже создается объект-сессии...
        Но дело в том что в AJAX-запросах непредвидено работа с сеансами (сессиями)... то есть, даже если AJAX-запрос получит идентификатор-сеанса такая возможность восстановиться на клиентской стороне непредвидена!
        Поэтому сессии (сеансы) для работы с веб-сервисами являются бесполезными И обычно состояние для таких объектов (компонентов EJB) делают 'Stateles'



(rpc и rest)
http://www.linux.org.ru/forum/web-development/9233445
http://www.comprice.ru/articles/detail.php?ID=42533
https://books.google.com.ua/books?id=zVpUBQAAQBAJ&pg=PA722&lpg=PA722&dq=java+%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B+rpc&source=bl&ots=O1Btvc3B2Z&sig=7lVqgkDpEHyI2UKDaOH6OgBp6R4&hl=ru&sa=X&ved=0ahUKEwjOkbGN_P3LAhUFZCwKHbzzBKUQ6AEITDAJ#v=onepage&q=java%20%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D1%8B%20rpc&f=false
https://www.ibm.com/developerworks/ru/library/ws-tip-jaxwsrpc/
https://ru.wikipedia.org/wiki/JSON-RPC
https://ru.wikipedia.org/wiki/Удалённый_вызов_процедур
(soap что это)
http://xmlhack.ru/texts/04/ws.in.java.tech/WebServiceinJava_axis10.html
https://ru.wikipedia.org/wiki/SOAP
http://ru.stackoverflow.com/questions/257184/Что-такое-soap
https://habrahabr.ru/post/158605/
http://javatalks.ru/topics/14493
(протокол http jms)
https://habrahabr.ru/post/248453/
http://www.sql.ru/forum/634689/skorost-webservice-vs-jms
http://www.ibm.com/support/knowledgecenter/SSFPJS_8.0.1/com.ibm.wbpm.main.doc/topics/esbprog_bindings_ws5.html?lang=ru
(DBMS протокол что это)
http://www.interface.ru/magazine/tcs/Archive/298/cic_tcs.htm
https://ru.wikipedia.org/wiki/Java_Database_Connectivity
https://javatalks.ru/topics/7147
http://www.javaportal.ru/java/tutorial/tutorialJDBC/intro.html
http://www.javable.com/columns/jdbc/workshop/01/

http://www.java2ee.ru/jsp/useBean.html
http://www.intuit.ru/studies/courses/633/489/lecture/24847
http://www.ibm.com/developerworks/ru/library/j-jtp07294/

(@MessageDriven(mappedName = "jms/NewMessage", activationConfig) https://netbeans.org/kb/docs/javaee/javaee-entapp-ejb_ru.html







(j2ee controller rest Content-type: application/json application/xml)
* (Integrating Swagger Into JAX-RS With Java EE 6 Specification) http://jmchung.github.io/blog/2013/12/14/integrating-swagger-into-jax-rs-with-java-ee-6-specification/
                                                                 https://github.com/jmchung/swagger4javaee/blob/master/swagger4javaee-web/src/main/java/com/example/rest/service/HTML5CorsFilter.java
* (The REST service: @Path, @Produces, @Consumes) http://tomee.apache.org/examples-trunk/rest-xml-json/README.html

. http://crunchify.com/what-is-cross-origin-resource-sharing-cors-how-to-add-it-to-your-java-jersey-web-server/
. http://crunchify.com/simple-way-to-get-http-response-header-in-java/
http://www.slideshare.net/caroljmcdonald/rest-with-java-ee-6-security-backbonejs
. http://coenraets.org/blog/2011/12/restful-services-with-jquery-and-java-using-jax-rs-and-jersey/
http://stackoverflow.com/questions/16335591/spring-mvc-json-406-not-acceptable
. https://www.ibm.com/developerworks/ru/library/wa-restful/
http://stackoverflow.com/questions/30548822/spring-mvc-4-application-json-content-type-is-not-being-set-correctly

(rest передать json или xml)
* (Web-сервисы RESTful: основы) http://www.ibm.com/developerworks/ru/library/ws-restfu/
* (Зачем нужен этот ваш REST, а также о некоторых тонкостях реализации RESTful приложений) http://eax.me/rest/
* (REST vs SOAP. Часть 1. Почувствуйте разницу) https://habrahabr.ru/post/131343/
 SOAP – это целое семейство протоколов и стандартов
* (Архитектура REST) https://habrahabr.ru/post/38730/
REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем

. http://anton.shevchuk.name/php/create-restful-api/
https://yiiframework.com.ua/ru/doc/guide/2/rest-quick-start/
. http://html-templates.info/blog/znakomtes-arhitektura-REST

(что такое rest протокол)
http://api.mail.ru/docs/guides/restapi/
------------------------------------------------------------------------------------------------------------------

------------------------------[ http://www.vogella.com/tutorials/REST/article.html ]
@Path("/todo")
public class TodoResource {
  // This method is called if XMLis request
  @GET
  @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
  public Todo getXML() {
    ...
    return todo;
  }
  
  @GET
  @Produces({ MediaType.TEXT_XML })
  public Todo getHTML() {
    ...
    return todo;
  }

} 

------------------------------[ https://github.com/serega-sergei/test/blob/master/src/main/java/com/test/services/customers/rest/CustomersServiceJSON.java ]
@POST
@Consumes(MediaType.APPLICATION_JSON)
public Response createCustomer(Customer customer) {
	...
	if (creCustomer != null) {
		return ResponseCreator.success(getHeaderVersion(), creCustomer);
	} else {
		return ResponseCreator.error(500, Error.SERVER_ERROR.getCode(), getHeaderVersion());
	}
}

@PUT
@Consumes(MediaType.APPLICATION_JSON)
public Response updateCustomer(Customer customer) {
	...
	if (updCustomer != null) {
		return ResponseCreator.success(getHeaderVersion(), updCustomer);
	} else {
		return ResponseCreator.error(500, Error.SERVER_ERROR.getCode(), getHeaderVersion());
	}
}

------------------------------[ http://www.ibm.com/developerworks/ru/library/ws-restfu/ ]
GET /users/Robert HTTP/1.1
Host: myserver
Accept: application/xml
------------------------------
PUT /users/Robert HTTP/1.1
Host: myserver
Content-Type: application/xml
<?xml version="1.0"?>
<user>
  <name>Bob</name>
</user>
------------------------------
JSON .... application/json
XML ..... application/xml
XHTML ... application/xhtml+xml

------------------------------[ https://habrahabr.ru/post/150034/ >> https://github.com/serega-sergei/test ]
200 — Successful;
401 — Not Authorized;
404 — Not Found;
500 — Server error during operation.

------------------------------[ http://tomee.apache.org/examples-trunk/rest-xml-json/README.html ]
//The REST service: @Path, @Produces, @Consumes
//@Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
//@Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
@Path("/greeting")
@Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
@Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
public class GreetingService {
    @GET
    public Response message() {
        return new Response("Hi REST!");
    }

    @POST
    public Response lowerCase(final Request message) {
        return new Response(message.getValue().toLowerCase());
    }
}


  - REST (JAX-WS) - это (не стандарт) прежде всего концепция
    -- реализовать REST веб-сервис можно либо через 'Spring' фреймворк либо через 'JAX-RS' библиотеку
    -- REST оддерживает такие форматы
       JSON .... application/json
       XML ..... application/xml
       XHTML ... application/xhtml+xml
    -- метод-обработчик REST веб-сервиса (через 'JAX-RS' библиотеку):
       > одновременно может принимать несколько форматов. Для этого нужно:
         >> аннотировать метод обработчик (аннотация '@Path' говорит о том что это является веб-сервис)
            @Path("/hello/{id}")
            @GET
            @POST
            @PUT
            @DELETE
         >> или класс (аннотация '@Path' говорит о том что это является веб-сервис)
            @Path("/hello")
            public static class Resource {
                @Path("/{id}")
                public Response removeCustomer(@PathParam("id") String id) { ... }
         >> аннотацией метода указать
            @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
            @Consumes({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
         >> а также чтобы в хедере запроса был установлен параметр 'Content-Type'
            Content-Type: application/json
            Content-Type: application/xml
            Content-Type: application/xhtml+xml
         >> 
            public Response removeCustomer(@PathParam("id") String id) { ... }
         >> НО если это (НЕ просто веб-сервис) 'сервлет' - тогда он формирует уже полноценую клиентскую HTML-страницу.
            У сервлета есть такие методы как: init(), destroy(), service(), doGet(..) | doPost(..) | ...
            Тобиш, это уже есть что-то большое...полноценная клиентская веб-страница с гиппертекстом (в то время как веб-сервис возращает только текстовую информацию необходимую для вставки на клиентскую веб-страницу)...

  - Web Service (JAX-WS)
    1. Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
				@WebService(name="EntityPortMyType", targetNamespace = "http://my.domain.com/ws/definitions")
				public interface EntityManager{
				    @WebMethod
				    long addEntity();
				
				    @WebMethod
				    long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );
				
				    @WebMethod
				    void removeEntity( @WebParam(name = "id")long id );
				}
     2. Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
        portName        - должен указывать на порт того типа, что прописан в интерфейсе
        targetNamespace - должен быть такой же, как и у интерфейса
        endpointInterface - точно указывать на полное имя реализуемого интерфейса
        wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
				@WebService(serviceName = "EntityManager",
				            portName="EntityPortMyType",
				            endpointInterface = "com.mydomain.webapp.domain.EntityManager",
				            targetNamespace = "http://my.domain.com/ws/definitions",
				            wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")
				
				public class EntityManagerImpl implements EntityManager{
				    public long addEntity(){
				        // method body
				        return 0;
				    }
				
				    public long findEntity(IdentityType i_type, String identity){
				        // method body
				        return 0;
				    }
				
				    public void removeEntity(long id){
				       // method body
				    }
				}
     3. В pom файле проекта необходимо совершить: 
        - вставить код для jaxws-maven плагина, 
        - обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть)
				<plugin>
				        <groupId>org.codehaus.mojo</groupId>
				        <artifactId>jaxws-maven-plugin</artifactId>
				        <executions>
				            <execution>
				                <goals>
				                    <goal>wsgen</goal>
				                </goals>
				            </execution>
				        </executions>
				        <configuration>
				            <resourceDestDir>${basedir}/src/main/webapp/WEB-INF/wsdl</resourceDestDir>
				            <sei>com.my.domain.webapp.domain.EntityManagerImpl</sei>
				            <genWsdl>true</genWsdl>
				            <keep>true</keep>
				            <packageName>com.my.domain.webapp.domain</packageName>
				        </configuration>
				</plugin>
				<dependency>
				     <groupId>com.sun.xml.ws</groupId>
				     <artifactId>jaxws-rt</artifactId>
				     <version>2.1.3</version>
				</dependency>
     4. Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
        - Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
        - Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener)
				 <listener>
				    <listener-class>
				        com.sun.xml.ws.transport.http.servlet.WSServletContextListener
				    </listener-class>
				</listener>
				
				<servlet id="ws-entities-servlet">
				    <servlet-name>EntityService</servlet-name>
				    <servlet-class>
				        com.sun.xml.ws.transport.http.servlet.WSServlet
				    </servlet-class>
				    <load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping id="ws-entities-servlet-mapping">
				    <servlet-name>EntityService</servlet-name>
				    <url-pattern>/app/entities</url-pattern>
				</servlet-mapping>
     5. Создать файл sun-jaxws.xml 
        Но что же сервлет будет делать с запросом, пришедшим на url-pattern?
        В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки:
				<?xml version="1.0" encoding="UTF-8"?>
				<endpoints
				        xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"
				        version="2.0">
				    <endpoint name="EntityManager"
				            implementation="com.my.domain.webapp.domain.EntityManagerImpl"
				            url-pattern="/app/entities"/>
				</endpoints>
     6. Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса
				http://localhost:8080/my-webapp/app/entities?wsdl







  - SOAP - это семейство протоколов
------------------------------[ http://www.ibm.com/support/knowledgecenter/SSFPJS_8.0.1/com.ibm.wbpm.main.doc/topics/esbprog_bindings_ws5.html?lang=ru ]
    -- Протокол SOAP/HTTP рекомендуется для:
       > Внешних веб-служб (например, клиентов или поставщиков)
       > Для простых двухточечных служб и служб без состояния
    -- Протокол SOAP/JMS рекомендуется для:
       > Для масштабного распределенного обмена сообщениями
       > Асинхронного обмена сообщениями
       > Когда требуется граница транзакции в промежуточном ПО
       > Когда получатели сообщений медленнее отправителей
       > Гарантированной доставки или однократной доставки сообщений





























(Changing content type in jax-rs REST service) http://stackoverflow.com/questions/5556897/changing-content-type-in-jax-rs-rest-service
* (How to build RESTful Service with Java using JAX-RS and Jersey (Example)) http://crunchify.com/how-to-build-restful-service-with-java-using-jax-rs-and-jersey/
(Создание Web-сервисов REST при помощи Java-технологий) https://www.ibm.com/developerworks/ru/library/wa-jaxrs/
(Реализуем RESTful Web Service на java) https://habrahabr.ru/post/150034/
* (REST with Java (JAX-RS) using Jersey - Tutorial) http://www.vogella.com/tutorials/REST/article.html
* (REST-сервис на Java — это просто) https://habrahabr.ru/post/115718/
* (Сервлет (Java)) https://ru.wikipedia.org/wiki/Сервлет_(Java)
* (Первое слово о сервлетах) http://java-course.ru/student/book1/servlet/
































