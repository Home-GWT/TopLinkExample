http://www.javabeat.net/spring-bean-scopes-singleton-prototype/
http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
https://github.com/EasyJavaRu/spring-core-scopes
https://habrahabr.ru/post/136140/
http://habrahabr.ru/post/50845/



* http://techo-ecco.com/blog/spring-prototype-scoped-beans-and-dependency-injection/
* http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
* https://github.com/EasyJavaRu/spring-core-scopes
* http://forum.spring.io/forum/spring-projects/container/88202-prototype-scope-bean-injection-into-singleton
* http://www.concretepage.com/spring/spring-bean-scope-example-using-scope-annotation-and-xml-for-singleton-prototype-request-session-global-session-and-application-scope-with-scoped-proxy#download
* http://www.mkyong.com/spring/spring-bean-scopes-examples/


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(JavaBeans vs Spring Beans. Понятие Bean) http://javatalks.ru/topics/31421?page=1
(Основы SpringFramework) http://fan-5.ru/best/best-78377.php
(Правила описания JavaBean) https://ru.wikipedia.org/wiki/JavaBeans
** (Внедрение бинов и иерархия scope + Scoped proxies) http://easyjava.ru/spring/spring-framework/spring-bean-scopes/


(JavaBeans vs Spring Beans. Понятие Bean)
 ---------------------------------------
> JavaBean ...... это класс, который следует JavaBeans спецификации. Главные правила - иметь открытый конструктор по умолчанию и get/set методы для доступа к свойствам. 
> Spring Bean ... это объект, созданный внутри спринг контекста, не более того.

Правила описания JavaBean
=========================
> Класс должен иметь конструктор без параметров, с модификатором доступа public.
  Такой конструктор позволяет инструментам создать объект без дополнительных сложностей с параметрами.
> Свойства класса должны быть доступны через get, set и другие методы (так называемые методы доступа), которые должны подчиняться стандартному соглашению об именах.
  Это легко позволяет инструментам автоматически определять и обновлять содержание bean’ов.
  Многие инструменты даже имеют специализированные редакторы для различных типов свойств.
> Класс должен быть сериализуем.
  Это даёт возможность надёжно сохранять, хранить и восстанавливать состояние bean независимым от платформы и виртуальной машины способом.
> Класс должен иметь переопределенные методы equals(), hashCode() и toString().

Java Beans Specification
========================
> Именования полей класса должны начинаться с маленькой буквы (camelStyle)
> Имена методов доступа к полям должны префиксоваться get-, set-, is-
  Т.е. если поле называется myField, то методы должны называться соответвенно setMyField(), getMyField()
  если поле имеет тип Boolean, то допускается вместо названия метода get- префиксовать is-, например isMyField()
> Элементы <propperty> позволяют задавать значения в экземпляре класса
  В таком случае, SpringFramework, используя механизм reflection устанавливает поля в заданные значения
> В XML файле конфигурации контекста, если тип поля не строка, а например int, то происходит автоматическая конвертация
  Это так же даостигается с использованием механихма reflection. Spring определяет тип, который ожидает метод set- и пытается привести строковое представление значения в файле к этому типу.
  Для этого Spring использует механизм PropertyEditor’ов или конвертеров. Для каждого типа можно зарегистрировать свой конвертер.
> Всё тоже самое доступно и с помощью задания свойств через параметры конструктора
> Именовать бины принято в соответствии со стандартным соглашением по именованию полей Java-классов.
  Т.е. имена бинов должны начинаться со строчной буквы и быть в "Верблюжьей" нотации.
>> По умолчанию, так, как будет назван метод определения бина, по такому имени и нужно получать бин через метод getBean() или автоматическое связывание.
   Однако вы можете переопределить это имя или указать несколько псевдонимов, через параметр name аннотации @Bean.

Жизненный цикл бина
===================
> @PostConstruct, @PreDestroy
> @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod")
> @Component, а также её наследники @Repository, @Service и @Controller.
> @ComponentScan - для того, чтобы ваша конфигурация могла знать о таких компонентах и вы могли бы их использовать, существует специальная аннотация для класса вашей конфигурации
> @Autowired - В большинстве случаев, имеются такие случаи, когда бин в одной конфигурации имеет зависимость от бина в другой конфигурации.
               Поскольку конфигурация является источником определения бинов, то разрешить такую зависимость не является проблемой, достаточно объявить поле класса конфигурации с аннотацией
> @Inject - ищет доступные реализации для класса и сам реашет какую нужно из них нужно-лучше применить
            (при использовании нужно чтобы имя переменной совпадало с именем класса...с учетом того что поля именуются маленькими-строчными буквами)
> @Required - аннотация применяется к аргументу setter-метода в бине и просто указывает на то, чтобы соответствующее свойство бина было установлено на момент конфигурирования значением из определения бина или автоматического связывания.
              Если же значение не будет установлено, будет выброшено исключение.
              Использование аннотации позволит избежать NullPointerException в процессе использования свойства бина.
> @Qualifier - т.к. кандидатов для автоматического связывания может быть несколько, то для установки конкретного экземпляра необходимо использовать аннотацию

Напомними основные обпределение IoC/DI
======================================
> Collaborator – объект или компонент, участвующий в структурных связях и взаимодействиях с целевым объектом (под целевым объектом в данном контексте понимается рассматриваемый класс или объект).
> Dependency Injection – техника внедрения объектов Collaborator’ов в целевые объекты извне, т.е. при помощи дополнительных классов, выступающих в роли Assembler’ов.
  Dependency Injection позволяет избавиться от необходимости жёстко кодировать реализацию конкретного интерфейса непосредственно в целевом классе.
> SpringFramework состоит из набора функциональный групп организованных в примерно 20 модулей.
  Модули сгруппированы в:
>> Core Container – состоит из ядра (Core), бинов (Beans), контекста (Context), специального языка выражений (Expression Language)
>> Data Access / Integration – состоит из модулей для связи с JDBC, ORM (Object Relationship Mapping, OXM (Object XML Mapping), JMS, Transaction)
>> Web – состоит из Web, Web-Servlet, Web-Struts (является устаревшим и вместо него рекомендуется использовать Spring-MVC), Web-Portlet
>> AOP
>> Instrumentation – поддержка модификаций кода классов и загрузки классов для использования в других модулях
>> Test – тестирование с помощью JUnit и TestNG

+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +

> Многие руководства начинают рекомендовать использовать:
  бины с scope 'singleton' для stateless-бинов;
  бины со scope 'prototype' для stateful-бинов;

>> С одной стороны, они конечно правы,так как Spring гарантирует, что данные scope prototype бинов не будут разделены между разными бинами, вызывая конфликты при обращении.
   С другой стороны, scope prototype не гарантирует потокобезопасности и не гарантирует, что один и тот же экземпляр бина со scope prototype будет вызван не более чем в одном потоке, со всеми вытекающими последствями.

>> Бины с разными scope не совсем между собой совместимы.
   если сделать какой-нибудь singleton bean зависящим от request bean - первый существует всегда и он один, второй существует от случая к случаю, зато может существовать в нескольких экземплярах = ошибка будет

> Singleton bean может быть зависимостью для бина с любым scope.
  Сам он может зависеть от бина с singleton scope и prototype scope, причём для каждого singleton бина будет создан свой собственный уникальный экземпляр prototype бина.

>> Аннотации @Autowired, @Inject, @Resource и @Value обрабатываются Spring реализацией BeanPostProcessor, поэтому вы не можете их применять в своих собственных BeanPostProcessor и BeanFactoryPostProcessor, а только лишь явной инициализацией через XML или @Bean метод.
  
+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
http://www.javabeat.net/spring-bean-scopes-singleton-prototype/
http://samolisov.blogspot.com/2012/07/spring-vs-javaee.html
http://www.javaportal.ru/java/articles/spring.html
http://javaxblog.ru/article/java-spring-1/
** (Java Spring. Часть 2 — Inversion of Control) http://javaxblog.ru/article/java-spring-2/
https://habrahabr.ru/post/112488/
(Spring Security/Конфигурирование с помощью пространства имён) https://ru.wikibooks.org/wiki/Spring_Security/Конфигурирование_с_помощью_пространства_имён
** (Описание работы IoC контейнера) http://spring-projects.ru/guides/lessons/lesson-2/
(Spring bean custom scope) https://habrahabr.ru/post/225397/
http://habrahabr.ru/post/50845/
(Dependency injection в Java EE 6) https://habrahabr.ru/post/136140/

> Как и в Spring, у бинов в контексте CDI есть свой скоуп в течении которого они существуют. Скоуп задается с помощью аннотаций из пакета javax.enterprise.context:
  @RequestScoped
  @SessionScoped
  @ApplicationScoped
  Dependent
  @ConversationScoped


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++[ MQ: ActiveMQ, RabbitMQ, JBoss Messaging, Glassfish (Oracle) ]
                (Java Message Service) https://ru.wikipedia.org/wiki/Java_Message_Service
(Работа с JMS сообщениями и MDB в JEE) https://habrahabr.ru/post/162813/
                      (Введение в JMS) http://www.javable.com/columns/serv_side/workshop/14/

Компоненты системы могут посылать сообщения (producer) и получать их (consumer).
(сообщение отправляет producer на пункт назначения (destination), являющимся на сервере queue или topic, после чего consumer может забрать оттуда сообщение)
Сообщение состоит из:
+ заголовка - хранит мета информацию сообщения, заполняемую автоматически
+ поля свойств - схоже с заголовком, но оно заполняется программно, и позже получатель сможет прочитать эту информацию
+ тела - содержит полезную нагрузку сообщения

Message-Driven Bean (MDB) - использование MDB позволит параллельно обрабатывать сообщения, не заботясь о сложности асинхронной обработки и дополнительного кода для подписки на очередь сообщений.
Для реализации MBD достаточно унаследовать бин от интерфейса javax.jms.MessageListener, реализуя метод onMessage(), и аннотировать соответствующим образом класс.
   ------------------------------------------
@MessageDriven(mappedName="jms/TutorialTopic", name = "ExampleMDB")
public class MDBExample implements MessageListener{
    //метод, вызываемый при получении нового сообщения
    @Override
    public void onMessage(Message msg) {
        try {
            TextMessage message = (TextMessage)msg;
            //считываем свойство из соответствующего поля, заданное вручную в consumer
            System.out.println("FROM MDB - client type IS " + message.getStringProperty("clientType"));
            //считываем  само сообщение
            System.out.println("FROM MDB - payload  IS" + message.getText());
        } catch (JMSException ex) {
            ex.printStackTrace();
        }
    }
}
При необходимости, для ручной обработки сообщений можно самостоятельно создать обработчика:
   ------------------------------------------
@Resource(name="jms/TutorialPool")
private ConnectionFactory connectionFactory;

@Resource(name="jms/TutorialTopic")
private Destination destination;

void onMessage(){
    try {
        Connection connection = connectionFactory.createConnection();
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        MessageConsumer consumer = session.createConsumer(destination);
        connection.start();
        while(true){
            Message msg = consumer.receive();
            //обработка сообщения
        }
    //закрыть connection  
    } catch (JMSException ex) {
       ex.printStackTrace();
    }        
}

Message-Oriented Middleware (MOM):
+ Приложение, пославшее сообщение, не должно ждать ответа, и может продолжать свою текущую деятельность.
+ Ни приложение, посылающее сообщение, ни адресат данного сообщения не обязаны быть активными в одно и то же время. Если адресат сообщения не активен, то MOM гарантирует, что сообщение будет доставлено как только адресат станет активным.
+ Компоненты системы не связаны напрямую друг с другом (decoupled), а потому возможно перенесение компонентов с одного хоста на другой в runtime без ущерба для работоспособности системы.

Часто говорят что в point-to-point модели есть один и только один receiver.
Может существовать несколько receivers присоединенных к одной и той же queue. Но MOMдоставит сообщение только одному из них. Какому именно – зависит от реализации. Некоторые MOM доставляют сообщение первому зарегистрированному receiver

> Java Message Service (JMS) – это Java API (то есть набор интерфейсов и классов) для работы с Message-Oriented Middleware.

Доставка сообщений
   ------------------------------------------
Сообщение может быть сохраняемым или несохраняемым.
+ Если сообщение сохраняемо то MOM сохранит его в базе данных или файле. Такое сообщение переживет "гибель" MOM.
+ Какой тип сообщения выбрать зависит от того что ожидаете: большей надежности (в случае сохраняемых сообщений) либо большей производительности (в случае несохраняемых).
+ Можно установить режим доставки сообщения в момент его посылки(по умолчанию режим будет таким, каким его установил администратор при создании ConnectionFactory).

Подтверждение получения сообщения
   ------------------------------------------
JMS поддерживает три "основных" модели подтверждения получения сообщения:
AUTO_ACKNOWLEDGE – в случае синхронного получения сообщений, подтверждение получения будет произведено автоматически
DUPS_OK_ACKNOWLEDGE – работа по подтверждению получения сообщения перекладывается на Session
CLIENT_ACKNOWLEDGE – клиент должен вызвать метод acknowledge() интерфейса javax.jms.Message чтобы явно подтвердить получение сообщения

Посылка сообщений как часть транзакции
   ------------------------------------------
Существует два подхода в использовании транзакций совместно с JMS:
1. Один применим только внутри JMS
2. Второй подход заключается в использовании JTA-транзакций совместно с JMS.
   Может быть использован для включения не только JMS но и например JDBC-запроса в состав той же транзакции
   Этот подход позволяет разработчику включать в единую транзакцию как посылку сообщений, так и запрос к базе данных или EJB.

Важно отменить, что в случае transacted session подтверждение получения будет произведено, когда транзакция будет завершена методом commit() обьекта session, который должен быть вызван клиентом, получающим сообщение (Session включает два метода: commit() и rollback()).
Когда producer использует transacted session, посланные сообщения накапливаются в буфере до тех пор, пока producer не вызовет либо commit(), либо rollback() (в случае вызова commit() сообщения будут доступны для доставки, в случае вызова rollback() JMS очистит буфер).



Компонент использующий JMS должен создать соединение с JMS-провайдером:
- (фабрика объектов) 'ConnectionFactory.ConnectionFactory' от которого наследуют 'QueueConnectionFactory', 'TopicConnectionFactory', 'XAQueueConnectionFactory', 'XATopicConnectionFactory'

1) Для того, чтобы получить доступ к ConnectionFactory, программа должна извлечь соответствующую ссылку из JNDI:
   ------------------------------------------
@Resource(mappedName="jms/ConnectionFactory")
private static ConnectionFactory connectionFactory;

2) Следующим шагом является создание соединения с JMS-провайдером:
   ------------------------------------------
Connection connection = connectionFactory.createConnection();
(после как соединение создано, могут быть созданы виртуальные каналы, в рамках которых будет осуществляться передача сообщений - очередь(Queue) и тема(Topic))

3) Для того, чтобы в программе получить ссылку на соответствующий объект:
   ------------------------------------------
@Resource(mappedName="jms/Queue")
private static Queue queue;
   ------------------------------------------
@Resource(mappedName="jms/Topic")
private static Topic topic;
(после того, как соединение с JMS-провайдером установлено и получены ссылки на соответствующие пункты назначения (очередь или тема) может начаться процесс обмена сообщениями)

4) Весь процесс обмена происходит в рамках сессии (Session) которая представляет собой однопотоковый контекст для обмена (передач/приемов) сообщениями
   ------------------------------------------
Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);




1) В рамках сессии приложение может создать ряд объектов, обеспечивающих отправку и приемку сообщений (Message Producers и Message Consumers):
   ------------------------------------------
MessageProducer producer = session.createProducer(queue); // приложение может отправлять сообщения
MessageConsumer consumer = session.createConsumer(queue); // приложение может принимать сообщения
   ------------------------------------------
producer.send(message); // для отправки сообщения достаточно вызвать метод send
   ------------------------------------------
connection.start();             // для синхронного приема сообщения необходимо сначала запустить диспетчеризацию сообщения
Message m = consumer.receive(); // затем вызвать метод receive() || receive(2000) - управление вернется в момент прихода сообщения или по истечению 2-сек.

2) Для асинхронного приема сообщения может быть создан специальный класс-Listener
   ------------------------------------------
Listener myListener = new Listener();
consumer.setMessageListener(myListener); // должен быть зарегистрирован в рамках данного MessageConsumer




Сообщение в JMS – это объект Java, состоящий из двух частей: заголовка (header - находится служебная информация) и тела (body - одержит в себе пользовательские данные) сообщения.
(Тело сообщения содержит в себе пользовательские данные, которые могут быть разной формы: текстовой, сериализуемые объекты, байтовые потоки...)

Типы сообщений:
+ BytesMessage - для передачи потока байт
+ MapMessage - для передачи множества элементов типа «имя-значение» (где имена являются объектами строкового типа, а значения – объектами примитивных типов данных Java)
+ ObjectMessage - для передачи сериализуемых объектов
+ StreamMessage - предназначен для передачи множества элементов примитивных типов данных Java
+ TextMessage - предназначен для передачи текстовой информации

Типичная JMS-программа проходит следующие этапы перед началом производства и потребления сообщений:
1. Ищет ConnectionFactory через JNDI.
2. Ищет одно или более Destination (пункты назначения) через JNDI.
3. Использует ConnectionFactory для создания Connection.
4. Использует Connection для создания одной или более Session.
5. Использует Session и Destination для создания необходимых MessageProducer и MessageConsumer.
6. Запускает Connection.




(Знакомство с JMS 2.0) https://habrahabr.ru/post/184460/
- Синхронное получение JMS
- Асинхронное получение JMS

+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
(запуск примера JMS используя glassfish) http://javatalks.ru/topics/32560
http://kurapov.ee/rus/technology/web/java/jms_client/
http://www.dokwork.ru/2011/09/jms.html
(Модель сообщений JMS) http://anevseev.bestpersons.ru/feed/post88837/
(Разработка собственной системы - требования предъявляемые к нашему серверу очередей) https://habrahabr.ru/company/mailru/blog/216363/
(Вопрос: Очередь с приоритетом) http://forundex.ru/yap/Ocheredj-s-prioritetom-83732
(Проектирование решений с использованием очередей?) http://programmers-in-ua.blogspot.com/2013/09/blog-post_4.html
https://ru.wikipedia.org/wiki/Java_Message_Service
(RabbitMQ: Введение в AMQP) https://habrahabr.ru/post/64192/
(Сценарии интеграции с Apache Camel. Часть 2) http://savepearlharbor.com/?p=231861
https://habrahabr.ru/post/44907/
https://habrahabr.ru/post/184460/
(Боремся с переполнением очередей сообщений в Erlang) http://eax.me/erlang-message-queues/
(Сценарии использования JMS вне системной интеграции) http://samolisov.blogspot.com/2013/05/jms.html
                                                      https://books.google.com.ua/books?id=gEJJCAAAQBAJ&pg=PA515&lpg=PA515&dq=java+queue+назначение&source=bl&ots=Nzjy17quvn&sig=fFvhOHIiPeyJUE2Rxb0eYo1g52I&hl=ru&sa=X&ved=0ahUKEwjlt-vX_4DLAhWBv3IKHWeYBwMQ6AEINDAE#v=onepage&q=java queue назначение&f=false
                                                      https://books.google.com.ua/books?id=FwJGAgAAQBAJ&pg=PA243&lpg=PA243&dq=jms+%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5+%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B5%D0%B9&source=bl&ots=2ZjztozSSA&sig=6GMe4u6j5yelsyTPCzdjf8XpoTU&hl=ru&sa=X&ved=0ahUKEwiYtLXX_IDLAhVDEHIKHSDKD6gQ6AEIXjAI#v=onepage&q=jms%20%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D0%B5%D0%B9&f=false
(Потоки и общая очередь) http://ru.stackoverflow.com/questions/204984/Потоки-и-общая-очередь


Приоритет сообщения устанавливается провайдером во время процесса передачи. 
Приоритет 0 является самым низким приоритетом; приоритет 9 является самым высоким приоритетом.

Испольщование свойств
Свойства устанавливаются перед отправкой сообщения:
При получении сообщения они доступны лишь в read-only режиме, при попытке изменить свойство будет выброшен MessageNotWriteableException. 
Значения свойств могут дублировать какую-то информацию из тела сообещния. 
В общем JMS не определяет политику: для чего могут служить свойства, а для чего не могут, но стоит отметить, что передавать данные в теле сообщения более рационально, чем в свойствах. 
Для лучшей производительности свойства следует использовать лишь для расширения заголовка сообщения, в первую очередь для отбора сообщений селектором.




Часто очереди сообщений используют как связующее звено между различными внутренними подсистемами:
- отложенная обработка пользовательских данных
- передача статистики
- сглаживание нагрузки на относительно медленные системы
- выполнение периодических задач

Использование очередей в Моем Мире:
- Отложенная обработка действий пользователя.
  (не лучшая идея заставлять пользователя ждать, пока вы сохраните его данные в SQL базу или другое хранилище)
  Хорошей практикой является добавление события о пользовательских действиях в достаточно быстрый сервер очередей, после чего можно отвечать клиенту, что операция прошла успешно. 
  Всю остальную работу надежно и эффективно выполнят обработчики очереди.
- Рассылка сообщений, писем и т.п.
  (вам необходимо отослать большое количество данных, при этом не перегрузив хранилища всплеском запросов)
  (самое главное, с помощью очередей легко избежать дублирования сообщений)
  Легко! Варьируя количество обработчиков очереди, размазываем пиковую нагрузку до разумного уровня, чтобы время обработки клиентских запросов в те же источники данных не ухудшилось.
  Для периодических рассылок достаточно после обработки сообщения обновлять время его активации, а не удалять: в нужное время оно снова будет обработано.
- Транспорт для «надежной» статистики.
  (Передача важных (все, что связано с деньгами) данных на агрегаторы статистики)
  Системы агрегации статистики обычно требовательны к ресурсам процессора, и при обработке данных могут не обеспечивать необходимое для frontend-серверов время ответа. 
  Еще одна особенность подобных систем — неравномерная загрузка, обычно связанная с обработкой данных порциями.
  Передача статистики через серверы очередей позволит избежать проблем с нестабильной задержкой и при этом сохранит гарантию доставки.
- Группировка событий.
  Если группа событий будет обращаться к одному и тому же набору данных в других системах, имеет смысл ставить одинаковое время активации, так как даже если установить время активации в прошлом, события отсортированы по времени активации.
- Каскадные очереди.
  (часто необходимо в процессе обработки сообщения выполнить ряд действий, сильно различающихся по необходимым ресурсам)
  Организация конечного автомата из нескольких очередей путем перекладывания данных между очередями по завершении очередного этапа обработки.
  В таком случае разнесение «быстрых» и «медленных» действий по разным этапам (очередям) позволяет эффективно управлять необходимым количеством ресурсов, варьируя число обработчиков для каждой очереди.



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(Коллекции в Java) http://www.school30.spb.ru/csd/java/20101001/school30_collections.pdf
                   http://www.javable.com/docs/books/symbolplus/ent_jb_v3/sample/ch13.pdf
https://habrahabr.ru/post/247015/
(Коллекции (Collections) в Java. Queue) http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-queue.html
https://habrahabr.ru/post/247015/
(Коллекции в java) http://www.4stud.info/java-programming/collections.html
https://habrahabr.ru/company/luxoft/blog/157273/
(Классы-коллекции - Занятие 6) http://math.sgu.ru/sites/chairs/prinf/materials/java/lesson6.htm
(Справочник по Java Collections Framework) https://habrahabr.ru/post/237043/
(10 советов по использованию ExecutorService) https://habrahabr.ru/post/260953/
(Обзор java.util.concurrent.*) https://habrahabr.ru/company/luxoft/blog/157273/
(Параллельные Реализации Очереди) http://spec-zone.ru/RU/Java/Tutorials/collections/implementations/queue.html
                                  https://www.youtube.com/watch?v=XkAjmCIY2WI&list=SP6jg6AGdCNaXo06LjCBmRao-qJdf38oKp&feature=iv&src_vid=jdAuumT9QqQ&annotation_id=annotation_15451 | https://www.youtube.com/watch?v=jdAuumT9QqQ

Интерфейс 'Queue' (унаследован от интерфейса Collection) - описывает очередь. Элементы могут добавляться в очередь только с одного конца, а извлекаться с другого (аналогично очереди в магазине)
+ poll() – возвращает первый элемент и удаляет его из очереди
Методы интерфейса Queue:
+ peek() – возвращает первый элемент очереди, не удаляя его
+ offer(Object obj) – добавляет в конец очереди новый элемент и возвращает true, если вставка удалась

Queue:
- PriorityQueue (прямой реализацией интерфейса Queue, LinkedList - так же реализует этот интерфейс, но был реализован намного раньше)
                Особенностью данной очереди является возможность управления порядком элементов (по-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди)
- ArrayDeque (реализация интерфейса Deque, который расширяет интерфейс Queue)

- ConcurrentLinkedQueue<E> - используется wait-free алгоритм (этот алгоритм довольно эффективен и, что самое важное, очень быстр, т.к. построен на CAS)
- ConcurrentLinkedDeque<E> - данные можно добавлять и вытаскивать с обоих сторон, поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out)
- BlockingQueue<E> - (если потоки разгребающие очередь перестанут справляться с наплывом данных, то можно довольно быстро схлопотать out of memory или перегрузить IO/Net) для таких случаев нужна queue с возможностью задать размер очереди или с блокировками по условиям.
- LinkedBlockingQueue<E> - реализованная на «two lock queue» алгоритме, один лок на добавление, другой на вытаскивание элемента (за счет двух локов по сравнению с ArrayBlockingQueue, данный класс показывает более высокую производительность, но и расход памяти у него выше)
- PriorityBlockingQueue<E> - многопоточной оберткой над PriorityQueue (при вставлении элемента в очередь его порядок определяется в соответствии с логикой Comparator'а или интерфейса-Comparable у элементов. Первым из очереди выходит самый наименьший элемент)
- SynchronousQueue (cинхронные очереди - работает по принципу один вошел, один вышел. Каждая операция вставки блокирует «Producer» поток до тех пор, пока «Consumer» поток не вытащит элемент из очереди и наоборот)
- TransferQueue<E> - при добавлении элемента в очередь существует возможность заблокировать вставляющий «Producer» поток до тех пор, пока другой поток «Consumer» не вытащит элемент из очереди. Блокировка может быть как с таймаутом, так и вовсе может быть заменена проверкой на наличие ожидающих «Consumer»ов (для синхронных, так и асинхронных сообщений)

Класс 'Stack' - работает по принципу LIFO (последним пришел - первым ушел).
                Элементы кладутся в стек «друг на друга», причем взять можно только верхний-элемент, который был положен в стек последним:
+ push(Object item) - помещает элемент на вершину стека;
+ pop() - извлекает из стека верхний элемент;
+ peek() - возвращает верхний элемент, не извлекая его из стека;
+ empty() - проверяет, не пуст ли стек;
+ search(Object item) - ищет глубину объекта в стеке. Верхний элемент имеет позицию 1, находящийся под ним - 2 и т.д. Если объекта в стеке нет, возвращает '-1';
   ------------------------------------------
> интерфейс-Queue (унаследован от интерфейса Collection - элементы могут добавляться в очередь только с одного конца а извлекаться с другого):
>> 'PriorityQueue' ........... особенностью данной очереди является возможность управления порядком элементов (элементы сортируются, но поведение может быть переопределено Comparator,comparable)

>  интерфейс-BlockingQueue (содержит ряд синхронизируемого Queue):
>> 'LinkedBlockingQueue' ..... ограниченная очередь блокирования FIFO Linked (реализованная на «two lock queue» - показывает более высокую производительность но и расход памяти у него выше)
>> 'ArrayBlockingQueue' ...... ограниченная очередь блокирования FIFO Array
>> 'PriorityBlockingQueue' ... неограниченная приоритетная очередь блокирования PriorityQueue
>> 'DelayQueue' .............. основанная на времени очередь планирования
>> 'SynchronousQueue' ........ простой механизм рандеву интерфейс-BlockingQueue
   ------------------------------------------



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(Сложный sql запрос из нескольких таблиц для сводной таблицы) http://ru.stackoverflow.com/questions/392359/Сложный-sql-запрос-из-нескольких-таблиц-для-сводной-таблицы
http://citforum.ck.ua/database/dblearn/dblearn05.shtml
(Вложенные таблицы (Nested Tables)) http://apps-oracle.ru/nested_tables/
http://java-course.ru/old/students/students.php?name=part3
http://svn.shamangrad.net/codebook/draft/multi-table-sql-queries.html
http://www.pgtk.edu.ru/lections/doku.php?id=rabd:sql_join



(Собеседование вопросы) http://www.programru.com/blog/MkjNwADMwIT5.html

(Логирование Apache JMeter в БД Oracle в режиме on-line) http://savepearlharbor.com/?p=200164


(Потоки в Java (java threads)) http://www.quizful.net/post/java-threads
Отличие этих двух методов заключается в том, что реализация Runnable является более гибкой для создания класса.
Большинство классов, которые должны выполняться как потоки, реализуют Runnable, поскольку они, вероятно, могут расширить свою функциональность за счёт другого класса.

