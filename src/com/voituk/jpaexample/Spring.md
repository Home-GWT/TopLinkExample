
https://habrahabr.ru/post/220233/
http://www.dataart.ua/blog/2014/05/spring-raskopali-do-yadra/
http://ru.stackoverflow.com/questions/319438/spring-beans-scope-singleton-vs-prototype
http://deadlock.org.ua/kit/habr/post/53111 >> http://www.dataart.ru/blog/2016/05/dagger-2-lechim-zavisimosti-po-metodike-google/

http://www.slideshare.net/cansrht/introduction-to-spring-framework-52669031 >> http://www.slideshare.net/springbyexample/spring-by-example-one-day-workshop >> http://www.slideshare.net/custisppt/dependency-injection-java

http://www.sql.ru/forum/1002871/session-scope-dlya-controller
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-10/ >> http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-9/ >> http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-begginers-part-8/ >> http://it.vaclav.kiev.ua/2011/10/09/spring-3-mvc-simple-example/
http://stackoverflow.com/questions/16058365/what-is-difference-between-singleton-and-prototype-bean >> http://stackoverflow.com/questions/17599216/spring-bean-scopes
https://blog.jyore.com/2015/01/spring-camel-route-bean-scoping/

http://javatalks.ru/topics/question/48691?page=1#246683
http://ru.stackoverflow.com/questions/480986/spring-qualifier-vs-scope-prototype
http://javatalks.ru/topics/43130

http://www.logicbig.com/tutorials/spring-framework/spring-core/injecting-singleton-with-prototype-bean/
http://javatalks.ru/topics/44435
http://albazh.blogspot.com/2015/09/3-spring-beans.html
https://habrahabr.ru/post/225397/
*** http://javastudy.ru/interview/jee-spring-questions-answers/
*** http://jsehelper.blogspot.com/2016/02/spring-framework-1.html >> http://jsehelper.blogspot.com/2016/03/spring-framework-2.html >> http://jsehelper.blogspot.com/2016/03/spring-framework-3.html
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-to-begginers-part-6/
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-begginers-part-7/
http://it.vaclav.kiev.ua/2011/10/09/spring-3-mvc-simple-example/
http://proselyte.net/tutorials/spring-tutorial-full-version/bean-lifecycle/
http://javabegin.ru/spring/

http://studopedia.su/6_13241_oblast-vidimosti-bina.html
http://javatalks.ru/topics/13391?page=1#62675
http://ru.stackoverflow.com/questions/500359/Как-работает-web-приложение-java
http://knowlix.github.io/blog/2012/07/17/spring-about-proxy/
http://www.spring-source.ru/articles.php?type=manual&theme=articles&docs=article_04
http://becomejavasenior.com/blog/2016/02/12/spring-ioc-container-and-spring-bean/
http://www.quizful.net/post/Spring-Auto-Wiring
http://rsdn.ru/forum/java/4490324.hot
http://spring-projects.ru/guides/lessons/lesson-2/
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes-other
http://spring-projects.ru/guides/lessons/lesson-3/
http://www.javacore.ru/topic/33-aop-spring.htm
http://proselyte.net/tutorials/spring-tutorial-full-version/bean-scope/
http://docs.spring.io/spring/docs/3.0.0.M3/spring-framework-reference/html/ch04s04.html
http://www.ibm.com/developerworks/ru/library/ws-springjava/
* http://shkolageo.ru/mpakard/Обзор+возможностей+Инверсия+управления+Аспектно-ориентированное+программирование+План+презентацииd/main.html
http://www.myshared.ru/slide/649134/
http://easyjava.ru/spring/spring-framework/kak-vmeshatsya-v-chastnuyu-zhizn-spring-bina/
- https://doc.cuba-platform.com/manual-6.0-ru/manual.html
http://ankursinghal86.blogspot.com/2014/07/injecting-prototypesession-bean-into.html
http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html
http://stackoverflow.com/questions/25000406/how-many-instances-created-for-singleton-bean-referring-to-a-session-bean-protot
*** http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
* http://www.finecosoft.ru/SpringDI
* http://2014.javapoint.ru/presentations/Borisov_spring.pdf
http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera

http://www.sql.ru/forum/1181606-2/spring-inzhektit-biny-s-raznym-skoupom-drug-v-druga
http://javabegin.ru/spring/ >> https://www.youtube.com/watch?v=l7gBzoiX6Eo
http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-1.html
http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-2.html
http://www.seostella.com/ru/article/2012/04/27/spring-3-i-controller-chast-3-cookievalue-i-requestheader.html

(ссылки на подготовку по Java) https://mail.yandex.ua/?ncrnd=596&uid=40270829&login=sashakmets#message/158188936911391773/r=Java%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0\&pos=8&reqid=c85a274cc3e939a2d2c478af07b4b2a1&filter=folder:,attaches:no,dates=-
https://github.com/JobTest/MSL/tree/develop3/src/main/java/example/testtask/java8/meeting2 >> https://github.com/JobTest/MSL/blob/develop3/src/main/java/example/testtask/java8/meeting2/links.txt
http://www.concretepage.com/spring/spring-bean-scope-example-using-scope-annotation-and-xml-for-singleton-prototype-request-session-global-session-and-application-scope-with-scoped-proxy#download

http://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm
http://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch02s02.html


MyCommand command = context.getBean(MyCommand .class);

чтобы можно было связывать бин обладающий меньшей областью видимости (например, session) с бином, у которого область видимости больше (например, singleton) необходимо вставлять не сами бины, а их прокси объекты - для создания такого прокси объекта необходимо добавить дочерний XML элемент <aop:scoped-proxy/>
<bean id="userData" class="ru.javacore.UserData" scope="session">
     <aop:scoped-proxy/>
</bean>
<bean id="dataService" class="ru.javacore.DataService">
     <property name="userData" ref="userData"/>
</bean>
Отметим, что применение элемента <aop:scoped-proxy/> при объявлении бинов область видимости, которых singleton или prototype будет генерировать исключение BeanCreationException. Это было актуально для версии Spring 3.0
<bean id="command" class="fiona.apple.AsyncCommand" scope="prototype">
</bean>
<bean id="commandManager" class="fiona.apple.CommandManager">
  <lookup-method name="createCommand" bean="command"/>
</bean>

Самое интересное начинается, когда бин (Bean) со скоупом 'prototype' вставляют в singleton-бин. Тогда появляется понятие Прокси.
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
public class MyUserData {
    //...
}

@Bean(scope = DefaultScopes.SESSION)
@ScopedProxy
public UserPreferences userPreferences() {
   return new UserPreferences();
}

При использовании Constructor Injection, может возникнуть еще одна проблема, известная как Кольцевая Зависимость (Circular dependencies). 
Представьте себе ситуацию, когда конструктор класса А требует в качестве параметра экземпляр класса B, а тот в свою очередь требует в констуркторе наличие класса A!? В этом случае, Spring Framework, не сможет „поднять“ экземпляры упомянутых компонент (beans), и выбросит исключительную ситуацию: BeanCurrentlyInCreationException. 
Выходом из подобной ситуации будет переход к Setter Injection. В этом случае при создании объектов, поля будут проинициализиорованы null и только в следующем проходе Spring выполнит Setter Injection.

'Бин' - постоянно переконфигурируют, поэтому его удобно декларировать в месте-XML...
BeanFactoryPostProcessor - работает раньше
BeanDefinishion (создает из них бины...)
BeanPostProcessor - работает позже

Для управления созданием и уничтожением бина у нас есть праметры init-method и destroy-method.

Есть два разных описаных объекта...если нужно подключить какую-то логику на момент объявления - это делается вне-программного кода...
Dependancy Injection (DI)
Setter Injection (SI)
Constructor Injection (CI)

Существует четыре вида связывания в спринг:
1. autowire byName,
2. autowire byType,
3. autowire by constructor,
4. autowiring by @Autowired and @Qualifier annotations
++++++++++++++++++++
(автоматическая привязка бинов) Spring поддерживает 5 режимов автопривязки:
no – по умолчанию, нет авто привязки, ее нужно устанавливать вручную с использованием атрибута ref.
byName – Авто привязка по имени, если имя указанное в свойствах бина в атрибуте autowire="byName" такое же как имя бина, то привязка производится автоматически.
byType – Авто привязка по типу данных, если тип данных бина совпадает с указанным типом данных в авто привязке, то привязака производится автоматически.
constructor – привязка по типу аргумента конструктора. 
autodetect – если контсруктор по умолчанию найден, используется автопривязка.


> singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для бинов без сохранения состояния(stateless)
> prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
> request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
> session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы используете web-aware ApplicationContext
> global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании portlet контекста). Действует, только если вы используете web-aware ApplicationContext
> application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете web-aware ApplicationContext

@Service - сервисный слой, бизнес логика и т.п.
@Repository - слой работы с базами данных
@Controller - слой работы с представлением
@Component - бин общего вида

@Autowire - Автоматическое связывание зависимостей

@Autowired
@Qualifier("mariaIvanova")  -  указать имя компонента

@Resource(name="ivanIvanov")  -  интерпретирует значение этого параметра как имя управляемого компонента для связывания (аналогично @Autowired и @Autowired @Qualifier("ivanIvanov"))

@Inject  -  использование аналогично использованию аннотации @Autowired

Методов жизненного цикла управляемого компонента:
@PostConstruct
@PreDestroy


> @Component - является базовой аннотацией для объявления класса управляемым компонентом. При загрузке механизм поиска Spring Framework проверяет наличие у класса этой аннотации и сохраняет в контексте приложения
> @Service - данная аннотация является специализацией @Component, которая в настоящее время не добавляет новой функциональности и используется для того, чтобы различать управляемые компоненты, определенные на уровне бизнес сервисов (busness layer) для демонстрации смысла данного компонента.
> @Repository - данная аннотация является специализацией @Component, которая используется для регистрации в контексте приложения управляемых компонент типа Data Access Object. Аннотация также обозначает, что все непроверяемые исключения (unchecked exception), которые генерируются внутри этого класса, должны быть транслированы в (также непроверяемое) исключение DataAccessException.
> @Controller - объявляет класс контроллером Spring MVC controller, используемым в веб приложениях. Аннотация также является специализацией @Component.

Многие руководства рекомендуют использовать бины с scope-singleton для 'stateless' бинов, а бины со scope-prototype для 'stateful' бинов.
Singleton bean - может быть зависимостью для бина с любым scope.
Сам он (singleton bean) может зависеть от бина с singleton-scope и prototype-scope (причём для каждого singleton бина будет создан свой собственный уникальный экземпляр prototype бина).
Кстати, получить в singleton бине новый экземпляр prototype бина так просто не получится, надо вручную обращаться к ApplicationContext и просить создать новый бин.
И request и session и globalSession могут быть зависимостями для любых бинов, но не напрямую.
Мы можем попросить spring создать специальный прокси, который с одной стороны будет иметь (внутри себя) scope singleton и, таким образом, быть совместимым со всеми scopes, с другой стороны этот прокси будет определять требуемый в данном контексте исполнения бин с меньшим временем жизни.



======================================================================================================================================================
                                        (EasyJava ** Spring bean scopes) http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
                           (ФИНЭКОСОФТ ** Dependency Injection и Spring) http://www.finecosoft.ru/SpringDI
(АйТи-шные заметки ** Spring Framework – первые шаги (Конспект девятый)) http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-9/
      (JavaCore.ru ** Что означает элемент <aop:scoped-proxy/> в Spring) http://www.javacore.ru/topic/33-aop-spring.htm
                     (JavaCore.ru ** Использование "autoproxy" в Spring) http://www.javacore.ru/topic/60-aop-spring.htm

Внедрение бинов и иерархия scope:
> Бин (это класс) может быть зависимый от другого бина - то есть, это значит что внутри этого класса будет объявлено поле/переменная типа другого-объекта (зависимого класса);
> Бин может быть зависящий для другого бина - то есть, это значит что внутри другого класса будет объявлено поле/переменная объекта типа этого-объекта (зависящего класса);

Любой бин определяется как обычный (независимый) класс внутри пакета ("public class Xxx{...}") с приватными полями и методами (гетерами и сетерами).
И такой класс также будет доступен в любом другом классе внутри этого пакета... Теперь можно объявить поле этого типа-класса внутри любого другого класса.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Важно понять что вначале java-объект каждого класса внутри пакета создается как обычный экземпляр класса И такой java-объект храниться внутри Spring-контейнера...
И уже после того как java-объект создан (внутри Spring-контейнера) в игру вступает 'scope' (расширяет границы жизненного цыкла java-объекта) в месте объявления поля этого типа внутри класса:
- если java-объект из области-Java будет удален сборщиком муссора по правилам-Java стандартного жизненного цыкла ТО границы жизненного цыкла для java-объекта который находиться под защитой 'scope' будут расширены (и такой java-объект будет продолжать существовать дольше...в области Spring-контейнера)
- то есть, относительно Spring-фреймворка java-объекты существуют в области Spring-контейнера независимо от условий их использования...
  Spring-фреймворк никогда НЕиспользует оператор 'new' для создания java-объектов (внутри области Java)...все java-объекты создаются независимо друг-от-друга.
  Класс имеет только объявление используемых полей-типов НО НЕсоздает их оператор 'new' (при том что жизненный цыкл java-объектов контролируется отдельно и по разному: как в области Java, так в области Spring-контейнера)
  (оператор 'new' говорит о том что java-объект будет создан в области Java и существовать по правилам-Java)
- Поэтому при удалении одного java-объекта, другие его java-объекты внутренние поля-типов класса этого удаляемого java-объекта НЕбудут удалены. Потому-что они НЕбыли созданы оператором 'new' (вне области Java) И ссылка на java-объекты ведет на Spring-контейнер (но НЕ на место обявления полей-типа)
  И только Spring-фреймворк, через scope, будет контролировать время жизни java-объекта (по правилам Spring-фреймворка...)

Что делает Spring:
1. Загружает все Java-классы из указаной области-пакета в свой контекст (бин-дефинишинс);
2. Смотрит-читает конфигурационные настройки для каждого задекларированные для каждого класса;
3. Создает Java-объекты: сперва пустые, потом уже согласно конфигурационным настройкам И загружает их в свой IO-Контейнер;
4. По востребованию берет из своего IO-Контейнера Java-объект и уже отдает его клиенту...;

В этом случае сам Spring наблюдает и управляет за жизнью (выданного им) Java-объекта И уничтожает его в нужный момент...
Именно 'скоупы' определяют область видимости (жизни) для Java-объектов И таким способом Spring автоматически уничтожает Java-объект.

По сути можно класс с любым скоупом определять в любом классе с другим скоупом...но при этом:
- 'Singleton' бин всегда существует только в единственном экземпляре(является потоко-НЕбезопасным) И всегда будет существовать...
  Если 'Singleton' бин является зависимым для для другого объекта (то есть внутри другого объекта будет объявлено поле типа-класса 'Singleton') >> тогда при удалении этого другого-объекта ничего страшного НЕпроизойдет (объект удачно удалиться и программа успешно будет продолжать работать...)
- 'Prototype' бин (или любой другой) существуют во многих экземплярах НО будет существовать только лиш кратковременно...
  Если 'Prototype' бин является зависимым для для Singleton-объекта (то есть внутри Singleton-объекта будет объявлено поле типа-класса 'Prototype') >> тогда при удалении этого другого-объекта удалиться и ссылка на него И это приведет к ошибке 'NullPointerException'

В 'Singleton' бине можно успешно создавать разовые объекты для генерации например случайных чисел И такие разовые объекты успешно будут работать для всех других объектов...
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
> Технология EJB для создания Java-объектов использует Java-инструменты:
  - java-файлы (исходники, НО не факт что библиотечные java-классы могут храниться в виде объектного кода) которые раскиданы в разных библиотеках собираются (компилируются в объектный код) в один-общий java-объект.
    Тами способом на вход получаем много java-файлов а отдаем уже только один java-объект.
  - внутренние поля класса такого java-объекта тоже создаются на момент когда собирается этот-общий java-объект (НО не раньше и не позже...)
    Если досуп к таким объектам внутренних полей класса будет закрыт тогда будет невозможно получить реальное состояние этого объекта внутреннего поля

> Технология Spring для создания Java-объектов использует свой контейнер:
  - сначала из разных java-файлов создаются java-объекты. И таких java-объектов может быть много. А потом Spring собирает все эти java-объекты во внутрь своего контейнера...
    Идеология шприца: когда Spring собирает все java-объекты во внутрь контейнера И потом, по требованию, достает и отдаем их (впрыскивает - делает иньекцию...)
    Тами способом на вход получаем один java-объект (после Spring-контейнера) а отдаем уже много ссылок в разных местах кода-классов на этот экземпляр класса (java-объекта).
    то есть, механизм сборки java-объектов через использования Spring-контейнера является обратным механизму сборки java-объектов через Java-инструменты - инверсия (Inversion of Control)
    а впрыскивание, когда Spring отдаем уже много ссылок на этот экземпляр класса - иньекция java-объекта (Dependency Injection)
  - И такой способ уже позволяет получать доступ к реальному состоянию этого объекта скрытого внутри поля класса (из Spring-контейнера чтобы например: протестировать поведения внутреннего модуля java-объекта в реальных условиях...)

> Жизненный цыкл java-объектов которые существуют о области Java контролируется сборщиком муссора (Java-инструмент: Garbage Collection)
  - если ссылка на java-объект пропадает - тогда такой java-объект автоматически будет удален из Heap-области
> Скоуп (scope) работает по идеологии пузыря - он расширает (границы) жизненный цыкл java-объектов внутри области Java
  - то есть, границы стандартного жизненного цыкла java-объекта который находиться под защитой scope-а уже будут разширены согласно правилам этого scope-а...
  - таким образом жизненный цыкл бина в Spring-фреймворке можно разделить на две области:
    -- 'IoC' - идеология шприца (куда собираются все java-объекты) - инверсия по отношению к тому как работает Java-инструмент
    -- 'DI' - идеология пузыря (когда этот java-объект впрыскивается в месте объявления поля класса) - иньекция (после того как java-объекты будут отданы кастомеру с этого момента в игру уже вступают scope воздействия на этот java-объект)

> Технология EJB тоже имеет свой контейнер (EJB-контейнер) И тоже управляет жизненным цыклом java-объектов, которые существуют внутри области EJB-контейнера.
  - Но (в отличии от Spring) EJB НЕумеет создавать java-объекты... Поэтому все java-объекты создаются оператором 'new' внутри области EJB-контейнера И жизненный цыкл такого java-объекта управляется уже правилом-EJB (расширяет границы жизненного цыкла области Java).
  - EJB-контейнер (в отличии от Spring-контейнера) создает java-объекты только по требованию при явном вызове оператора 'new' И в ходе работы java-объекты создаются в разный период времени (в отличии от Spring-контейнера который все java-объекты создает сразу...)

> Иньекция (@Inject) - (это замена для оператора 'new') выполняется поиск подходящей версии класса-реализации для поля-типа с указанным интерфейсом:
  - в месте объявления поля-типа '@Inject' находит подходящую версию класса-реализации и создает-подставляет экземпляр класса для этого поля-типа...то есть, это позволяет уже незаботиться об поиске в каком пакете лежит требуемый класс-реализации;
> Иньекция зависимостей (Dependency Inject) - это поиск и создание подходящей версии класса-реализации по интерфейсу для поля-типа НО уже с привязкой java-объекта к 'scope' области контейнера (что расширает границы жизненного цыкла области Java):
  - то есть, отличие 'Dependency Inject' от 'Inject' в том что после создания подходящей версии класса-реализации по интерфейсу ЕЩЕ и расширает границы жизненного цыкла области Java (привязывает java-объект к 'scope' области контейнера...) для этого java-объекта.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
>'Переменная' - используется для обмена данными между разными функциями...

> 'Бин' - это тоже переменная которая но имеет сложную структуру...
  'Бин' - используется для обмена данными между разными модулями, причем эти модули могут работать независимо на разных JVM (виртуальных машинах).
    Дело в том что каждая JVM может обрабатывать только те приложения которые работают под управлением именно этой JVM (а ко всем другим приложениям JVM доступа НЕимеет...)
  То есть, если приложение вдруг завершит свою работу внутри JVM, тогда уже после этого (при повторном запуске приложения) приложение НЕсможет востановить свое состояние...то есть опепративная память может толко времменно хранить   состояние объектов (в случае если произойдет сбой - состояние восстановить НЕвозможно)
  'Бин' - так устроен что сохраняет состояние объекта на диск (диск - позволяет постоянно хранить данные И даже после сбоя) - 'сериализация'. Таким образом данные которые храняться в виде файла могут быть прочитаны разными JVM, в любое  время. Поэтому 'бин' позволяет восстанавливать состояние объектов на разных JVM.
  Поэтому 'бины' служат для связи модулей на разных жизненных цыклах веб-приложения (потому-что разные модули используют разные технологии, которые работают в разных JVM...) - так сказать помогают склеивать жизненный цыкл веб-приложения.

> 'Бин' имеет умную структуру:
  - сохраняются / сериализируются только поля (данные о состоянии бина) в файл, а set/get-методы 'бина' никогда несохраняются (и вообще никакие методы 'бинов' несохраняются). Поэтому для возможности восстановления есть специальные требования:
  -- класс-бина должен существовать на всех тех JVM на которых выполняется восстановление;
  -- система JVM на своей сторое создает новый объект этого бина НО данные полей о состоянии бина подкладывает уже из сохранненого файла... - так происходит востановление / десириализация бина.
  - 'бин' же автоматизирует эту процедуру сериализации-десириализации на разных JVM с возможностью подбора подходящего типа класса для объекта.
  - назначение set/get-методов 'бина' по умолчанию используются для передачи-обмена данных между кастомером и JVM (а в последствии - файлом).
    (поэтому бины используются для обмена данными между разными устройствами...)

 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
> Внутри одного приложения разные функции могут обмениваться данными с помощью 'переменных'...

> Обмен данными между разными приложениями внутри одного компютера выполняется с помощью 'слота' (вспомогательное программное дополнение):
  - существует два типа слотов ('клиентский слот' является иннициатором и отправляет команду; 'серверный слот' является приемником он слушает и обрабатывает команду;)
    -- кажый 'слот' привязывается еще и к (номеру) 'порт-а'...
  - между этими слотами можно передавать текстовую команду (и в текстовом виде получать ответ)
  - само-же приложение является псевдо-устройством... (то есть, вместо приложения может даже быть физическое устройство)
Так если-бы представить себе схему обмена данными внутри локального компьютера:
- с одной стороны работают приложения. Некоторые приложения (при необходимости) могут работать со слотами, а другие приложения могут работать без слотов...
- с другой стороны есть (физические) устройства, это контроллеры куда могут быть подключены клавиатура, мышка и прочее для генерации команды
  -- эти устройства генерят команды и через контроллер передают эти команды на 'клиентский слот'
  -- все такие команды (сообщения) сперва попадают в Операционную Система А дальше Операционная Система уже решает куда перенаправлять или отклонять команды...
  -- в итоге команда (текстовое сообщение) приходит по номеру порта на адресуеы слот...

> Все компьютеры между собой соеденены через (глобальную) компьютеную сеть...
  - сущесвует 3-уровня которые позволяют связывать компьютеры между собой внутри компьютерных сетях:
    -- 'физический уровень' (байт-код разбивается/собирается по пакетам чтобы проверять утерю данных для гарантированной передачи большогообъема данных на большие расстояния)
    -- 'сетевой уровень' (хранит сконфигурированную карту адрессов компьютерной сети и имеющихся внутри активные подключения клиентов И контролирует порядок обмена данными между клиентами...)
    -- 'прикладной уровень' (кодирует/декодирует байт-код в текст)
  - все эти 3-уровня размещаются отдельно на каждом компьютере и обвертываются специальным приложением чтобы контролировать этапы передачи данных
    -- в основу работы такого специального приложения заложен на механизм двухсторонней передачи данных: 'запрос-ответ'...
    -- именно такое специальное приложение и является 'HTTP-протоколом'
  - 'HTTP-протокол' в качестве передаваемой команды (данных) использует 'HTTP-объект' (HTTP-объект состоит из хидера запроса И тела запроса...)
  - Веб-браузер является клиентским приложением которое используется для обмена данными между сервером...
    -- Поэтому внутри такого приложения веб-браузера уже есть 'клиентский слот'
    -- по умолчанию 'клиентский слот' привязывается по номеру протокола '80', на котором работает приложение HTTP-протокола
    -- собственно на клиентской стороне внутри приложения HTTP-протокола определяются ошибки соединения типа '4**' (404), другие ошибки определяются на серверной стороне (3**, 5**). Статус '200' говорит о том что запрос был выполнен успешно...

> 'Сервер приложения' тоже является обычным приложением, которое работает на стороне сервера.
  - 'сервер приложения' имеет серверный слот для обмена данными (текстовыми командами) по HTTP-протоколу А также прослушивает GET/POST/PUT/DELETE... И укомплектован собственными программными компонентами
  - 'сервлет' является программным компонентом сервера приложения (что-то типа основной функции 'main' входа в программу), реализует прослушивание GET/POST/PUT/DELETE методов...
    -- в случае если у 'сервера приложения' нехватает собственных программных компонентов для выполнения каких-то задач, тогда используются уже стороние компоненты...
  - веб-приложения является серверным компонентом.
    -- веб-приложение полностью пронизано клиентскими запросами (это значит что каждый раз только в период одного-каждого клиентского запроса создаются новые объекты, выполняются какие-то действия и потом все это удаляется...)
    -- чтобы каждый раз НЕтратить время на создание новых объектов И использовать уже существующие объекты: для этой цели используют 'бин' (который хранит свое состояние между клиентскими запросами, расширяет область жизненного цыкла)
  - 'бин' хранит состояние объекта между клиентскими запросами и расширяет область жизненного цыкла java-объектов...
  - 'скоуп' тоже расширяет область жизненного цыкла НО используется для тела функции (не для java-объектов)...
 ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
> При разработке API нужно брать во внимание:
  - API это прежде всего написание клиентских функций-интерфейсов (с применением REST, SOAP)...
  - при попадании на URL-адресс домена веб-приложения важно чтобы были исключены ошибки типа '404', '300' (дело в том что интерфейс API должен возвращать понятный и отзывчивый ответ: чтобы говоорил об конкретной ошибке НО со статусом '200'...)

Веб-сервисы работают на серверной стороне и служат обычно для обработки клиентских полученных данных.
Утилиты (в отличие от веб-сервиса) работают на клиентской сторое И выполняют клиентский запрос (средствами класса 'URL') чтобы получить ответ из веб-сервиса...

> 'Сессия':
  - условно так считается что идентификатор сессии может получить зарегистрированный клиент
    (то есть, сессия создается 'getSession()' уже после того когда клиент зарегистрируется и пройдет авторизацию...)
  - если клиент прошел авторизацию и получил идентификатор сессии то считается что такой клиент получает в какой-то степени доверие...и уже такому клиенту разрешено иметь больше прав (чем анонимному клиенту)
    -- итак, имея идентификатор сессии клиент может обладать большими правами И если выполняются клиентские запросы к API тогда для клиента расширяется функциональная область на веб-сайте...
> 'LDAP':
  - можно держать отдельный сервер приложения только для регистрации и авторизации клиентов (единая система авторизации...), при первом обращении к такому серверу приложения клиент получит идентификатор сессии
    тогда каждый раз когда клиент будет заходить например на приложение веб-сервиса (API) всегда будет выполняться проверка его прав доступа по идентификатору сессии...

> 'Web-сервер':
  - считается что именно клиентская часть является самой низко-нагруженной, потому-что:
    -- веб-сервер только отдает клиенту запрашиваемый HTML-документ (никакой обработки в области веб-сервера НЕпроисходит...)
    -- каждый раз, когда клиент (веб-браузер) получил из веб-сервера HTML-документ, веб-браузер кеширует ее И полученная однажды веб-страничка повторно уже НЕбудет загружаться с веб-сервера...
> 'Сервер приложений':
  - считается что именно серверная часть является самой высоко-нагруженной, потому-что:
    -- поскольку загрузка веб-странички является Асинхронным процессом, то каждый раз когда клиент что-то вызывает на веб-страничке обычно выполняется загрузка из сервера приложения...
    -- на сервере приложений происходит вся обработка клиентских запросов (этот процесс может занимать много времени и много ресурсов)
    -- (теперь уже перезагрузка всей веб-странички происходит в малых случаях)
  - именно по этой причине всегда лучше отдельно устанавливать веб-сервер от сервера приложений (поскольку они по разному загружены...)
  - в некоторых случаях делают даже балансировку между серверами приложений на случай когда если нагрузки на сервер будут очень высокими И тогда время отзыва будет низким...

> 'Сервлет' служит для расширения функциональных возможностей сервера приложений:
  - обычно сервлет используют в качестве контроллера чтобы загружать HTML-документ (на низком уровне...)
  - при разработке веб-сервисов обычно используют библиотеку 'JAX' (JAX-RS, JAX-WS, JAX-RPC)
    -- это позволяет делать более широкие настройки, например: прием клиентских запросов на один URL-адресс в разных форматах >> @Produces({ MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON })
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

------------------------------------------------------------------------------------------------------------------------------------------------------
@Inject - (это EJB-ая аннотация) каждый интерфейс может иметь несколько реализаций, причем эти реализации могут являться наследками. Такие реализации обычно храняться в виде бинарного Java-класса (jar-файла).
          Так вот, иньекция ищет в модулях проекта такой jar-файл который более-ближе подходящий для реализации интерфейса и иннициализирует-создает новый объект в месте где было объявлено это поле-переменная...
@Inject(name="ivanIvanov") - в Spring-фреймворке существует собственная, уже переопределенная, аннотация иньекции котороя аналогично использованию аннотации @Autowired...
@Autowired - (это Spring-ая аннотация) Spring-фреймворк имеет IO-контейнер в котором лежат уже подготовленные Java-объекты (которые были созданы согласно указаным в конфигурации требованиям).
          Так вот, автовайред по востребованию достает из своего IO-контейнера такой уже подготовленный конкретный Java-объект и отдает его копию клиенту в месте где было объявлено это поле-переменная...
          (а еще, в зависимости от указанного скоупа [это область видимости для объектов], автовайред управляет жизненным циклом объектов И самостоятельно следит за уничтожением выданных объектов согласно указанному в конфигурации скоупу...)
@Resource - (это Spring-ая аннотация) обычно эта аннотация используется аналогично [@Resource(name="mariaIvanova")] как если-бы вызывались в паре аннотации:
            @Autowired
            @Qualifier("mariaIvanova")
______________________________________________________________________________________________________________________________________________________
======================================================================================================================================================
Дело в том что веб-приложение имеет жизненный цыкл, который зависит от разных применяемых технологий внутри такого распределенного приложения, это:
- передача / транспортировака данных из клиентской рабочей станции на сторону удаленного сервера по HTTP/HTTPS/FTP протоколу
- управление жизненным цыклом Java-объектов (создание-удаление, период существования) на стороне сервера приложений согласно клиентским транзакциям
- поддержка постоянной сохранности клиентских данных и возможность восстановления клиентских данных
- JMS-протокол который гарантирует дооставку данных с учетом приоритетов и целостности в случаях нестабильной работы
Работа с отдельной-выбранной такой технологией в веб-приложением, это есть - контекст (Context - на уровне выбранного контекста можно выполнять только специальные операции над данными...)

> Для работы с этими технологиями в EJB (Enterprice Java Beans) есть: 'бины' (EJB-бин) и 'скоупы' (scope)
  Первым делом клиент формирует и отправляет запрос из клиентской рабочей станции на сторону сервера по HTTP-протоколу (механизм работы HTTP-протокола работает по схеме запрос-ответ).
  На стороне сервера стоит сервер приложений который обрабатывает все клиентские запросы... На обработку такого клиентского запроса может тратиться много времени И все это время клиент находиться в ожидании ответа (веб-страница на его веб-браузере заблокирована...)
  Сервер приложения может по случаю ломаться... И для восстановления состояния клиента применяется уже другой сервер EIS (Enterprise Information Server - универсальный доступ к данным используя единый SQL-стандарт).
  А чтобы клиент НЕждал долгое время пока его запрос обрабатывается для этого решения есть DMB-бин (Driven Message Bean) который гарантирует доставку клиентского сообщения по JMS-протоколу НЕдожидаясь пока это сообщение будет обработанно...
  + Итак, существую разные EJB-бины с разными свойствами:
    - Каждый клиентский запрос (Request) всегда являеться независимым, то есть, сервер приложения каждый клиентский запрос рассматривает как новый (даже если это выполняется внутри сессии...).
      В каждом таком независимом клиентском запросе данные храняться только одно-разово (на период времени для отправки / выполнения клиентского запроса И получения ответа...после этого данные пропадают)
      Такое одно-разовое / независимое состояние поддерживает - 'Stateless-бин'
    - В случае когда клиентские запросы зависимы друг от друга (например: клиентская корзина покупок в магазине ИЛИ состояние прав доступа...) для этого требуется в каждом новом запросе передавать состояние предыдущего запроса.
      В этом случае такие зависимы клиентские запросы будут очень громоздкими. Для решения такой проблемы существуют - клиентские сессии (Session - они хранят состояние полей для каждого клиента на стороне сервера...)
      Такие много-разовые зависимые клиентские запросы поддерживает - 'Statefull-бин'
    - Клиентский запрос уже попал на сервер приложения И теперь сервер приложений должен выполнить еще один запрос на EIS-сервер в базу данных чтобы достать там хранимую информацию о клиенте (и начать ее обрабатывать...)
      Поэтому обработку клиентского запроса можно разделить на две области: обработка клиентской информации на стороне EIS-сервера в базе данных; И обработка клиентской информации на сервере прложений;
      Для решения такой проблемы существует - механизм кеширования данных (результаты всех ранее выполненых запросов в базу данных, кторые были выполнены однажды, сохраняются на стороне сервера приложений, чтобы потом иметь возможность мгновенно получить информацию...)
      Работу с запросами к базе данных и с механизмом кеширования подерживает - 'Entity-бин'
    - Теперь еще остается обработка клиентской информации на сервере прложений. При больших объемах информации, может тратиться много времени на ее обработку.
      Иногда бывает что клиенту ненужна информация что обрабатывается в этот момент...когда-то позже клиент может запросить результаты по обработке этого зпрроса.
      Поэтому, в некоторых случаях, для клиента нет смысла ждать полный цыкл обработки данных. Достаточно будет только отправить данные на обработку И НЕожидать выпонения его результата...
      Для решения такой проблемы существует JMS-сервер, который гарантирует доставку клиентского сообщения в модуль-обработчик на сервере приложений.
      Такую схему для обработки данных поддерживает - 'DMB-бин' (Driven Message Bean)
  + Проектирование схемы (порядок построения) EJB-бинов позволяет получить максимальную производительность по скорости работы (отдачи) веб-приложения для клиентского использования...
    В действительнсти-же EJB-бины представляют собой всего-лиш раскиданные-установленные хранилища (временные-постоянние) из которых можно быстро вытянуть информацию на промежутках всего жизненного цикла веб-приложения (чтобы сократить прохождения полного цыкла обработчика данных для получения информации).
    (таким образом на линии жизненного цыкла веб-приложения можно проследить за областями на каких этапах задействованы EJB-бины И насколько эффективно разработчик спроектировал схему для хранения данных...чтобы сократить прохождения полного цыкла обработчика данных для максимально быстрого-эффективного получения информации на промежутках всего жизненного цыкла веб-приложения)
      Скоупы - это области которые как-бы описывают жизненный цыкл веб-приложения уже для обработчиков данных (то есть, скоупы НЕхранят данные, они занимаются только обработкой уже имеющих-полученных данных).
    - Итак, скоупы обварачивают области жизненного цыкла веб-приложения для выполнения обработки данных.
      Внутри каждого скоупа есть какой-то обработчик данных...
    - А уже внутри каждого обработчика данных есть EJB-бин для получения данных клиентского запроса...
    Правильно спроектированные скоупы для обработчиков данных позволяют добиться эффективности: максимально-быстрое время затрачиваемое на обработку данных И по минимуму использование ресурсов памяти...
    Если скоупы спроектированны НЕправильно:
      -- через мерно частый вызов объектов приведет к затрате большего времени на создание новых объектов - это понизит скорость по производительность по скорости;
      -- через мерно редкий вызов объектов приведет к затиранию данных в клиентских запросах - это приведет к потере клиентских данных;

Таким образом разработчик может спроектировать схему EJB-бинов:
- Использовать 'Statefull-бин' чтобы зависимые клиентские запросы содержали минимальный размер И НЕгрузили трафик HTTP-протокола...
- Использовать 'Entity-бин' чтобы кешировать клиентские данные ЕСЛИ клиенту НЕнужно получать обновленные данные И сэконоить время на обработке данных...
- Использовать 'DMB-бин' чтобы НЕждать сейчас выполнения полного цыкла обработки данных А запросить информацию позже, для востребования...
И спроектировать схему скоупов:
- чтобы добиться эффективности: для максимально-быстрого времени затрачиваемое на обработку данных И по минимуму использование ресурсов памяти...

> Servlet - всего-лиш выступает в роли контроллера (слушивает клиентские запросы через HTTP-протокол, реализуя методы GET/POST/PUT/DELETE)...и обрабатывает или вызывает обработчик данных
> JSP - выступает в роли представления (помогает формировать клиентсткую веб-страницу)
> База данных - выступает в роли модели (это сущность объекта...)

> Технологии EJB (Enterprice Java Beans) также управляют жизненным цыклом существования Java-объектов - контролируют время создания / удаления Java-объектов И период жизни Java-объектов:
  - Но для этого разработчику нужно самостоятельно проектировать такую схему
  - Создание всех Java-объектов выполняется явно, оператором 'new'
  - И только уже после того как такая схема будет спроектирована, технология EJB сможет возвращать Java-объекты по требованию клиента
> Spring-фреймворк берет это-же проектирование на себя и делает это вместо разработчика:
  - Spring-бин отличаются от EJB-бина тем что жизненный цыкл Spring-бина контролируется Spring-фреймворком.
    И такой Spring-бин является уже компонентом (Component).
    В Spring-е также существуют разные компоненты: 'Controller', 'Service', 'Repository'. Эти компоненты в Spring-фреймворке играют ту-же роль что и EJB-бины в технологии EJB...И аналогично также Spring делает проектирование.
  - Spring-фреймворк имеет IO-контейнер, куда подготавливает и загружает все Java-объекты веб-приложения
  - Разработчик НЕможет сам создавать Java-объекты в Spring-е через оператор 'new', потому-что посзданием объектов занимаеться контейнер Spring-а...
  - Разработчик может только управлять / устанавливать конфигурацию для компонентов (Spring-бинов). Причем разработчик это может в горячем режиме, без перекомпилирования кода (потому-что за все это отвечает Spring)
  - Итак, Spring сам создает и проектирует Java-объекты веб-приложения.
    Дальше, в момент по требованию клиента, Spring достает из своего IO-контейрера копию уже готового объекта и отдает его клиенту (кастомеру...) в месте объявления поля этого типа.
    Именно такая обратная процедура создания Java-объектов и является - IoC / DI (иньекция зависимостей...)
  - С помощью скоупов Spring может управлять жизненным цыклом Java-объектов.
    А также позволяет эфективно проектировать приложения чтобы количество создания новых Java-объектов имело максимально-быстрое время затрачиваемое на обработку данных И по минимуму использование ресурсов памяти (аналогично технологии EJB...)

> Жизненный цыкл Spring-а:
  1. Загружает Java-файлы из указаной области-пакета в свой контекст (бин-дефинишинс);
  2. Читает файл-конфигурационных настроек для каждого задекларированные класса;
  3. Создает Java-объекты: сперва пустые, потом уже согласно конфигурационным настройкам (для формирования двухфазного конструктора...) И загружает их в свой IO-Контейнер;
  4. По востребованию берет из своего IO-Контейнера Java-объект и уже отдает его копию кастомеру...;
  5. Именно 'скоупы' определяют область видимости (жизни) для Java-объектов И таким Spring наблюдает и управляет за жизнью (выданного им) Java-объекта И уничтожает его в нужный момент...


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(Thoughts...!!!!!! ** Injecting a prototype/Session bean into a singleton bean) http://ankursinghal86.blogspot.com/2014/07/injecting-prototypesession-bean-into.html
(Re: Объясните пожалуйста подробно, как это работает) http://rsdn.ru/forum/java/4490324.hot
(Блог о... ** 3. Spring. Beans) http://albazh.blogspot.com/2015/09/3-spring-beans.html
(javatalks.ru ** Сессия в Spring MVC ввела в заблуждение) http://javatalks.ru/topics/44435

(meeting2/links.txt) https://github.com/JobTest/MSL/blob/develop3/src/main/java/example/testtask/java8/meeting2/links.txt
(jpaexample/JPAExample.java) https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
(ссылки на подготовку по Java) https://mail.yandex.ua/?ncrnd=596&uid=40270829&login=sashakmets#message/158188936911391773/r=Java%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0\&pos=8&reqid=c85a274cc3e939a2d2c478af07b4b2a1&filter=folder:,attaches:no,dates=-
(meeting3/README.md) https://github.com/JobTest/MSL/tree/develop4.2/src/main/java/example/testtask/java8/meeting3
(jpaexample/EJB.md) https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/EJB.md

(Евгений Борисов ** Spring-потрошитель, часть 2) http://www.sql.ru/forum/1181606-2/spring-inzhektit-biny-s-raznym-skoupom-drug-v-druga
(тимур батыршинов ** Что такое Spring Framework) http://javabegin.ru/spring/
(тимур батыршинов ** 45 - Spring. Создание проекта Spring MVC) https://www.youtube.com/watch?v=l7gBzoiX6Eo
(Spring 3 и @Controller. Часть 1) http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-1.html
(Spring 3 и @Controller. Часть 2) http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-2.html
(Spring 3 и @Controller. Часть 3) http://www.seostella.com/ru/article/2012/04/27/spring-3-i-controller-chast-3-cookievalue-i-requestheader.html
http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera
http://2014.javapoint.ru/presentations/Borisov_spring.pdf
http://stackoverflow.com/questions/25000406/how-many-instances-created-for-singleton-bean-referring-to-a-session-bean-protot

(Есть ли будущее у MVC-шаблона?) https://dev.by/lenta/main/est-li-buduschee-u-mvc-shablona
(написал web-приложение «Каталог автомобилей») https://sohabr.net/habr/post/240033/
https://javatalks.ru/topics/44268
http://www.javatpoint.com/spring-3-mvc-tutorial














