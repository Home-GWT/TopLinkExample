
https://habrahabr.ru/post/220233/
http://www.dataart.ua/blog/2014/05/spring-raskopali-do-yadra/
http://ru.stackoverflow.com/questions/319438/spring-beans-scope-singleton-vs-prototype
http://deadlock.org.ua/kit/habr/post/53111 >> http://www.dataart.ru/blog/2016/05/dagger-2-lechim-zavisimosti-po-metodike-google/

http://www.slideshare.net/cansrht/introduction-to-spring-framework-52669031 >> http://www.slideshare.net/springbyexample/spring-by-example-one-day-workshop >> http://www.slideshare.net/custisppt/dependency-injection-java

http://www.sql.ru/forum/1002871/session-scope-dlya-controller
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-10/ >> http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-9/ >> http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-begginers-part-8/ >> http://it.vaclav.kiev.ua/2011/10/09/spring-3-mvc-simple-example/
http://stackoverflow.com/questions/16058365/what-is-difference-between-singleton-and-prototype-bean >> http://stackoverflow.com/questions/17599216/spring-bean-scopes
https://blog.jyore.com/2015/01/spring-camel-route-bean-scoping/

http://javatalks.ru/topics/question/48691?page=1#246683
http://ru.stackoverflow.com/questions/480986/spring-qualifier-vs-scope-prototype
http://javatalks.ru/topics/43130

http://www.logicbig.com/tutorials/spring-framework/spring-core/injecting-singleton-with-prototype-bean/
http://javatalks.ru/topics/44435
http://albazh.blogspot.com/2015/09/3-spring-beans.html
https://habrahabr.ru/post/225397/
*** http://javastudy.ru/interview/jee-spring-questions-answers/
*** http://jsehelper.blogspot.com/2016/02/spring-framework-1.html >> http://jsehelper.blogspot.com/2016/03/spring-framework-2.html >> http://jsehelper.blogspot.com/2016/03/spring-framework-3.html
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-to-begginers-part-6/
http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-begginers-part-7/
http://it.vaclav.kiev.ua/2011/10/09/spring-3-mvc-simple-example/
http://proselyte.net/tutorials/spring-tutorial-full-version/bean-lifecycle/
http://javabegin.ru/spring/

http://studopedia.su/6_13241_oblast-vidimosti-bina.html
http://javatalks.ru/topics/13391?page=1#62675
http://ru.stackoverflow.com/questions/500359/Как-работает-web-приложение-java
http://knowlix.github.io/blog/2012/07/17/spring-about-proxy/
http://www.spring-source.ru/articles.php?type=manual&theme=articles&docs=article_04
http://becomejavasenior.com/blog/2016/02/12/spring-ioc-container-and-spring-bean/
http://www.quizful.net/post/Spring-Auto-Wiring
http://rsdn.ru/forum/java/4490324.hot
http://spring-projects.ru/guides/lessons/lesson-2/
http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes-other
http://spring-projects.ru/guides/lessons/lesson-3/
http://www.javacore.ru/topic/33-aop-spring.htm
http://proselyte.net/tutorials/spring-tutorial-full-version/bean-scope/
http://docs.spring.io/spring/docs/3.0.0.M3/spring-framework-reference/html/ch04s04.html
http://www.ibm.com/developerworks/ru/library/ws-springjava/
* http://shkolageo.ru/mpakard/Обзор+возможностей+Инверсия+управления+Аспектно-ориентированное+программирование+План+презентацииd/main.html
http://www.myshared.ru/slide/649134/
http://easyjava.ru/spring/spring-framework/kak-vmeshatsya-v-chastnuyu-zhizn-spring-bina/
- https://doc.cuba-platform.com/manual-6.0-ru/manual.html
http://ankursinghal86.blogspot.com/2014/07/injecting-prototypesession-bean-into.html
http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/beans.html
http://stackoverflow.com/questions/25000406/how-many-instances-created-for-singleton-bean-referring-to-a-session-bean-protot
*** http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
* http://www.finecosoft.ru/SpringDI
* http://2014.javapoint.ru/presentations/Borisov_spring.pdf
http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera

http://www.sql.ru/forum/1181606-2/spring-inzhektit-biny-s-raznym-skoupom-drug-v-druga
http://javabegin.ru/spring/ >> https://www.youtube.com/watch?v=l7gBzoiX6Eo
http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-1.html
http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-2.html
http://www.seostella.com/ru/article/2012/04/27/spring-3-i-controller-chast-3-cookievalue-i-requestheader.html

(ссылки на подготовку по Java) https://mail.yandex.ua/?ncrnd=596&uid=40270829&login=sashakmets#message/158188936911391773/r=Java%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0\&pos=8&reqid=c85a274cc3e939a2d2c478af07b4b2a1&filter=folder:,attaches:no,dates=-
https://github.com/JobTest/MSL/tree/develop3/src/main/java/example/testtask/java8/meeting2 >> https://github.com/JobTest/MSL/blob/develop3/src/main/java/example/testtask/java8/meeting2/links.txt
http://www.concretepage.com/spring/spring-bean-scope-example-using-scope-annotation-and-xml-for-singleton-prototype-request-session-global-session-and-application-scope-with-scoped-proxy#download

http://www.tutorialspoint.com/spring/spring_bean_life_cycle.htm
http://docs.spring.io/spring-javaconfig/docs/1.0.0.M4/reference/html/ch02s02.html


MyCommand command = context.getBean(MyCommand .class);

чтобы можно было связывать бин обладающий меньшей областью видимости (например, session) с бином, у которого область видимости больше (например, singleton) необходимо вставлять не сами бины, а их прокси объекты - для создания такого прокси объекта необходимо добавить дочерний XML элемент <aop:scoped-proxy/>
<bean id="userData" class="ru.javacore.UserData" scope="session">
     <aop:scoped-proxy/>
</bean>
<bean id="dataService" class="ru.javacore.DataService">
     <property name="userData" ref="userData"/>
</bean>
Отметим, что применение элемента <aop:scoped-proxy/> при объявлении бинов область видимости, которых singleton или prototype будет генерировать исключение BeanCreationException. Это было актуально для версии Spring 3.0
<bean id="command" class="fiona.apple.AsyncCommand" scope="prototype">
</bean>
<bean id="commandManager" class="fiona.apple.CommandManager">
  <lookup-method name="createCommand" bean="command"/>
</bean>

Самое интересное начинается, когда бин (Bean) со скоупом 'prototype' вставляют в singleton-бин. Тогда появляется понятие Прокси.
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES)
public class MyUserData {
    //...
}

@Bean(scope = DefaultScopes.SESSION)
@ScopedProxy
public UserPreferences userPreferences() {
   return new UserPreferences();
}

При использовании Constructor Injection, может возникнуть еще одна проблема, известная как Кольцевая Зависимость (Circular dependencies). 
Представьте себе ситуацию, когда конструктор класса А требует в качестве параметра экземпляр класса B, а тот в свою очередь требует в констуркторе наличие класса A!? В этом случае, Spring Framework, не сможет „поднять“ экземпляры упомянутых компонент (beans), и выбросит исключительную ситуацию: BeanCurrentlyInCreationException. 
Выходом из подобной ситуации будет переход к Setter Injection. В этом случае при создании объектов, поля будут проинициализиорованы null и только в следующем проходе Spring выполнит Setter Injection.

'Бин' - постоянно переконфигурируют, поэтому его удобно декларировать в месте-XML...
BeanFactoryPostProcessor - работает раньше
BeanDefinishion (создает из них бины...)
BeanPostProcessor - работает позже

Для управления созданием и уничтожением бина у нас есть праметры init-method и destroy-method.

Есть два разных описаных объекта...если нужно подключить какую-то логику на момент объявления - это делается вне-программного кода...
Dependancy Injection (DI)
Setter Injection (SI)
Constructor Injection (CI)

Существует четыре вида связывания в спринг:
1. autowire byName,
2. autowire byType,
3. autowire by constructor,
4. autowiring by @Autowired and @Qualifier annotations
++++++++++++++++++++
(автоматическая привязка бинов) Spring поддерживает 5 режимов автопривязки:
no – по умолчанию, нет авто привязки, ее нужно устанавливать вручную с использованием атрибута ref.
byName – Авто привязка по имени, если имя указанное в свойствах бина в атрибуте autowire="byName" такое же как имя бина, то привязка производится автоматически.
byType – Авто привязка по типу данных, если тип данных бина совпадает с указанным типом данных в авто привязке, то привязака производится автоматически.
constructor – привязка по типу аргумента конструктора. 
autodetect – если контсруктор по умолчанию найден, используется автопривязка.


> singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина. Как правило, используется для бинов без сохранения состояния(stateless)
> prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется для бинов с сохранением состояния(stateful)
> request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
> session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если вы используете web-aware ApplicationContext
> global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании portlet контекста). Действует, только если вы используете web-aware ApplicationContext
> application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только если вы используете web-aware ApplicationContext

@Service - сервисный слой, бизнес логика и т.п.
@Repository - слой работы с базами данных
@Controller - слой работы с представлением
@Component - бин общего вида

@Autowire - Автоматическое связывание зависимостей

@Autowired
@Qualifier("mariaIvanova")  -  указать имя компонента

@Resource(name="ivanIvanov")  -  интерпретирует значение этого параметра как имя управляемого компонента для связывания (аналогично @Autowired и @Autowired @Qualifier("ivanIvanov"))

@Inject  -  использование аналогично использованию аннотации @Autowired

Методов жизненного цикла управляемого компонента:
@PostConstruct
@PreDestroy


> @Component - является базовой аннотацией для объявления класса управляемым компонентом. При загрузке механизм поиска Spring Framework проверяет наличие у класса этой аннотации и сохраняет в контексте приложения
> @Service - данная аннотация является специализацией @Component, которая в настоящее время не добавляет новой функциональности и используется для того, чтобы различать управляемые компоненты, определенные на уровне бизнес сервисов (busness layer) для демонстрации смысла данного компонента.
> @Repository - данная аннотация является специализацией @Component, которая используется для регистрации в контексте приложения управляемых компонент типа Data Access Object. Аннотация также обозначает, что все непроверяемые исключения (unchecked exception), которые генерируются внутри этого класса, должны быть транслированы в (также непроверяемое) исключение DataAccessException.
> @Controller - объявляет класс контроллером Spring MVC controller, используемым в веб приложениях. Аннотация также является специализацией @Component.

Многие руководства рекомендуют использовать бины с scope-singleton для 'stateless' бинов, а бины со scope-prototype для 'stateful' бинов.
Singleton bean - может быть зависимостью для бина с любым scope.
Сам он (singleton bean) может зависеть от бина с singleton-scope и prototype-scope (причём для каждого singleton бина будет создан свой собственный уникальный экземпляр prototype бина).
Кстати, получить в singleton бине новый экземпляр prototype бина так просто не получится, надо вручную обращаться к ApplicationContext и просить создать новый бин.
И request и session и globalSession могут быть зависимостями для любых бинов, но не напрямую.
Мы можем попросить spring создать специальный прокси, который с одной стороны будет иметь (внутри себя) scope singleton и, таким образом, быть совместимым со всеми scopes, с другой стороны этот прокси будет определять требуемый в данном контексте исполнения бин с меньшим временем жизни.



======================================================================================================================================================
                                        (EasyJava ** Spring bean scopes) http://easyjava.ru/spring/spring-framework/spring-bean-scopes/
                           (ФИНЭКОСОФТ ** Dependency Injection и Spring) http://www.finecosoft.ru/SpringDI
(АйТи-шные заметки ** Spring Framework – первые шаги (Конспект девятый)) http://it.vaclav.kiev.ua/2010/12/25/spring-framework-for-beginners-part-9/
      (JavaCore.ru ** Что означает элемент <aop:scoped-proxy/> в Spring) http://www.javacore.ru/topic/33-aop-spring.htm
                     (JavaCore.ru ** Использование "autoproxy" в Spring) http://www.javacore.ru/topic/60-aop-spring.htm

Внедрение бинов и иерархия scope:
> Бин (это класс) может быть зависимый от другого бина - то есть, это значит что внутри этого класса будет объявлено поле/переменная типа другого-объекта (зависимого класса);
> Бин может быть зависящий для другого бина - то есть, это значит что внутри другого класса будет объявлено поле/переменная объекта типа этого-объекта (зависящего класса);

Любой бин определяется как обычный независимый класс (верхнего уровня: "public class Xxx{...}") с приватными полями и методами (гетерами и сетерами).
И такой класс также будет доступен в любом другом классе внутри этого пакета... Теперь можно объявить поле этого типа-класса внутри любого другого класса.

Что делает Spring:
1. Загружает все Java-классы из указаной области-пакета в свой контекст (бин-дефинишинс);
2. Смотрит-читает конфигурационные настройки для каждого задекларированные для каждого класса;
3. Создает Java-объекты: сперва пустые, потом уже согласно конфигурационным настройкам И загружает их в свой IO-Контейнер;
4. По востребованию берет из своего IO-Контейнера Java-объект и уже отдает его клиенту...;

В этом случае сам Spring наблюдает и управляет за жизнью (выданного им) Java-объекта И уничтожает его в нужный момент...
Именно 'скоупы' определяют область видимости (жизни) для Java-объектов И таким способом Spring автоматически уничтожает Java-объект.

По сути можно класс с любым скоупом определять в любом классе с другим скоупом...но при этом:
- 'Singleton' бин всегда существует только в единственном экземпляре(является потоко-НЕбезопасным) И всегда будет существовать...
  Если 'Singleton' бин является зависимым для для другого объекта (то есть внутри другого объекта будет объявлено поле типа-класса 'Singleton') >> тогда при удалении этого другого-объекта ничего страшного НЕпроизойдет (объект удачно удалиться и программа успешно будет продолжать работать...)
- 'Prototype' бин (или любой другой) существуют во многих экземплярах НО будет существовать только лиш кратковременно...
  Если 'Prototype' бин является зависимым для для Singleton-объекта (то есть внутри Singleton-объекта будет объявлено поле типа-класса 'Prototype') >> тогда при удалении этого другого-объекта удалиться и ссылка на него И это приведет к ошибке 'NullPointerException'

В 'Singleton' бине можно успешно создавать разовые объекты для генерации например случайных чисел И такие разовые объекты успешно будут работать для всех других объектов...

------------------------------------------------------------------------------------------------------------------------------------------------------
@Inject - (это EJB-ая аннотация) каждый интерфейс может иметь несколько реализаций, причем эти реализации могут являться наследками. Такие реализации обычно храняться в виде бинарного Java-класса (jar-файла).
          Так вот, иньекция ищет в модулях проекта такой jar-файл который более-ближе подходящий для реализации интерфейса и иннициализирует-создает новый объект в месте где было объявлено это поле-переменная...
@Inject(name="ivanIvanov") - в Spring-фреймворке существует собственная, уже переопределенная, аннотация иньекции котороя аналогично использованию аннотации @Autowired...
@Autowired - (это Spring-ая аннотация) Spring-фреймворк имеет IO-контейнер в котором лежат уже подготовленные Java-объекты (которые были созданы согласно указаным в конфигурации требованиям).
          Так вот, автовайред по востребованию достает из своего IO-контейнера такой уже подготовленный конкретный Java-объект и отдает его копию клиенту в месте где было объявлено это поле-переменная...
          (а еще, в зависимости от указанного скоупа [это область видимости для объектов], автовайред управляет жизненным циклом объектов И самостоятельно следит за уничтожением выданных объектов согласно указанному в конфигурации скоупу...)
@Resource - (это Spring-ая аннотация) обычно эта аннотация используется аналогично [@Resource(name="mariaIvanova")] как если-бы вызывались в паре аннотации:
            @Autowired
            @Qualifier("mariaIvanova")
______________________________________________________________________________________________________________________________________________________
======================================================================================================================================================
Дело в том что веб-приложение имеет жизненный цыкл, который зависит от разных применяемых технологий внутри такого распределенного приложения, это:
- передача / транспортировака данных из клиентской рабочей станции на сторону удаленного сервера по HTTP/HTTPS/FTP протоколу
- управление жизненным цыклом Java-объектов (создание-удаление, период существования) на стороне сервера приложений согласно клиентским транзакциям
- поддержка постоянной сохранности клиентских данных и возможность восстановления клиентских данных
- JMS-протокол который гарантирует дооставку данных с учетом приоритетов и целостности в случаях нестабильной работы
Работа с отдельной-выбранной такой технологией в веб-приложением, это есть - контекст (Context - на уровне выбранного контекста можно выполнять только специальные операции над данными...)

> Для работы с этими технологиями в EJB (Enterprice Java Beans) есть: 'бины' (EJB-бин) и 'скоупы' (scope)
  Первым делом клиент формирует и отправляет запрос из клиентской рабочей станции на сторону сервера по HTTP-протоколу (механизм работы HTTP-протокола работает по схеме запрос-ответ).
  На стороне сервера стоит сервер приложений который обрабатывает все клиентские запросы... На обработку такого клиентского запроса может тратиться много времени И все это время клиент находиться в ожидании ответа (веб-страница на его веб-браузере заблокирована...)
  Сервер приложения может по случаю ломаться... И для восстановления состояния клиента применяется уже другой сервер EIS (Enterprise Information Server - универсальный доступ к данным используя единый SQL-стандарт).
  А чтобы клиент НЕждал долгое время пока его запрос обрабатывается для этого решения есть DMB-бин (Driven Message Bean) который гарантирует доставку клиентского сообщения по JMS-протоколу НЕдожидаясь пока это сообщение будет обработанно...
  + Итак, существую разные EJB-бины с разными свойствами:
    - Каждый клиентский запрос (Request) всегда являеться независимым, то есть, сервер приложения каждый клиентский запрос рассматривает как новый (даже если это выполняется внутри сессии...).
      В каждом таком независимом клиентском запросе данные храняться только одно-разово (на период времени для отправки / выполнения клиентского запроса И получения ответа...после этого данные пропадают)
      Такое одно-разовое / независимое состояние поддерживает - 'Stateless-бин'
    - В случае когда клиентские запросы зависимы друг от друга (например: клиентская корзина покупок в магазине ИЛИ состояние прав доступа...) для этого требуется в каждом новом запросе передавать состояние предыдущего запроса.
      В этом случае такие зависимы клиентские запросы будут очень громоздкими. Для решения такой проблемы существуют - клиентские сессии (Session - они хранят состояние полей для каждого клиента на стороне сервера...)
      Такие много-разовые зависимые клиентские запросы поддерживает - 'Statefull-бин'
    - Клиентский запрос уже попал на сервер приложения И теперь сервер приложений должен выполнить еще один запрос на EIS-сервер в базу данных чтобы достать там хранимую информацию о клиенте (и начать ее обрабатывать...)
      Поэтому обработку клиентского запроса можно разделить на две области: обработка клиентской информации на стороне EIS-сервера в базе данных; И обработка клиентской информации на сервере прложений;
      Для решения такой проблемы существует - механизм кеширования данных (результаты всех ранее выполненых запросов в базу данных, кторые были выполнены однажды, сохраняются на стороне сервера приложений, чтобы потом иметь возможность мгновенно получить информацию...)
      Работу с запросами к базе данных и с механизмом кеширования подерживает - 'Entity-бин'
    - Теперь еще остается обработка клиентской информации на сервере прложений. При больших объемах информации, может тратиться много времени на ее обработку.
      Иногда бывает что клиенту ненужна информация что обрабатывается в этот момент...когда-то позже клиент может запросить результаты по обработке этого зпрроса.
      Поэтому, в некоторых случаях, для клиента нет смысла ждать полный цыкл обработки данных. Достаточно будет только отправить данные на обработку И НЕожидать выпонения его результата...
      Для решения такой проблемы существует JMS-сервер, который гарантирует доставку клиентского сообщения в модуль-обработчик на сервере приложений.
      Такую схему для обработки данных поддерживает - 'DMB-бин' (Driven Message Bean)
  + Проектирование схемы (порядок построения) EJB-бинов позволяет получить максимальную производительность по скорости работы (отдачи) веб-приложения для клиентского использования...
    В действительнсти-же EJB-бины представляют собой всего-лиш раскиданные-установленные хранилища (временные-постоянние) из которых можно быстро вытянуть информацию на промежутках всего жизненного цикла веб-приложения (чтобы сократить прохождения полного цыкла обработчика данных для получения информации).
    (таким образом на линии жизненного цыкла веб-приложения можно проследить за областями на каких этапах задействованы EJB-бины И насколько эффективно разработчик спроектировал схему для хранения данных...чтобы сократить прохождения полного цыкла обработчика данных для максимально быстрого-эффективного получения информации на промежутках всего жизненного цыкла веб-приложения)
      Скоупы - это области которые как-бы описывают жизненный цыкл веб-приложения уже для обработчиков данных (то есть, скоупы НЕхранят данные, они занимаются только обработкой уже имеющих-полученных данных).
    - Итак, скоупы обварачивают области жизненного цыкла веб-приложения для выполнения обработки данных.
      Внутри каждого скоупа есть какой-то обработчик данных...
    - А уже внутри каждого обработчика данных есть EJB-бин для получения данных клиентского запроса...
    Правильно спроектированные скоупы для обработчиков данных позволяют добиться эффективности: максимально-быстрое время затрачиваемое на обработку данных И по минимуму использование ресурсов памяти...
    Если скоупы спроектированны НЕправильно:
      -- через мерно частый вызов объектов приведет к затрате большего времени на создание новых объектов - это понизит скорость по производительность по скорости;
      -- через мерно редкий вызов объектов приведет к затиранию данных в клиентских запросах - это приведет к потере клиентских данных;

Таким образом разработчик может спроектировать схему EJB-бинов:
- Использовать 'Statefull-бин' чтобы зависимые клиентские запросы содержали минимальный размер И НЕгрузили трафик HTTP-протокола...
- Использовать 'Entity-бин' чтобы кешировать клиентские данные ЕСЛИ клиенту НЕнужно получать обновленные данные И сэконоить время на обработке данных...
- Использовать 'DMB-бин' чтобы НЕждать сейчас выполнения полного цыкла обработки данных А запросить информацию позже, для востребования...
И спроектировать схему скоупов:
- чтобы добиться эффективности: для максимально-быстрого времени затрачиваемое на обработку данных И по минимуму использование ресурсов памяти...

> Servlet - всего-лиш выступает в роли контроллера (слушивает клиентские запросы через HTTP-протокол, реализуя методы GET/POST/PUT/DELETE)...и обрабатывает или вызывает обработчик данных
> JSP - выступает в роли представления (помогает формировать клиентсткую веб-страницу)
> База данных - выступает в роли модели (это сущность объекта...)

> Технологии EJB (Enterprice Java Beans) также управляют жизненным цыклом существования Java-объектов - контролируют время создания / удаления Java-объектов И период жизни Java-объектов:
  - Но для этого разработчику нужно самостоятельно проектировать такую схему
  - Создание всех Java-объектов выполняется явно, оператором 'new'
  - И только уже после того как такая схема будет спроектирована, технология EJB сможет возвращать Java-объекты по требованию клиента
> Spring-фреймворк берет это-же проектирование на себя и делает это вместо разработчика:
  - Spring-бин отличаются от EJB-бина тем что жизненный цыкл Spring-бина контролируется Spring-фреймворком.
    И такой Spring-бин является уже компонентом (Component).
    В Spring-е также существуют разные компоненты: 'Controller', 'Service', 'Repository'. Эти компоненты в Spring-фреймворке играют ту-же роль что и EJB-бины в технологии EJB...И аналогично также Spring делает проектирование.
  - Spring-фреймворк имеет IO-контейнер, куда подготавливает и загружает все Java-объекты веб-приложения
  - Разработчик НЕможет сам создавать Java-объекты в Spring-е через оператор 'new', потому-что посзданием объектов занимаеться контейнер Spring-а...
  - Разработчик может только управлять / устанавливать конфигурацию для компонентов (Spring-бинов). Причем разработчик это может в горячем режиме, без перекомпилирования кода (потому-что за все это отвечает Spring)
  - Итак, Spring сам создает и проектирует Java-объекты веб-приложения.
    Дальше, в момент по требованию клиента, Spring достает из своего IO-контейрера копию уже готового объекта и отдает его клиенту (кастомеру...) в месте объявления поля этого типа.
    Именно такая обратная процедура создания Java-объектов и является - IoC / DI (иньекция зависимостей...)
  - С помощью скоупов Spring может управлять жизненным цыклом Java-объектов.
    А также позволяет эфективно проектировать приложения чтобы количество создания новых Java-объектов имело максимально-быстрое время затрачиваемое на обработку данных И по минимуму использование ресурсов памяти (аналогично технологии EJB...)

> Жизненный цыкл Spring-а:
  - Сначала загружаются Java-файлы
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
(Thoughts...!!!!!! ** Injecting a prototype/Session bean into a singleton bean) http://ankursinghal86.blogspot.com/2014/07/injecting-prototypesession-bean-into.html
(Re: Объясните пожалуйста подробно, как это работает) http://rsdn.ru/forum/java/4490324.hot
(Блог о... ** 3. Spring. Beans) http://albazh.blogspot.com/2015/09/3-spring-beans.html
(javatalks.ru ** Сессия в Spring MVC ввела в заблуждение) http://javatalks.ru/topics/44435

(meeting2/links.txt) https://github.com/JobTest/MSL/blob/develop3/src/main/java/example/testtask/java8/meeting2/links.txt
(jpaexample/JPAExample.java) https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
(ссылки на подготовку по Java) https://mail.yandex.ua/?ncrnd=596&uid=40270829&login=sashakmets#message/158188936911391773/r=Java%20%D0%BF%D0%BE%D0%B4%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D0%BA%D0%B0\&pos=8&reqid=c85a274cc3e939a2d2c478af07b4b2a1&filter=folder:,attaches:no,dates=-
(meeting3/README.md) https://github.com/JobTest/MSL/tree/develop4.2/src/main/java/example/testtask/java8/meeting3
(jpaexample/EJB.md) https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/EJB.md

(Евгений Борисов ** Spring-потрошитель, часть 2) http://www.sql.ru/forum/1181606-2/spring-inzhektit-biny-s-raznym-skoupom-drug-v-druga
(тимур батыршинов ** Что такое Spring Framework) http://javabegin.ru/spring/
(тимур батыршинов ** 45 - Spring. Создание проекта Spring MVC) https://www.youtube.com/watch?v=l7gBzoiX6Eo
(Spring 3 и @Controller. Часть 1) http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-1.html
(Spring 3 и @Controller. Часть 2) http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-2.html
(Spring 3 и @Controller. Часть 3) http://www.seostella.com/ru/article/2012/04/27/spring-3-i-controller-chast-3-cookievalue-i-requestheader.html
http://www.sql.ru/forum/901344/kakie-priemushhestva-ispolzovaniya-ioc-konteynera
http://2014.javapoint.ru/presentations/Borisov_spring.pdf
http://stackoverflow.com/questions/25000406/how-many-instances-created-for-singleton-bean-referring-to-a-session-bean-protot

(Есть ли будущее у MVC-шаблона?) https://dev.by/lenta/main/est-li-buduschee-u-mvc-shablona
(написал web-приложение «Каталог автомобилей») https://sohabr.net/habr/post/240033/
https://javatalks.ru/topics/44268
http://www.javatpoint.com/spring-3-mvc-tutorial














