package com.voituk.jpaexample;

import java.util.Date;
import java.util.Iterator;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

/**
 * (java persistence api что это)
 * http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 * http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 * (jpa persistence стратегии)
 * http://habrahabr.ru/post/265061/
 * http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 * http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 * http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * http://habrahabr.ru/post/172239/
 * http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * 
 * *******************************************************
 * JDBC-интерфейс являеться стандартным способом при работе с базами данных.
 * Но JDBC-интерфейс имеет имеет недостатки:
 * - реализация клиентской стороны включая и драйвер коннекта к базе ложиться исключительно на плечи разработчика...
 * - драйвер коннекта к базе сильно зависит от Операционной Сиситемы и железа на стороне клиента где его используют...
 * - разработчику который использует этот JDBC-интерфейс приходиться самостоятельно реализовывать JAVA-класы (сущности) которые моделируют таблицы базы данных...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * JPA (Java Persistence API) - являеться ORM-фреймворком который решает эти задачи и упрощает жизнь разработчику:
 * - кросс-платфоорменная (независимая) реализация драйвера коннекта к базе!
 * - реализует работу с таблицами базы данных на уровне классов!
 * - и собстввенно все транзакции к базе выполняются под управлением исключительно ORM-фреймворка (так что разработчик НЕпариться над порядком построения транзакции и контролирование дедлоков)!
 * 
 * *******************************************************
 * Итак, есть база данных и есть клиенты...
 * Клиенты делают чтение и запись данных в базу...
 * Для выполнения (клиентских) транзакций к базе клиенту нужно подключиться к этой базе...
 * При подключение клиента к базе создается сессия в рамках которой выполняются все транзакций...
 * Каждая транзакция на изменение должна иметь подтверждение (как факт правильности инструкций и начало выполнения)...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Итак:
 * - существует много клиентских коннектов к базе - сессий;
 * - существует активная инструкция (которая выполняется в текущий момент)...;
 * - и существуют другие инструкции (НЕактивные)...;
 * Дело в том что в базе данные являются общими, то есть, одновременно эти данные могут изменять много клиентов И при этом повредить данные которые еще НЕзафиксированы...
 * Чтобы избежать случаев когда несколько клиентов пытаются одновременно изменить одни и те-же данные И избежать ошибок - для этого и существуют "уровни изоляции":
 * 1. READ UNCOMMITTED  ( изоляция уровня чтения неподтвержденного )
 *    Указывает что другие транзакции могут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 2. READ COMMTITED  ( изоляция уровня чтения подтвержденного )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 3. REPEATABLE READ  ( изоляция уровня повторяемого чтения )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 * SNAPSHOT
 * 4. SERIALIZABLE  ( упорядоченная изоляция )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 *    И другие транзакции НЕмогут вставлять новые строки-данные со значениями ключа которые входят в диапазон ключей ДЛЯ считываемых инструкциями этой-текущей транзакции до ее завершения.
 *    
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *                                                             (Spring Roo in Under Nine Minutes) https://www.youtube.com/watch?v=K78vL72XDqw
 * (По следам Spring Pet Clinic. Maven/ Spring Context/ Spring Test/ Spring ORM/ Spring Data JPA) http://habrahabr.ru/post/232381/
 * 
 *                   (java persistence api что это)
 *           (Introduction to Java Persistence API) http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 *             (Java Persistence API (JPA): Основы) http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * (SET TRANSACTION ISOLATION LEVEL (Transact-SQL)) https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 *                                                            (jpa persistence стратегии)
 **                 (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *       (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 *   (Начало работы с Java Persistence API) http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * 
 *                               (уровни изоляции как работают)
 ** (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 *                          (MySQL: уровни изоляции транзакций) http://habrahabr.ru/post/135217/
 *                (Уровни изоляции транзакций в SQL. Шпаргалка) http://www.arbinada.com/main/ru/node/619
 * 
 *                                  (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * (PowerMock (+Mockito): новый взгляд на unit-тестирование) http://habrahabr.ru/post/172239/
 *                      (Тестирование GWT с помощью Mockito) http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *                                             (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php | https://books.google.com.ua/books?id=yqW0D1U0Q9IC&pg=PA343&lpg=PA343&dq=грязное+чтение+неповторяемое+чтение+чтение+фантомов&source=bl&ots=Hc3e5tQSpr&sig=c49sASAVEk_sh5xH1o2DoEaXusc&hl=ru&sa=X&ved=0ahUKEwj3nKO3r8zJAhXBFiwKHeh8CH8Q6AEIMjAE#v=onepage&q=грязное чтение неповторяемое чтение чтение фантомов&f=false
 *                                  (Уровни изоляции транзакции) https://www.youtube.com/watch?v=ovG4QXNpu7U
 *                (Уровень изоляции READ COMMITED SNAPSHOT в 1С) https://www.youtube.com/watch?v=D8PHwf5RHB4
 * (Уровень изоляции неповторяемое чтение, Неповторяемое чтение) https://www.youtube.com/watch?v=TWTDFWxSRYs
 *                          (Уровень изоляции Serializable в 1С) https://www.youtube.com/watch?v=TAGNnvCghlY
 *   (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 * 
 * Транзакции - защищают данные с которыми работает пользователь чтобы другой пользователь их неиспортил.
 * Но существуют ситуации когда данные ненужно защищать (потому-что они неявляются важными)...
 * Поэтому одни данные являются очень важными и их нужно защищать, а другие данные неявляются важными или имеют среднюю важность их можно выборочно защищать.
 * Уровень изоляции транзакции - это набор правил которые определяют насколько сильно нужно защищать данные (в транзакциях).
 * 
 * > В ходе выполнения транзакции результат выполнения может быть либо применен-зафиксирован либо отменен-откат.
 * Так вот, пока транзакция еще небыла зафиксирована - нет никакой гарантии что может быть откат - и все незафиксированные данные пропадут - это "Грязное чтение"
 * 
 * > В ходе выполнения транзакции читаем каждую строку (если их много) с какой-то последовательностью.
 * И пока читаем эту строку - она заблокирована от изменения, но как только закончили ее читать и перешли к другой, тогда другая транзакция может изменить освободившуюся строку.
 * То есть нет никаких гарантий что между чтением строки и фиксированием транзакции эта строка не будет снова изменена - это "Неповторяемое чтение".
 * 
 * > В ходе выполнения транзакции также читаем строки (если их много) с какой-то последовательностью...
 * И в этот момент другая транзакция вставляет новые строки между читаемыми строками уже после их прочтения (здесь нет блокировок на еще отсутствующие строки).
 * То есть нет никаких гарантий что после прочтения всех строк до момента фиксированием транзакции не будет добавления новых строк - это "Чтение фантомов".
 * 
 * 1. READ UNCOMMITTED (нет защиты, существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 * 2. READ COMMTITED   (решается проблема "Грязного чтения")
 * 3. REPEATABLE READ  (решается проблема "Неповторяемого чтения")
 * 4. SERIALIZABLE     (решается проблема "Чтения фантомов")
 * 
 * (Базы данных. Вводный курс) http://citforum.ck.ua/database/advanced_intro/80.shtml
 * (Уровни изоляции транзакций в SQL) http://www.osp.ru/pcworld/2009/07/9708191/
 * (Блокировки и уровни изоляции транзакций InnoDB в MySQL) http://habrahabr.ru/post/238513/
 * http://shurshun.ru/tranzaktsii-blokirovki-urovni-izoliovannosti-tranzaktsiy-v-mysql/
 * http://kek.ksu.ru/EOS/BD/SQL_transaction.html
 * http://www.sql.ru/forum/699859/izuchau-urovni-izolyacii-tranzakciy-v-sql-neponyatnoe-povedenie-read-committed
 * http://habrahabr.ru/post/135217/
 * http://www.arbinada.com/main/ru/node/619
 * (уровни изоляции транзакций hibernate)
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *  (На пути к правильным SQL транзакциям (Часть 1)) http://habrahabr.ru/company/infopulse/blog/261097/
 ** (На пути к правильным SQL транзакциям (Часть 2)) http://habrahabr.ru/company/infopulse/blog/261101/
 *  (Типичные взаимные блокировки в MS SQL и способы борьбы с ними) http://habrahabr.ru/company/mindbox/blog/261661/
 *  (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php  |  http://datasql.ru/basesql/16.htm
 *  
 * Сервер накладывает блокировки на данные (при использовании небольших транзакций) для повышение эффективности работы.
 * Блокировка - (временное) ограничение на выполнение некоторых операций обработки данных (может быть наложена на отдельную строку так и на всю базу).
 *  
 * Сессия - это канал связи между клиентом и сервером для обмена данными...
 * Транзакция - это защита данных, чтобы другая транзакция их неиспортила...
 * Уровни изоляции - это набор правил (блокировок) которые определяют степень защиты данных...
 * ...........................................................................................
 * Есть физические данные и абстрактные данные:
 * > физические данные - имеют (описываются) модульную структуру, которая позволяет исключить дублирование и сжимать информацию тем самым повысить скорость-производительность доступа к данным (лежат на медленном дисковом устройстве)
 * > абстрактные данные - являются частицей физических данных, эта временная рабочая/незафиксированая информация (может быть отменена)
 * Только после подстверждения данные попадают из абстрактной области в физическую область.
 *  
 * Блокировки в SQL - это такой себе строительный эелемент который позволяет моделировать разные способы защиты.
 * Условно блокировки можно разделить на 2-а вида: на запись; на чтение;
 * Дело в том элемент-блокировки прежде всего являеться логической компонентой которая описывается так:
 * - Разновидности блокировок по типу блокируемых ресурсов: на строку, на ключ, на страницу, на таблицу, на базу;
 * - Разновидности блокировок по режиму блокирования: Совмещаемая (Shared) блокировка - на чтение; Монопольная (Exclusive) блокировка - на запись; Блокировка обновления (Update)- на чтение/запись; Блокировки с намерением (Intent) - расширяет ресурс при множествености..; ...
 * 
 * (Используя блокировки - уровни изоляции моделируют разные ступени способов защиты на стороне сервера; - А с помощью уровней изоляции разработчик выбирает оптимальный вариант между скоростью и качеством выполнения запросов;)
 * Уровни изоляции транзакции влияют на скорость работы системы поэтому важно правильно выбирать уровень изоляции в зависимости от задачи которую выполняет транзакция:
 * (чем выше уровень изоляции, тем меньше степень одновременного конкурентного доступа но гарантирует полную изоляцию параллельных конкурентных транзакций)
 * 1. READ UNCOMMITTED (нет защиты)
 *                     его следует применять только в тех случаях, когда точность данных не представляет важности или когда данные редко подвергаются изменениям
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 *                     если необходимо отображать real time статистику по постоянно изменяющимся данным для построение отчетов
 *                     
 * 2. READ COMMTITED   (выполнят проверку только на наличие монопольной блокировки для данной строки)
 *                     (здесь блокировки отменяются сразу-же после обработки данных (обычно все блокировки отменяются в конце транзакции))
 *                     улучшает параллельный/одновременный доступ к данным
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Грязного чтения")
 *                     (по умолчанию) обычно достаточно использовать для чтения данных, без какой либо транзакции
 *                     
 * 3. REPEATABLE READ  (устанавливает разделяемые блокировки на все считываемые данные и удерживает эти блокировки до тех пор, пока транзакция не будет подтверждена или отменена)
 *                     В этом случае многократное выполнение запроса внутри транзакции всегда будет возвращать один и тот же результат.
 *                     Недостатком этого уровня изоляции является дальнейшее ухудшение одновременного доступа поскольку период времени в течение которого другие транзакции не могут обновлять те же самые данные значительно дольше чем в случае уровня READ COMMITTED.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Неповторяемого чтения")
 *                     если вставка новых записей в параллельных транзакциях никак не может повлиять на результат текущей транзакции
 *                     части которых могут быть изменены во время чтения
 *                     
 * 4. SERIALIZABLE     (устанавливает блокировку на всю id-область данных, считываемых соответствующей транзакцией, поэтому предотвращает вставку новых строк другой транзакцией до тех пор пока первая транзакция не будет подтверждена или отменена)
 *                     Уровень изоляции SERIALIZABLE реализуется, используя метод блокировки диапазона ключа (устанавливает блокировку на всю область данных считываемых соответствующей транзакцией).
 *                     Не допускает возникновения всех трех проблем параллельного одновременного конкурентного доступа, перечисленных ранее.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Чтения фантомов")
 *                     если транзакция изменяет данные в БД и при этом проверяет, чтобы эти данные не противоречили уже существующим записям в БД
 *                     части которых могут быть изменены во время чтения
 *                     
 * Существуют 3-и команды, которые используются для управления транзакциями:
 * 1) COMMIT – для сохранения изменений;
 * 2) ROLLBACK – для отмены изменений;
 * 3) SAVEPOINT – для установки особых точек возврата.
 * 
 * Транзакция определяется на уровне соединения с базой данных и при закрытии соединения автоматически закрывается (когда транзакция начинается все команды считаются телом одной транзакции пока не будет достигнут ее конец).
 * SQL Server предлагает множество средств управления поведением транзакций. Пользователи должны указывать только начало и конец транзакции используя SQL-команды или API:
 * 1) "автоматическое" (по умолчанию SQL Server работает в режиме автоматического начала транзакций, когда каждая команда рассматривается как отдельная транзакция - если команда выполнена успешно то фиксируются... инначе - откат);
 * 2) "подразумеваемое" (когда пользователю понадобится создать транзакцию, включающую несколько команд, он должен явно указать транзакцию);
 * 3) "явное" (SQL Server не может находиться в режиме исключительно явного определения транзакций, этот режим работает поверх двух других);
 * 
 * (Руководство по блокировке и управлению версиями строк транзакций SQL Server) https://msdn.microsoft.com/ru-ru/library/jj856598%28v=sql.120%29.aspx  |  https://msdn.microsoft.com/ru-ru/library/ms187373.aspx
 * (Транзакции и блокировки) http://reis.rtf.urfu.ru/portal/prime/po/sql/70.htm
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Различают 2-а вида блокировки:
 * 1) блокировка записи – транзакция блокирует строки так что запрос другой транзакции к этим строкам будет отменен;
 * 2) блокировка чтения – транзакция блокирует строки так что запрос со стороны другой транзакции на блокировку записи этих строк будет отвергнут, а на блокировку чтения – принят;
 * 
 * блокировки на логических уровнях...
 * 
 * уровни блокировок (по типу блокируемых ресурсов):
 * + на уровне строк;
 * - на уровне ключа;
 * - на уровне страницы; 
 * + на уровне таблиц;
 * + на уровне базы;
 * 
 * уровень 0 – запрещение "загрязнения" данных.
 * уровень 1 – запрещение "грязного" чтения.
 * уровень 2 – запрещение неповторяемого чтения.
 * уровень 3 – запрещение фантомов.
 * 
 * Блокировки в среде MS SQL Server, Управление блокировками
 * 
 * https://www.youtube.com/watch?v=daA8jAMyo_c
 * http://sqlcom.ru/
 * https://www.youtube.com/watch?v=iGsbXLgZMlo
 * https://www.youtube.com/watch?v=I6WKOVYdgWU
 * 
 * *******************************************************
 *                 (Урок 2. Понятия базы данных, отношения, ключи и др) http://www.realcoding.net/article/view/127
 * (14 вопросов об индексах в SQL Server, которые вы стеснялись задать) http://habrahabr.ru/post/247373/
 * 
 * (InnoDB | Внешние ключи и транзакции ** FOREIGN KEY >> REFERENCES: CASCADE|RESTRICT) http://asmodeus.com.ua/library/soft/mysql/innodbpk.html
 * (Створення або змінення таблиць та індексів за допомогою запиту на визначення даних) https://support.office.com/uk-ua/article/Створення-або-змінення-таблиць-та-індексів-за-допомогою-запиту-на-визначення-даних-d935e129-229b-48d8-9f2d-1d4ee87f418e
 *                                                          (Использование Constraints) http://www.askdev.ru/question/5235/Использование-Constraints/
 *                     (CONSTRAINT используется для создания и удаления ограничений...) https://support.office.com/ru-ru/article/Предложение-CONSTRAINT-e5241593-139a-4eb7-ad30-61026873191e
 * (19. ПОДДЕРЖКА ЦЕЛОСТНОСТИ ВАШИХ ДАННЫХ) http://www.sql.ru/docs/sql/u_sql/ch19.shtml
 *                                          http://www.flenov.info/books.php?contentid=5
 *                                          http://www.flenov.info/books.php?contentid=6
 * 
 * Строки в таблицах базы являются объемными (объектами) элементами и несут в себе информацию и многих полях... поэтому операция сравнения-перебор-поиск нужного элемента-строки являеться очень (трудозатратным) трудоемким действием.
 * Если говорить о маленьких таблицах, такое (трудозатратное) трудоемкое действие сравнения-перебор-поиск нужного элемента-строки, мало влияет на производительность...
 * Но в больших таблицах это несет уже большие потери по производительности.
 * Поэтому, чтобы более эффективно решить проблему с перебором-поиском для нужного элемента-строки, используют ссылку на строку - этот элемент представляет 1-но поле с коротким значением (что позволяет повысить производительность при выполнении действия по перебору-навигации).
 * Итак, ссылка на строку, являеться - "ключем".
 * + достоинства: ускоряет поиск строки в больших траблицах;
 * - недостатки: требуется выполнять дополнительные запросы чтобы (вытянуть) получить информацию из строки;
 * 
 * В таблицах средней величины использование "ключей" - являеться эфективным способом...
 * Но в очень больших таблицах даже работа с "ключами" являеться (относительно) трудозатратной по времени. И чтобы ускорить этот процесс - есть механизм сортировки...
 * Механизм сортировки создает специальную структуру (иерархического сбалансированного дерева), которая перебирает (не все элементы в подряд) только выборочные элементы по специальному алгоритму (что позволяет сокращать количество операций для достижения такого-же результата).
 * Итак, механизм сортировки ключей/полей, является - "индексом" (то есть, "индекс" это (не альтернатива) являеться дополнением "ключа" для повышения эффективности в очень больших таблицах).
 * – "кластеризованный индекс" ..... применяется для разных полезных полей (столбцов с данными), то есть НЕтребует дополнительных запросов в строку чтобы вытащить инфорацию И может быть отсортирован в заданом порядке... НО на всю таблицу он может быть только один;
 * – "некластеризованный индекс" ... применяется только для ключей (ссылки-указатели на строки), то есть требует выполнения дополнительных запросов в строку чтобы вытащить инфорацию И НЕможет быть отсортирован... Но в каждой таблице может быть много проиндексированных таких полей;
 *  
 * Ключи и индексы в базе
 * -----------------------
 * В таблице есть колонки которые содержат полезные данные (необходимые для работы). И таких строк (с полезными данными) в таблице очень много...
 * Поэтому существует проблема поиска данных - при условии что таких колонок много...процесс поиска становиться сложным и трудоемким.
 * Ключ - это колонка с (легковестными) простыми-уникальными значениями, которые являются как-бы ссылками на строки содержащие полезные объемные-данные
 * Недостатки "ключа" в том что требуется еще делать дополнительные запросы чтобы вытащить полезные данные со строки...
 * 
 * 1) Потенциальный ключ (KEY) ....... это любое 1-но поле (колонка) только с полезными данными, которое обладает уникальностью (неповторимостью)
 * 2) Уникальный ключ (UNIQUE) ....... это комбинация полей (колонок) только с полезными данными, которое обладают уникальностью (неповторимостью)
 * 3) Первичный ключ (PRIMARY KEY) ... (может быть только один на всю таблицу) добавляеться новое (специальное) поле-счетчик
 * 4) Альтернативные ключи ........... это все остальные поля (колонки), которые НЕявляются потенциальными, уникальными и первичными ключами
 * 5) Внешние ключи (FOREIGN KEY) .... это поля (колонки) которые ссылаются на первичные ключи в других таблицах (в такой способ связывая между собой таблицы в единую целостность)
 *                                     (поле с полезными данными которое ссылается на другое поле с первичным ключем называется - внешней ссылкой; а первичный ключ на который ссылаются называется - родительским ключом;)
 * На "внешний ключ" накладываются специальные ограничения (CONSTRAINT):
 * – CASCADE .... означает распространение действий родительской таблицы на дочерние, то есть, если значение ключа в родительской таблице изменится то оно автоматически (без специальных запросов) изменится и в дочерних таблицах
 * – RESTRICT ... означает что нельзя редактировать значение ключа или удалять строки из родительской таблицы пока есть соответвующие внешние ключи в дочерних таблицах (это правило является правилом по умолчанию).
 * Необходимо помнить, что единая сущность таблиц, которые связываются внешними ключами, имеют специальные ограничения на изменение таблиц (так чтобы сохранить эту самую единую сущность). 
 * 
 * Индекс - это улучшение "ключа" (но это не замена "ключа").
 * Идея в том что "индекс" применяет сортировку для организации более эффективного поиска-доступа к полезным данным.
 * А также "индекс" может непосредственно работать с полезными данными (то есть, отпадает необходимость в делать дополнительные запросы...) - это еще более ускоряет работу поиска-доступа
 * 
 * Работу "индекса" можно описать так:
 * – Интексирование столбца начинается с корневого узла "Root"; двигаясь дальше, на промежуточном уровне, определяется страница с более детальной информацийе "Intermediate"; И уже на самом нижнем уровне выясняеться нужный индекс (листья индекса) "Leaf";
 * Итак, индексы бывают:
 * 1) Кластеризованный индекс ..... это поля (столбцы) которые содержат полезные (реальные) данные-значения в строках - а еще такие проиндексированные поля (столбцы) называются - "кучей";
 * 2) Некластеризованный индекс ... это только 1-но поле (столбец) который является ссылкой-указателем (ключом) на строку;
 * 3) Составной индекс ............ может содержать несколько полей (столбцов - до 16 столбцов их общая длина ограничена 900 байтами);
 * 4) Уникальный индекс ........... это только 1-но поле (столбец) который содержит уникальные-неповторимые полезные (реальные) данные-значения в строках;
 * 5) Покрывающий индекс .......... позволяет запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к строкам самой таблицы;
 * Необходимо помнить что индексирвоание изменяет первоначальную структуру таблицы, поэтому добавление индексов в таблицу сопровождаеться 'ALTER'
 * 
 * (Стратегии работы с транзакциями: Распространенные ошибки) https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000002287754030 >> http://www.ibm.com/developerworks/ru/library/j-ts1/
 * (...) https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao.java
 * (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 *                          http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-map.html
 *                          http://info.javarush.ru/translation/2014/02/11/9-главных-вопросов-о-Map-в-Java.html
 *                          http://evilcoderr.blogspot.com/2013/01/hash-table-c.html
 *                          http://www.cyberguru.ru/dotnet/net-framework/dotnet-structures-analysis2-page7.html
 * (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *       (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html 
 * 
 * (какие бывают CONSTRAINT)
 * http://www.sql.ru/docs/mssql/tsql_ref/
 * https://msdn.microsoft.com/ru-ru/library/bb964742%28v=sql.120%29.aspx
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *                               (Стратегии работы с транзакциями: Распространенные ошибки) http://www.ibm.com/developerworks/ru/library/j-ts1/
 * (Стратегии работы с транзакциями: Oбзор моделей транзакций и стратегий их использования) http://www.ibm.com/developerworks/ru/library/j-ts2/
 *                                                               (Транзакционные стратегии) http://www.k-press.ru/cs/2009/3/ts/ts.asp
 *                                                               
 *                                                     (Alex Tretyakov Blog ** Основы JPA) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
 *                              (Alex Tretyakov Blog ** JPA-маппинг сущности и ее свойств) http://alextretyakov.blogspot.com/2013/06/jpa-mapping-suschnosti-i-ee-svojstv.html
 *             (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *                   (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Table-per-concrete-class стратегии) http://alextretyakov.blogspot.com/2014/04/jpa-table-per-concrete-class-strategija.html
 * 
 ** (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * 
 * Транзакционные стратегии:
 * 1) стратегия слоя API ................ подходящую для бизнес-приложений с грубо гранулированным слоем API;
 * 2) стратегия Client Orchestration .... пригодную для бизнес-приложений с более тонко гранулированным слоем API;
 * 3) стратегия высокого параллелизма ... подходящую для приложений с большим числом одновременно работающих пользователей;
 * Например, стандартная структура:
 * - 'DAO' (на самом низком слое) происходит физическая связь/реализация транзакций между JAVA и базой
 * - 'Сервис' здесь реализована бизнес-логика приложения, она полностью описывает механизм транзакций и способы их откатов (методы для взаимодействия с физическим слоем И более тонко описывает транзакции)
 * - 'Контролер' (слой верхнего уровня, привязывается к пользовательским сессиям) на этом уровне программный код распаралеливается на пользовательские сессии и несет нагрузку на обработку паралельных запросов...
 * 
 * Модели транзакций:
 * – локальная модель ....... управление транзакциями осуществляется менеджером базы данных (а не приложением, то есть, управляем только соединениями но не транзакциями).
 *                            Эту модель можно использовать для доступа через JDBC к данным и хранимым процедурам.
 *                            Нельзя использовать локальную модель для выполнения изменений в базе данных через ОРМ (например: Hibernate, TopLink, Java Persistence API (JPA))
 *                           
 * – программная модель ..... ответственность за управление транзакциями возлагается на разработчика (мы сами управляем транзакциями которые оказываются изолированными от низкоуровневых соединений с базой данных);
 *                            Разработчик должен самостоятельно получить ссылку на транзакцию от менеджера транзакций, начать ее, затем подтвердить ее, а если возникло исключение – то откатить ее.
 *                          
 * – декларативная модель ... при работе с этой моделью контейнер самостоятельно начинает, подтверждает и откатывает транзакции.
 *                            Задачей разработчика является только описание поведения транзакций.
 *                            (это наиболее часто применяемая модель, которая известная как модель транзакций управляемых контейнером "Container Managed Transactions" (CMT)); 
 * 
 * (JPA-маппинг сущности и ее свойств)
 *  JPA-маппинг отношений типов: "один-к-одному","один-ко-многим","многие-к-одному","многие-ко-многим";
 *  JPA-маппинг иерархии классов с помощью: "Single-table стратегии","Joined стратегии","Table-per-concrete-class стратегии";
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *                               https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao.java
 *                               https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao2.java
 *                               https://github.com/JobTest/AddressBookDB/blob/master/src/main/java/com/dao/UserRolesDao.java
 * (Java Persistence/Persisting) https://en.wikibooks.org/wiki/Java_Persistence/Persisting
 *   (Java Persistence/Criteria) https://en.wikibooks.org/wiki/Java_Persistence/Criteria
 *
 * Для JPA:
 * *****************
 *    find (SELECT)
 * persist (INSERT)
 *  remove (DELETE)
 *   merge (UPDATE)
 * 
 * Для Hibernate
 * *****************
 * get|list (SELECT)
 *     save (INSERT)
 *   delete (DELETE)
 *   update (UPDATE)
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 **                            (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 *  (Время против памяти на примере хеш-таблиц на Java) http://habrahabr.ru/post/230283/
 *  (Под капотом Redis: Хеш таблица (часть 1)) http://habrahabr.ru/post/271205/
 * 
 * 1) Хеширование с цепочками (ОТКРЫТОЕ ХЕШИРОВАНИЕ)
 *    > это список обвернутый в массив.
 *    > Хеш-функция конвертирует хеш-код ключа в индекс ячейки для массива.
 *    > Если эта ячейка массива уже зайнята тогда:
 *      >> при поиске элемента в списке по 'equals' сравниваем ключи и для найденного элемента возвращаем состояние объекта
 *      >> при добавлении элемента, просто добавляем в конец списка
 *    ?????????????????????????????????????????????????????????
 *    Хеш-таблица - это ассоциативный массив - представление одних данных в другое.
 *    (Объекты) ключи - это элементы которыми внутри себя оперирует хеш-таблица. Данные - это есть ассоциативное представление ключей.
 *    (Объекты) ключи - должны быть легковестными (НЕбольшими) и пригодными для операций... Данные - обычно являются громоздкими (большими) объектами которыми трудно оперировать.
 *    Поэтому контракт 'hashCode|equals' применяется для (объекта) ключа (все операции внутри хеш-таблицы выполняются по ключу).
 *    В хеш-таблице существует ХЕШ-ФУНКЦИЯ которая вычисляет индекс-массива для хранения объекта по КЛЮЧУ. Проблема в том что относительная точность индекса-массива сравнительно с хеш-кодом очень низкая - именно это является основной причиной коллизии!
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    то есть, согласно контракту (Если объекты равны - тогда их хеш-коды гарантировано равны; Если хеш-коды разные - тогда объекты гарантировано разные; Но бывают случаи когда разные объекты имеют равные хеш-коды - это колизия;)
 *    поэтому в 'бекет-е' (список на который ссылаеться ячейка массива) лежат разные объекты-ключи с равными хеш-кодами. Теперь с помощью 'equals' проверяем на равенство (разных) объектов-ключей - таким способом находим элемент...
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    При поиске элемента: хеш-функция через хеш-код находит индекс-массива, а 'equals' находит/возвращает равный элемент.
 *    При добавлении элемента: хеш-функция через хеш-код определяет индекс-массива, а 'equals' находит равный элемент И заменяет его данные ИЛИ в случае отсутствия добавляет его в конец списка.
 *    Если изменить параметры определения хеш-кода (объекта) ключа - тогда потеряем ссылку на элемент внутри хеш-таблицы.
 *    А если НЕпереопределить 'equals' (объекта) ключа - тогда хеширование работать будет... но в случае коллизии элемент будет утерян (НЕзащищен).
 *    ?????????????????????????????????????????????????????????
 * 2) Хеширование с открытой адресацией (ЗАКРЫТОЕ ХЕШИРОВАНИЕ)
 *    > здесь имеем просто массив.
 *    > Хеш-функция конвертирует хеш-код ключа в индекс ячейки для массива.
 *    > Если эта ячейка массива уже зайнята тогда:
 *      >> делаем <линейный> поиск следующей (первой попавшийся) пустой ячейки и вставляем туда элемент...
 *         (в этом случае возникает проблема когда в какой-то элементы в массиве могут распределяться неравномерно - неэфективно заполняемое пространство ячеек...)
 *      >> для решения такой пролемы существует специальная <линейная> функция, которая ищет следующую ячейку (НЕпервую попавшеюся) с определенным шагом-пропуска...
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * (Что нам дает JPA) http://atamanenko.blogspot.com/2012/04/spring-data-jpa.html
 * Вообще Spring Data JPA пытается быть умным, поэтому реализация findBy{...} методов ищется следующим образом:
 * 1. Сначала смотрится аннотация @Query на объявлении метода, если она есть, то используется.
 * 2. Затем смотрится аннотация @NamedQuery с именем вида Entity.findMethodName, для вышеприведённого случая это будет User.findByLoginAndPassword.
 * 3. Если ничего не нашли. то по сигнатуре метода генерируется запрос.
 * У @Query следующие плюсы:
 * 1. Позволяет не засорять объявление доменной сущности.
 * 2. Сильно помогает, если у нас в запросе есть неявные джойны, потому что для таких запросов Spring Data JPA не умеет корректно генерировать запрос SELECT COUNT(*), который нужен в тех случаях, когда метод должен вернуть Page.
 * 
 * (spring технологии)
 *                                                        (...) http://javabegin.ru/products/spring/
 *                                                        (...) http://devcolibri.com/3732
 *                                                        (...) http://mai.pmoproject.ru/pages/viewpage.action?pageId=4424007
 * (Учимся готовить: Spring 3 MVC + Spring Security + Hibernat) http://habrahabr.ru/post/111102/
 * - Добавление класса сущности в модель домена.
 * - Слой доступа к данным.
 * - Сервис-слой.
 * - Добавление веб.
 * - Контроллер.
 * - Вид.
 * - Безопасность.
 * (Spring DATA, Spring REST, Spring MVC, Spring Security)
 * 
 * 
 * 
**  (Re: GWT MVP: pdf (еще) + Eclipse +++ (Фишай,Абсорс) + Spring Roo GWT & Spring Test/ Spring ORM/ Spring Data JPA +++) https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000002329443356
                                        (Евгений Беркунский ** Java Persistence API (JPA):Основы > Жизненный цикл Entity) http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
***                                        (Java для белок ** Вопросы на интервью по технологиям Java Spring и Hibernate) http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
***                                                 (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
**                                                                 (Alex Tretyakov Blog ** Основы JPA) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
**                                          (Alex Tretyakov Blog ** JPA-маппинг сущности и ее свойств) http://alextretyakov.blogspot.com/2013/06/jpa-mapping-suschnosti-i-ee-svojstv.html
**                                 (Alex Tretyakov Blog ** JPA-маппинг отношений типа "один-к-одному") http://alextretyakov.blogspot.com/2013/06/jpa-mapping-tipa-odin-k-odnomu.html
**           (Alex Tretyakov Blog ** JPA-маппинг отношений типов "один-ко-многим" и "многие-к-одному") http://alextretyakov.blogspot.com/2013/06/jpa-mapping-tipa-odin-ko-mnogim-i.html
**                              (Alex Tretyakov Blog ** JPA-маппинг отношений типа "многие-ко-многим") http://alextretyakov.blogspot.com/2013/07/jpa-mapping-tipa-mnogie-ko-mnogim.html
**                                              (Alex Tretyakov Blog ** Упорядочиваем коллекции в JPA) http://alextretyakov.blogspot.com/2013/07/uporyadochivaem-kollektsii-v-jpa.html
**                                            (Alex Tretyakov Blog ** JPA-маппинг перечисляемых типов) http://alextretyakov.blogspot.com/2013/07/mapping-perechislyaemyh-typov-v-jpa.html
**                                            (Alex Tretyakov Blog ** JPA-маппинг встроенных объектов) http://alextretyakov.blogspot.com/2013/08/jpa-mapping-vstroennyh-obyektov.html
**              (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
**                    (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
**  (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Table-per-concrete-class стратегии) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
*   (JPA работа с базой данных) http://devcolibri.com/1658
*   (Hibernate cache) http://habrahabr.ru/post/135176/
**  (Пример настройки Database Connection Pool) http://articles.javatalks.ru/articles/8
*   (Hibernate 3: введение и написания Hello world приложения) http://www.quizful.net/post/Hibernate-3-introduction-and-writing-hello-world-application
*   (Hibernate Tutorial) https://javatalks.ru/topics/11004
*
 * ***************************************************************************************************
 * >     (Загрузка загрузка файла-конфигурации и настройка среды) объекты сессии могут находиться в трёх состояниях: Transient,Persistent,Detached
 * >>    (Entity, Embeddable, Mapped Superclass) четыре статуса жизненного цикла Entity: new,managed,detached,removed
 * >>>   (JPA-маппинг сущности и ее свойств) типы связей между Entity, fetch-стратегии загрузки объектов, стратегии наследования мапинга в JPA: Single-table, Joined, Table per concrete, Transactional
 * >>>>  (кэш сесии|первого уровня, кэш фабрики сессий|второго уровня, методы очистки сессии) типы стратегий кэша: Read-only, Read/write, Нестрогий read/write, Transactional
 * >>>>> (SQL|JPQL диалект, Criteria) язык HQL|SQL-запросов, полиморфизм
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * > ORM - механизм сохранения java-объектов в базу данных.
 * > JPA - это описание спецификации.
 * > JPA/JDO - Это две спецификации для сохранения java-объектов в базу данных.
 *             JPA позволяет работать с реляционными базами.
 *             JDO более общая спецификация позволяет работать с реляционными базами и noSQL базами.
 * > Hibernate - это одна из реализаций JPA.
 * > EntityManagerFactory - соответствует persistence который содержит настройки для соединения с базой данных.
 *                          Persistence описывается в файле persistence.xml который должен находиться в директории resources/META-INF.
 * > EntityManager - это интерфейс который описывает API для всех основных операций над Entity (persist|merge|remove|refresh||detach|lock). EntityManager создается с помощью объекта типа EntityManagerFactory.
 *                   обеспечить механизмы создания/чтения/удаления для объектов:
 *                   - Для JPA: find (SELECT)
 *                              persist (INSERT)
 *                              remove (DELETE)
 *                              merge (UPDATE)
 * > SessionFactory - позволяет создавать сессии согласно конфигурации 'hibernate.cfg.xml' (создается один раз и используется во всем приложении)
 *                    Configuration - загрузка файла-конфигурации 'hibernate.cfg.xml' и настройка среды Hibernate (для коннекта к базе)
 * > Session - (Hibernate сессия) это главный интерфейс взаимодействия Java-приложения и Hibernate.
 *             Задача сессии обеспечить механизмы создания/чтения/удаления для объектов:
 *             - Для Hibernate: get|list (SELECT)
 *                              save (INSERT)
 *                              delete (DELETE)
 *                              update (UPDATE)
 * > Объекты сессии могут находиться в трёх состояниях:
 *   1. Transient - никогда не сохранялись и не ассоциированы ни с одной сессией (игнорируются);
 *   2. Persistent - ассоциированы с уникальной сессией (включаются);
 *   3. Detached - ранее сохраненные, но не ассоциированы с сессией. 
 * 
 * >> Entity - это легковестный объект бизнес логики.
 * >> Четыре статуса жизненного цикла Entity:
 *    1. new (объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных);
 *    2. managed (объект создан, управляется JPA, имеет сгенерированные первичные ключи);
 *    3. detached (объект был создан, но больше не управляется JPA);
 *    4. removed (объект создан, управляется JPA, но будет удален после commit-a транзакции);
 * >> Требования к Entity:
 *    1. класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации;
 *    2. класс должен содержать public/protected конструктор без аргументов (он также может иметь конструкторы с аргументами);
 *    3. класс не может быть enum или интерфейсом;
 *    4. класс не может быть финальным классом;
 *    5. класс не может содержать финальные поля или методы, если они участвуют в маппинге;
 *    6. поля класса должны быть доступны только методам самого класса и не должны быть напрямую доступны другим классам (getter/setter методам или другим методам бизнес-логики в Entity классе);
 *    7. класс должен содержать первичный ключ;
 * >> типы данных допустимы в Entity:
 *    1. примитивные типы и их обертки Java;
 *    2. строки;
 *    3. любые сериализуемые типы Java (реализующие Serializable интерфейс);
 *    4. enums;
 *    5. entity классы; 
 *    6. embeddable классы
 *    7. коллекции;
 * >> Можно использовать типы данных входящих в первичный ключ Entity:
 *    1. примитивные типы и их обертки Java;
 *    2. строки;
 *    3. BigDecimal и BigInteger;
 *    4. java.util.Date и java.sql.Date;
 * >> Embeddable - встраиваемый класс который не используется сам по себе (только как часть Entity):
 *                 класс должен быть отмечен аннотацией Embeddable;
 *                 классы должны удовлетворять тем же правилам что Entity;
 * >> Mapped Superclass - это класс-родитель от которого наследуются Entity:
 *                        класс должен быть отмечен аннотацией MappedSuperclass или описан в xml-файле;
 *                        он может содержать JPA-анотации;
 *                        такой класс не является Entity;
 *                        и ему не обязательно выполнять все требования установленные для Entity;
 *                        класс не может использоваться в операциях EntityManager или Query;
 *
 * >>> Базовая JPA-аннотация (JPA-маппинг сущности и ее свойств) - указывает на простейший тип маппинга данных (на колонку/таблицы/базы данных, можно указать fetch-стратегию доступа к полю и является ли поле обязательным);
 * >>> Converter JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяют указать класс для конвертации Базового аттрибута Entity в другой тип;
 * >>> Access JPA-аннотация (JPA-маппинг сущности и ее свойств) - имеет два типа доступа к атрибутам (свойствам) Entity:
 *     1. через аннотацию на поле класса;
 *     2. через аннотацию на метод класса;
 * >>> EntityListeners JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет задать класс Listener который содержит сallback-методы обработки событий (PrePersist|PostPersist||PreRemove|PostRemove||PreUpdate|PostUpdate||PostLoad); 
 * >>> Cacheable JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет включить или выключить использование кеша второго уровня;
 * >>> Стратегии наследования мапинга в JPA:
 *     1. Single-table - одна таблица на всю иерархию наследования = Минусом является что в общей таблице будут пустые поля для всех других классов-потомков;
 *     2. Joined - (объединяющая стратегия) каждый entity сохраняется в свою таблицу, а все унаследованные колонки записываются в таблицы класса-предка (устанавливается связь relationships между этими таблицами) = Минусом являются потери производительности от объединения таблиц;
 *     3. Table per concrete - каждый отдельный класс-наследник имеет свою таблицу = Минусом является плохая поддержка полиморфизма;
 * >>> Типы связей (relationship) между Entity:
 *     1. OneToOne
 *     2. OneToMany
 *     3. ManyToOne
 *     4. ManyToMany
 *     Каждую из которых можно разделить ещё на два вида:
 *     -  Bidirectional (ссылка на связь устанавливается только с обоих сторон) 
 *     -  Unidirectional (ссылка на связь устанавливается только с одной стороны)
 * >>> Fetch стратегии загрузки объектов:
 *     - В JPA описаны два типа fetch стратегии загрузки объектов:
 *       1. LAZY (ленивая загрузка - данные поля будут загруженны только во время первого доступа к этому полю)
 *       2. EAGER (данные поля будут загруженны немедленно)
 *     - Fetch стратегии загрузки объектов в Hibernate
 *       1. Join fetching (получает объекты одним SELECTом, используя OUTER JOIN)
 *       2. Select fetching (использует уточняющий SELECT чтобы получить объекты)
 *       3. Subselect fetching (использует уточняющий SELECT чтобы получить объекты + будут загружены родительские объекты-наследники)
 *       4. Batch fetching (оптимизированный SELECT)
 * >>> EntityGraph - изменяет настройки fetch-стратегии (загрузки объектов) атрибутов Entity для отдельных запросов
 * 
 * >>>> Типы кэша используются в Hibernate:
 *      1. кэш сесии (кэш первого уровня) - только для данного конкретного пользователя.
 *      2. кэш фабрики сессий (кэш второго уровня) - является общим для всего приложения и используется чтобы уменьшить трафик с базой данных.
 *         Чтобы указать кэш второго уровня нужно определить hibernate.cache.provider_class в hibernate.cfg.xml
 *         Реализации кэша второго второго уровня:
 *         - EHCache (поддерживает read-only и read/write кэширование, но не поддерживает кластеризацию)
 *         - OSCache (поддерживает read-only и read/write кэширование, поддерживает кластеризацию)
 *         - SwarmCache (поддерживает read-only и нестрогое read/write кэширование)
 *         - JBoss TreeCach (предоставляет полноценный кэш транзакции)
 * >>>> Типы стратегий кэша:
 *      - Read-only (используется когда данные вычитываются но никогда не обновляется)
 *      - Read/write (используется когда данные должны обновляться)
 *      - Нестрогий read/write (гарантирует что две транзакции не модифицируют одни и те же данные синхронно)
 *      - Transactional (полноценное кэширование транзакций...доступно только в JTA окружении)
 * >>>> Методы очистки сессии:
 *      - flush (синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии)
 *      - evict (нужен для удаления объекта из кеша cессии)
 *      - contains (определяет находится ли объект в кеше сессии или нет)
 *      - clear (очищает весь кеш)
 * >>>> Варианты настройки кэша второго уровня в JPA из persistence.xml:
 *      1. ALL (все Entity могут кэшироваться в кеше второго уровня) 
 *      2. NONE (кеширование отключено для всех Entity) 
 *      3. ENABLE_SELECTIVE (кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true), для всех остальных кэширование отключено)
 *      4. DISABLE_SELECTIVE (кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false))
 *      5. UNSPECIFIED (кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию для кэширования)
 * 
 * >>>>> Hibernate поддерживает управляемые и не управляемые транзакции (он взаимодействует с БД через JDBC-соединение)
 * >>>>> SQL - (диалект) это язык запросов с простыми-стандартными командами которые поддкрживаюся всеми типами баз данных;
 * >>>>> JPQL (Java Persistence query language) - (диалект) это язык HQL-запросов такой же как SQL только (вместо имен и колонок таблиц базы данных) он использует имена классов Entity и их атрибуты;
 * >>>>> В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но так же объекты всех его классов-потомков.
 *       Чтобы исключить такое поведение используется функция TYPE в where условии.
 * >>>>> Criteria - это тоже язык запросов аналогичным JPQL, только запросы основаны на методах и объектах;
 * >>>>> преимущства от использования Hibernate:
 *       1. прозрачный механизм связи БД и POJO;
 *       2. HQL;
 *       3. автоматическая генерация primary key;
 *       4. кэш: Session Leve, Query и Second level;
 *       5. производительность: ленивая инициализация, выборка outer join;
 *       
 *       
 *       
 *       
 *** (Spring / @SessionAttributes("myobject")) http://vmustafayev4en.blogspot.com/2012/10/power-of-springs-modelattribute-and.html
 ***                     (Spring / Controller) https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task/src/test/java/com/miratex
 ***                 (Spring / @Transactional) https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task
 **                                            https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000001901539095
 *   https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2370000006060497655/r=%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D0%BA&pos=91&reqid=3487605fa0b4b225ee74c7fa6abe398d&filter=folder:,attaches:no,dates=-
 */

public class JPAExample {
	
	@SuppressWarnings("unchecked")
	public static void main(String... argv) {
		EntityManagerFactory factory = null;
		EntityManager        manager = null;
		
		try {
			factory = Persistence.createEntityManagerFactory("TestStore");
			manager = factory.createEntityManager();
			
			//Add several blogPosts entities to database using EntityManager
			manager.getTransaction().begin();
			manager.persist( new BlogPost("BlogPost 1", "This is first blog post", new Date(), true) );
			manager.persist( new BlogPost("Just another blog post", "This is second blog post", new Date(), true) );
			manager.getTransaction().commit();
			
			//Read all entities from database using EntityManager
			Query query = manager.createQuery("SELECT obj FROM BlogPost AS obj ORDER BY obj.date DESC");
			List<BlogPost> list = (List<BlogPost>) query.getResultList();
			
			for (Iterator iterator = list.iterator(); iterator.hasNext();) {
				BlogPost blogPost = (BlogPost) iterator.next();
				System.out.println(blogPost.getId() + " :: '" + blogPost.getTitle() + "' >> " + blogPost.getBody() + " [" + blogPost.getDate() + "]");
			}
			
			
		} finally {
			if (manager!=null) manager.close();
			if (factory!=null) factory.close();
		}
		
		
	}

}
