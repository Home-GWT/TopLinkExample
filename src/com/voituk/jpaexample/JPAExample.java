package com.voituk.jpaexample;

import java.util.Date;
import java.util.Iterator;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

/**
 * (java persistence api что это)
 * http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 * http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 * (jpa persistence стратегии)
 * http://habrahabr.ru/post/265061/
 * http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 * http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 * http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * http://habrahabr.ru/post/172239/
 * http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * 
 * *******************************************************
 * JDBC-интерфейс являеться стандартным способом при работе с базами данных.
 * Но JDBC-интерфейс имеет имеет недостатки:
 * - реализация клиентской стороны включая и драйвер коннекта к базе ложиться исключительно на плечи разработчика...
 * - драйвер коннекта к базе сильно зависит от Операционной Сиситемы и железа на стороне клиента где его используют...
 * - разработчику который использует этот JDBC-интерфейс приходиться самостоятельно реализовывать JAVA-класы (сущности) которые моделируют таблицы базы данных...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * JPA (Java Persistence API) - являеться ORM-фреймворком который решает эти задачи и упрощает жизнь разработчику:
 * - кросс-платфоорменная (независимая) реализация драйвера коннекта к базе!
 * - реализует работу с таблицами базы данных на уровне классов!
 * - и собстввенно все транзакции к базе выполняются под управлением исключительно ORM-фреймворка (так что разработчик НЕпариться над порядком построения транзакции и контролирование дедлоков)!
 * 
 * *******************************************************
 * Итак, есть база данных и есть клиенты...
 * Клиенты делают чтение и запись данных в базу...
 * Для выполнения (клиентских) транзакций к базе клиенту нужно подключиться к этой базе...
 * При подключение клиента к базе создается сессия в рамках которой выполняются все транзакций...
 * Каждая транзакция на изменение должна иметь подтверждение (как факт правильности инструкций и начало выполнения)...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Итак:
 * - существует много клиентских коннектов к базе - сессий;
 * - существует активная инструкция (которая выполняется в текущий момент)...;
 * - и существуют другие инструкции (НЕактивные)...;
 * Дело в том что в базе данные являются общими, то есть, одновременно эти данные могут изменять много клиентов И при этом повредить данные которые еще НЕзафиксированы...
 * Чтобы избежать случаев когда несколько клиентов пытаются одновременно изменить одни и те-же данные И избежать ошибок - для этого и существуют "уровни изоляции":
 * 1. READ UNCOMMITTED  ( изоляция уровня чтения неподтвержденного )
 *    Указывает что другие транзакции могут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 2. READ COMMTITED  ( изоляция уровня чтения подтвержденного )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 3. REPEATABLE READ  ( изоляция уровня повторяемого чтения )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 * SNAPSHOT
 * 4. SERIALIZABLE  ( упорядоченная изоляция )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 *    И другие транзакции НЕмогут вставлять новые строки-данные со значениями ключа которые входят в диапазон ключей ДЛЯ считываемых инструкциями этой-текущей транзакции до ее завершения.
 *    
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *                                                             (Spring Roo in Under Nine Minutes) https://www.youtube.com/watch?v=K78vL72XDqw
 * (По следам Spring Pet Clinic. Maven/ Spring Context/ Spring Test/ Spring ORM/ Spring Data JPA) http://habrahabr.ru/post/232381/
 * 
 *                   (java persistence api что это)
 *           (Introduction to Java Persistence API) http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 *             (Java Persistence API (JPA): Основы) http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * (SET TRANSACTION ISOLATION LEVEL (Transact-SQL)) https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 *                                                            (jpa persistence стратегии)
 **                 (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *       (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 *   (Начало работы с Java Persistence API) http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * 
 *                               (уровни изоляции как работают)
 ** (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 *                          (MySQL: уровни изоляции транзакций) http://habrahabr.ru/post/135217/
 *                (Уровни изоляции транзакций в SQL. Шпаргалка) http://www.arbinada.com/main/ru/node/619
 * 
 *                                  (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * (PowerMock (+Mockito): новый взгляд на unit-тестирование) http://habrahabr.ru/post/172239/
 *                      (Тестирование GWT с помощью Mockito) http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *                                             (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php | https://books.google.com.ua/books?id=yqW0D1U0Q9IC&pg=PA343&lpg=PA343&dq=грязное+чтение+неповторяемое+чтение+чтение+фантомов&source=bl&ots=Hc3e5tQSpr&sig=c49sASAVEk_sh5xH1o2DoEaXusc&hl=ru&sa=X&ved=0ahUKEwj3nKO3r8zJAhXBFiwKHeh8CH8Q6AEIMjAE#v=onepage&q=грязное чтение неповторяемое чтение чтение фантомов&f=false
 *                                  (Уровни изоляции транзакции) https://www.youtube.com/watch?v=ovG4QXNpu7U
 *                (Уровень изоляции READ COMMITED SNAPSHOT в 1С) https://www.youtube.com/watch?v=D8PHwf5RHB4
 * (Уровень изоляции неповторяемое чтение, Неповторяемое чтение) https://www.youtube.com/watch?v=TWTDFWxSRYs
 *                          (Уровень изоляции Serializable в 1С) https://www.youtube.com/watch?v=TAGNnvCghlY
 *   (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 * 
 * Транзакции - защищают данные с которыми работает пользователь чтобы другой пользователь их неиспортил.
 * Но существуют ситуации когда данные ненужно защищать (потому-что они неявляются важными)...
 * Поэтому одни данные являются очень важными и их нужно защищать, а другие данные неявляются важными или имеют среднюю важность их можно выборочно защищать.
 * Уровень изоляции транзакции - это набор правил которые определяют насколько сильно нужно защищать данные (в транзакциях).
 * 
 * > В ходе выполнения транзакции результат выполнения может быть либо применен-зафиксирован либо отменен-откат.
 * Так вот, пока транзакция еще небыла зафиксирована - нет никакой гарантии что может быть откат - и все незафиксированные данные пропадут - это "Грязное чтение"
 * 
 * > В ходе выполнения транзакции читаем каждую строку (если их много) с какой-то последовательностью.
 * И пока читаем эту строку - она заблокирована от изменения, но как только закончили ее читать и перешли к другой, тогда другая транзакция может изменить освободившуюся строку.
 * То есть нет никаких гарантий что между чтением строки и фиксированием транзакции эта строка не будет снова изменена - это "Неповторяемое чтение".
 * 
 * > В ходе выполнения транзакции также читаем строки (если их много) с какой-то последовательностью...
 * И в этот момент другая транзакция вставляет новые строки между читаемыми строками уже после их прочтения (здесь нет блокировок на еще отсутствующие строки).
 * То есть нет никаких гарантий что после прочтения всех строк до момента фиксированием транзакции не будет добавления новых строк - это "Чтение фантомов".
 * 
 * 1. READ UNCOMMITTED (нет защиты, существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 * 2. READ COMMTITED   (решается проблема "Грязного чтения")
 * 3. REPEATABLE READ  (решается проблема "Неповторяемого чтения")
 * 4. SERIALIZABLE     (решается проблема "Чтения фантомов")
 * 
 * (Базы данных. Вводный курс) http://citforum.ck.ua/database/advanced_intro/80.shtml
 * (Уровни изоляции транзакций в SQL) http://www.osp.ru/pcworld/2009/07/9708191/
 * (Блокировки и уровни изоляции транзакций InnoDB в MySQL) http://habrahabr.ru/post/238513/
 * http://shurshun.ru/tranzaktsii-blokirovki-urovni-izoliovannosti-tranzaktsiy-v-mysql/
 * http://kek.ksu.ru/EOS/BD/SQL_transaction.html
 * http://www.sql.ru/forum/699859/izuchau-urovni-izolyacii-tranzakciy-v-sql-neponyatnoe-povedenie-read-committed
 * http://habrahabr.ru/post/135217/
 * http://www.arbinada.com/main/ru/node/619
 * (уровни изоляции транзакций hibernate)
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *  (На пути к правильным SQL транзакциям (Часть 1)) http://habrahabr.ru/company/infopulse/blog/261097/
 ** (На пути к правильным SQL транзакциям (Часть 2)) http://habrahabr.ru/company/infopulse/blog/261101/
 *  (Типичные взаимные блокировки в MS SQL и способы борьбы с ними) http://habrahabr.ru/company/mindbox/blog/261661/
 *  (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php  |  http://datasql.ru/basesql/16.htm
 *  
 * Сервер накладывает блокировки на данные (при использовании небольших транзакций) для повышение эффективности работы.
 * Блокировка - (временное) ограничение на выполнение некоторых операций обработки данных (может быть наложена на отдельную строку так и на всю базу).
 *  
 * Сессия - это канал связи между клиентом и сервером для обмена данными...
 * Транзакция - это защита данных, чтобы другая транзакция их неиспортила...
 * Уровни изоляции - это набор правил (блокировок) которые определяют степень защиты данных...
 * ...........................................................................................
 * Есть физические данные и абстрактные данные:
 * > физические данные - имеют (описываются) модульную структуру, которая позволяет исключить дублирование и сжимать информацию тем самым повысить скорость-производительность доступа к данным (лежат на медленном дисковом устройстве)
 * > абстрактные данные - являются частицей физических данных, эта временная рабочая/незафиксированая информация (может быть отменена)
 * Только после подстверждения данные попадают из абстрактной области в физическую область.
 *  
 * Блокировки в SQL - это такой себе строительный элемент который позволяет моделировать разные способы защиты.
 * Условно блокировки можно разделить на 2-а вида: на запись; на чтение;
 * Дело в том элемент-блокировки прежде всего являеться логической компонентой которая описывается так:
 * - Разновидности блокировок по типу блокируемых ресурсов: на строку, на ключ, на страницу, на таблицу, на базу;
 * - Разновидности блокировок по режиму блокирования: Совмещаемая (Shared) блокировка - на чтение; Монопольная (Exclusive) блокировка - на запись; Блокировка обновления (Update)- на чтение/запись; Блокировки с намерением (Intent) - расширяет ресурс при множествености..; ...
 * 
 * (Используя блокировки - уровни изоляции моделируют разные ступени способов защиты на стороне сервера; - А с помощью уровней изоляции разработчик выбирает оптимальный вариант между скоростью и качеством выполнения запросов;)
 * Уровни изоляции транзакции влияют на скорость работы системы поэтому важно правильно выбирать уровень изоляции в зависимости от задачи которую выполняет транзакция:
 * (чем выше уровень изоляции, тем меньше степень одновременного конкурентного доступа но гарантирует полную изоляцию параллельных конкурентных транзакций)
 * 1. READ UNCOMMITTED (нет защиты)
 *                     его следует применять только в тех случаях, когда точность данных не представляет важности или когда данные редко подвергаются изменениям
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 *                     если необходимо отображать real time статистику по постоянно изменяющимся данным для построение отчетов
 *                     
 * 2. READ COMMTITED   (выполнят проверку только на наличие монопольной блокировки для данной строки)
 *                     (здесь блокировки отменяются сразу-же после обработки данных (обычно все блокировки отменяются в конце транзакции))
 *                     улучшает параллельный/одновременный доступ к данным
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Грязного чтения")
 *                     (по умолчанию) обычно достаточно использовать для чтения данных, без какой либо транзакции
 *                     
 * 3. REPEATABLE READ  (устанавливает разделяемые блокировки на все считываемые данные и удерживает эти блокировки до тех пор, пока транзакция не будет подтверждена или отменена)
 *                     В этом случае многократное выполнение запроса внутри транзакции всегда будет возвращать один и тот же результат.
 *                     Недостатком этого уровня изоляции является дальнейшее ухудшение одновременного доступа поскольку период времени в течение которого другие транзакции не могут обновлять те же самые данные значительно дольше чем в случае уровня READ COMMITTED.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Неповторяемого чтения")
 *                     если вставка новых записей в параллельных транзакциях никак не может повлиять на результат текущей транзакции
 *                     части которых могут быть изменены во время чтения
 *                     
 * 4. SERIALIZABLE     (устанавливает блокировку на всю id-область данных, считываемых соответствующей транзакцией, поэтому предотвращает вставку новых строк другой транзакцией до тех пор пока первая транзакция не будет подтверждена или отменена)
 *                     Уровень изоляции SERIALIZABLE реализуется, используя метод блокировки диапазона ключа (устанавливает блокировку на всю область данных считываемых соответствующей транзакцией).
 *                     Не допускает возникновения всех трех проблем параллельного одновременного конкурентного доступа, перечисленных ранее.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Чтения фантомов")
 *                     если транзакция изменяет данные в БД и при этом проверяет, чтобы эти данные не противоречили уже существующим записям в БД
 *                     части которых могут быть изменены во время чтения
 *                     
 * (На пути к правильным SQL транзакциям (Часть 2)) https://habrahabr.ru/company/infopulse/blog/261101/
 * (Блокировка (СУБД)) https://ru.wikipedia.org/wiki/Блокировка_(СУБД)
 * (Блокировки и уровни изоляции транзакций InnoDB в MySQL) https://habrahabr.ru/post/238513/
 * (блокировки при записи в регистр сведений) http://www.forum.mista.ru/topic.php?id=659368
 * (InnoDB: транзакции и блокировки) http://articles.javatalks.ru/articles/28
 * (Блокировки в SQL Server) http://www.sql.ru/articles/mssql/2004/04110303advancedlocking.shtml
 * (Режимы блокировки) https://technet.microsoft.com/ru-ru/library/ms175519%28v=sql.105%29.aspx
 * (Справочное руководство по MySQL) http://www.mysql.ru/docs/man/InnoDB_Deadlock_detection.html
 * (Что такое deadlock и как с ним бороться) http://www.sql.ru/docs/interbase/deadlocks.shtml
 * (Взаимная блокировка) https://ru.wikipedia.org/wiki/Взаимная_блокировка
 * (Типичные взаимные блокировки в MS SQL и способы борьбы с ними) https://habrahabr.ru/company/mindbox/blog/261661/
 * --------------------------------------------------------------------------------------------------------------------------------------------------------------
 * + 'коллективная блокировка' (Shared) - блокировка в режиме чтения позволяет транзакции: читать строку. Используются для операций считывания (SELECT);
 *                                      - позволяет другим транзакциям читать строку и ставить такую-же Shared-блокировку;
 *                                      - запрещает изменять строку или ставить eXclusive-блокировку;
 * + 'исключительная блокировка' (eXclusive) - блокировка уровня записи позволяет транзакции: читать, обновлять, удалять строку. Используется для операций изменения данных (INSERT, UPDATE, DELETE);
 *                                           - позволяет блокировать строку: на чтение и на запись;
 *                                           - запрещает другим транзакциям блокировать строку;
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * + 'коллективная блокировка' (Shared) - разрешает паралельно установливать другие Shared-блокировки на теже строки в рамках транзакции (до момента завершения транзакции);
 *                                      - блокировки снимаются по мере чтения данных и они могут быть сняты даже до момента завершения транзакции не дожидаясь считывания оставшихся 9 строк;
 *                                        то есть, такая блокировка действует внутри транзации (поэтому она и называется совмещенной)
 * + 'исключительная блокировка' (eXclusive) - данная блокировка не может быть установлена, если существуют какие-либо другие блокировки на ресурсе, т.е. команда будет ждать снятия всех существующих блокировок;
 *                                           - будучи успешно установленной, данная блокировка не позволяет установку новых блокировок любых типов т.е. все запросы, пытающиеся получить доступ к заблокированному ресурсу, будут ожидать снятия монопольной блокировки;
 *                                             то есть, такая блокировка действует в отдельной транзакции до конца ее завершения (поэтому она и является уникальной)
 * + 'блокировка обновления' (Update) - она ведёт себя как что-то среднее между Shared-блокировкой и Exclusive-блокировкой;
 *                                    - логически его можно разделить на два этапа:
 *                                      #1 поиск данных для обновления - на этапе лучше будет установить Shared-блокировку (это позволит другим транзакциям избежать ожидания при чтении данных);
 *                                      #2 обновление найденных данных - и только если данные найдены то преобразовать её в Exclusive-блокировкe и произвести изменение (это сделает невозможным даже чтение данных из других транзакций и используется для операций INSERT, UPDATE, DELETE);
 * + 'блокировка с намерением' (Intent) - (оптимистическая блокировка) служит для оптимизации работы алгоритма установки блокировок;
 *                                      - в основе лежит простая идея:
 *                                        Перед установкой низкоуровневых блокировок (строках, страницах) сначала устанавливаем Intent-блокировку на более высоком уровне (таблицы);
 *                                        Если такой блокировки нет, то мы можем избежать проверки наличия уже существующих блокировок (строках, страницах) и сразу их установить;
 *                                        А если она есть то можно более оптимально принять решение о возможности установки определённой блокировки низкого уровня;
 *                                        - 'гранулярная блокировка' действует на всю таблицу или всю страницу и все строки
 * --------------------------------------------------------------------------------------------------------------------------------------------------------------
 * + Разновидности блокировок по типу блокируемых ресурсов
 *   - Конкретная строка в таблице
 *   - Ключ (один или несколько ключей в индексе)
 *   - Страница
 *   - Экстент
 *   - Таблица и все относящиеся к ней данные (индексы, ключи, данные)
 *   - База (блокируется, когда меняется схема базы)
 * 
 * + Совместимость блокировок (некоторые типы блокировки могут быть успешно установлены на одном и том же ресурсе):
 *   - Блокировка с намерением совмещаемого доступа (IS)
 *   - Блокировка с намерением монопольного доступа (IX)
 *   - Совмещаемая блокировка с намерением монопольного доступа (SIX)
 *   - Блокировка с намерением обновления (IU)
 *   - Совмещаемая блокировка с намерением обновления (SIU)
 *   - Блокировка обновления с намерением монопольного доступа (UIX)
 * ==============================================================================================================================================================
 * + По ресурсам блокировки бывают на: ключ, индекс, строку, страницу, таблицу
 * + 'Shared-блокировка' блокирует одну строку
 * + 'eXclusive-блокировка' блокирует диапазон строк в рамках которых выполняется одна транзакция
 * + 'Update-блокировка' блокирует одну строку. Только в одном случае (при поиске) она является 'коллективной', а в другом случае (при добавлении, обновлении, удалении) является 'исключительной'
 * + 'Intent-блокировка' предварительно метит страницу, таблицу для установки-объединения оптимальной блокировки при проверке... (такая блокировка является - 'гранулярной блокировкой' действует на всю таблицу или всю страницу и все строки)
 * 
 * + 'non-wait блокировка' - такая блокировка может возникнуть между двумя транзакциями в Shared-режиме: когда транзакция-1 блокирует общую строку на время работы с ней, а транзакция-2 ждет ее освобождения
 *                         - такие блокировки являются кратко-временными И всегда отходчивы
 * + 'wait блокировка' (взаимо-блокировка или мертвые блокировки) - такая блокировка может возникнуть между двумя транзакциями с разными режимами: когда транзакция-1 в Shared-режиме блокирует общую строку на время работы с ней, а транзакция-2 в eXclusive-режиме ждет ее освобождения
 *                                                                - при этом такие режимы блокировок несовместимы между собой и каждая ожидает завершения другой транзакции на зайнятом общем ресурсе = такое состояние ожидания будет бесконечно длиться...
 * = Если две транзакции сначала сделают разделяемую блокировку а затем начать писать, то ничего не выйдет, будут блокировать друг друга.
 *                                                                
 * Движок InnoDB (в MySQL) использует блокировки на уровне строк.
 * В зависимости от уровня изоляции транзакции могут блокироваться как строки (попавшие в результирующую выборку), так и все строки (что были просмотрены при поиске).
 * 
 * В 'REPEATABLE READ' блокирующий запрос без использования индекса потребует перебора всей таблицы и блокировки всех записей, посему правильный выбор индексов напрямую влияет на скорость работы блокировок.
 * 
 * Уровни изоляции транзакций InnoDB (можно изменить запросом SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL):
 * + READ UNCOMMITED:
 *   - Все запросы SELECT читают в неблокирующей манере.
 *     Изменения незавершенной транзакции могут быть прочитаны в других транзакциях, а изменения эти могут быть еще и впоследствии откачены.
 *   - В остальном все так же, как и при READ COMMITED.
 * + READ COMMITED
 *   - Согласованное чтение ничего не блокирует, но каждый раз происходит из свежего снэпшота.
 *   - Блокирующее чтение (SELECT... FOR UPDATE/LOCK IN SHARE MODE), UPDATE и DELETE блокирует только искомые индексные записи.
 *     Таким образом возможна вставка параллельным потоком записей в промежутки между индексами.
 *     Промежутки блокируются только при проверках внешних ключей и дублирующихся ключей.
 *     Также блокировки просканированных строк не удовлетворяющих WHERE снимаются сразу же после обработки WHERE.
 * + REPEATABLE READ (значение по умолчанию):
 *   - Согласованное чтение (SELECT) ничего не блокирует, читает строки из снэпшота, который создается при первом чтении в транзакции. Одинаковые запросы всегда вернут одинаковый результат;
 *   - Для блокирующего чтения (SELECT... FOR UPDATE/LOCK IN SHARE MODE), UPDATE и DELETE блокировка будет зависит от типа условия. Если условие уникально (WHERE id=42), то блокируется только найденная индексная запись (record lock). Если условие с диапазоном (WHERE id > 42), то блокируются весь диапазон (gap lock или next-key lock).
 * + SERIALIZABLE:
 *   - Аналогичен REPEATABLE READ за исключением одного момента:
 *       если autocommit выключен (а при явном старте транзакции он выключен) - все простые запросы SELECT неявно превращаются в SELECT... LOCK IN SHARE MODE
 *       если autocommit включен - каждый SELECT идет в отдельной транзакции (SELECT... LOCK IN SHARE MODE)
 * 
 * SELECT... LOCK IN SHARE MODE - блокирует считываемые строки на запись:
 *                              - Другие сессии могут читать но ждут окончания транзакции для изменения затронутых строк;
 *                                Если же в момент такого SELECT строка уже изменена другой транзакцией но еще не зафиксирована то запрос ждет окончания транзакции и затем читает свежие данные;
 * SELECT... FOR UPDATE - блокирует считываемые строки на чтение:
 *                      - Точно такую же блокировку ставит обычный UPDATE, когда считывает данные для обновления;
 * 
 * SELECT @Var = Y FROM MyTable WITH (UPDLOCK) WHERE X=2
 * = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
 * + Движок 'InnoDB' по умолчанию ставит блокировки на строки.
 * 
 * + Уровни изоляции допускают правила ('READ UNCOMMITED') которые полностью исключают любые режимы блокировок внутри транзакции.
 *   - Но, по умолчанию MySQL использует уровень изоляции 'REPEATABLE READ', в котором применяется 'Shared-блокировка'.
 * 
 * + Все режимы блокировок прменяются только на файловые ресурсы базы данных (ключи, индексы, строки, страницы, таблицы).
 * + 'Транзакция' это есть защита данных от изменения другими транзакциями при выполнении sql-запросов
 *   - при выполнении sql-запросов внутри транзакции результирующие данные выягиваются из файлов (которые хранятся на диске) и загружаются в 'снепшот' (так называемая кеш-память).
 *     И все это время пока работает sql-запрос до его применения внутри транзакции, данные снепшот-а и данные что из файлов (которые хранятся на диске) будут разными.
 * + Режими блокировок синхронизируют работу снепшот-а и файлов (которые хранятся на диске) на время до окончания выполнения транзакции (пока работает sql-запрос)
 *   - в такой способ другие транзакции, кторые паралельно будут работать, ожидают когда первая транзакция освободит рессурс(ы).
 * 
 * 1. READ UNCOMMITED
 *    - в результате отсутствия любых блокировок это приводит к наличии всех проблем: 'Грязного чтения', 'Неповторимого чтения', 'Чтеня фантомов'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      обычно применяется там где НЕважно точность информации (например: получение статистики)
 * 2. READ COMMITED
 *    - в результате применения Update-блокировки это приводит к решению проблемы: 'Грязного чтения'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      улучшает параллельный/одновременный доступ к данным
 * 3. REPEATABLE READ
 *    - в результате применения Shared-блокировки это приводит к решению проблемы: 'Неповторимого чтения'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      применяется когда нужно вставлять новые данные при параллельном/одновременном доступе к данным
 * 4. SERIALIZABLE
 *    - в результате применения eXclusive-блокировки это приводит к решению проблемы: 'Чтеня фантомов'
 *      ------------------------------------------------------------------------------------------------------------------------------------------
 *      применяется когда необходимо очень часто обновлять данные при параллельном/одновременном доступе
 * 
 * + При доступе к общему ресурсу, когда одновременно выполняются sql-запросы в паралельных транзакциях, есть вероятность блокировок - когда одна транзакция ожидает освобождения ресурсов от другой транзакции.
 *   - при разных уровнях изолации, где участвуют eXclusive-блокировка и Shared-блокировка, такая проблема может привести к мертвым взаимо-блокировкам (wait-блокировка) = 'дедлок';
 *     (когда внутри одной транзакции уже началось считывание данных И в этот момент другая транзакция блокирует этот ресурс для первой транзакции а потом сама-же ожидает окончание выполнения этой первой транзакции)
 *   - при равных уровнях изоляции тоже могут возникать блокировки (non-wait блокировка) НО такие блокировки "отходчивые" они уже НЕприводят к 'дедлоку'
 * --------------------------------------------------------------------------------------------------------------------------------------------------------------
 * --------------------------------------------------------------------------------------------------------------------------------------------------------------
 *                     
 * Существуют 3-и команды, которые используются для управления транзакциями:
 * 1) COMMIT – для сохранения изменений;
 * 2) ROLLBACK – для отмены изменений;
 * 3) SAVEPOINT – для установки особых точек возврата.
 * 
 * Транзакция определяется на уровне соединения с базой данных и при закрытии соединения автоматически закрывается (когда транзакция начинается все команды считаются телом одной транзакции пока не будет достигнут ее конец).
 * SQL Server предлагает множество средств управления поведением транзакций. Пользователи должны указывать только начало и конец транзакции используя SQL-команды или API:
 * 1) "автоматическое" (по умолчанию SQL Server работает в режиме автоматического начала транзакций, когда каждая команда рассматривается как отдельная транзакция - если команда выполнена успешно то фиксируются... инначе - откат);
 * 2) "подразумеваемое" (когда пользователю понадобится создать транзакцию, включающую несколько команд, он должен явно указать транзакцию);
 * 3) "явное" (SQL Server не может находиться в режиме исключительно явного определения транзакций, этот режим работает поверх двух других);
 * 
 * (Руководство по блокировке и управлению версиями строк транзакций SQL Server) https://msdn.microsoft.com/ru-ru/library/jj856598%28v=sql.120%29.aspx  |  https://msdn.microsoft.com/ru-ru/library/ms187373.aspx
 * (Транзакции и блокировки) http://reis.rtf.urfu.ru/portal/prime/po/sql/70.htm
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Различают 2-а вида блокировки:
 * 1) блокировка записи – транзакция блокирует строки так что запрос другой транзакции к этим строкам будет отменен;
 * 2) блокировка чтения – транзакция блокирует строки так что запрос со стороны другой транзакции на блокировку записи этих строк будет отвергнут, а на блокировку чтения – принят;
 * 
 * блокировки на логических уровнях...
 * 
 * уровни блокировок (по типу блокируемых ресурсов):
 * + на уровне строк;
 * - на уровне ключа;
 * - на уровне страницы; 
 * + на уровне таблиц;
 * + на уровне базы;
 * 
 * уровень 0 – запрещение "загрязнения" данных.
 * уровень 1 – запрещение "грязного" чтения.
 * уровень 2 – запрещение неповторяемого чтения.
 * уровень 3 – запрещение фантомов.
 * 
 * Блокировки в среде MS SQL Server, Управление блокировками
 * 
 * https://www.youtube.com/watch?v=daA8jAMyo_c
 * http://sqlcom.ru/
 * https://www.youtube.com/watch?v=iGsbXLgZMlo
 * https://www.youtube.com/watch?v=I6WKOVYdgWU
 * 
 * *******************************************************
 *                 (Урок 2. Понятия базы данных, отношения, ключи и др) http://www.realcoding.net/article/view/127
 * (14 вопросов об индексах в SQL Server, которые вы стеснялись задать) http://habrahabr.ru/post/247373/
 * 
 * (InnoDB | Внешние ключи и транзакции ** FOREIGN KEY >> REFERENCES: CASCADE|RESTRICT) http://asmodeus.com.ua/library/soft/mysql/innodbpk.html
 * (Створення або змінення таблиць та індексів за допомогою запиту на визначення даних) https://support.office.com/uk-ua/article/Створення-або-змінення-таблиць-та-індексів-за-допомогою-запиту-на-визначення-даних-d935e129-229b-48d8-9f2d-1d4ee87f418e
 *                                                          (Использование Constraints) http://www.askdev.ru/question/5235/Использование-Constraints/
 *                     (CONSTRAINT используется для создания и удаления ограничений...) https://support.office.com/ru-ru/article/Предложение-CONSTRAINT-e5241593-139a-4eb7-ad30-61026873191e
 * (19. ПОДДЕРЖКА ЦЕЛОСТНОСТИ ВАШИХ ДАННЫХ) http://www.sql.ru/docs/sql/u_sql/ch19.shtml
 *                                          http://www.flenov.info/books.php?contentid=5
 *                                          http://www.flenov.info/books.php?contentid=6
 * 
 * Строки в таблицах базы являются объемными (объектами) элементами и несут в себе информацию и многих полях... поэтому операция сравнения-перебор-поиск нужного элемента-строки являеться очень (трудозатратным) трудоемким действием.
 * Если говорить о маленьких таблицах, такое (трудозатратное) трудоемкое действие сравнения-перебор-поиск нужного элемента-строки, мало влияет на производительность...
 * Но в больших таблицах это несет уже большие потери по производительности.
 * Поэтому, чтобы более эффективно решить проблему с перебором-поиском для нужного элемента-строки, используют ссылку на строку - этот элемент представляет 1-но поле с коротким значением (что позволяет повысить производительность при выполнении действия по перебору-навигации).
 * Итак, ссылка на строку, являеться - "ключем".
 * + достоинства: ускоряет поиск строки в больших траблицах;
 * - недостатки: требуется выполнять дополнительные запросы чтобы (вытянуть) получить информацию из строки;
 * 
 * В таблицах средней величины использование "ключей" - являеться эфективным способом...
 * Но в очень больших таблицах даже работа с "ключами" являеться (относительно) трудозатратной по времени. И чтобы ускорить этот процесс - есть механизм сортировки...
 * Механизм сортировки создает специальную структуру (иерархического сбалансированного дерева), которая перебирает (не все элементы в подряд) только выборочные элементы по специальному алгоритму (что позволяет сокращать количество операций для достижения такого-же результата).
 * Итак, механизм сортировки ключей/полей, является - "индексом" (то есть, "индекс" это (не альтернатива) являеться дополнением "ключа" для повышения эффективности в очень больших таблицах).
 * – "кластеризованный индекс" ..... применяется для разных полезных полей (столбцов с данными), то есть НЕтребует дополнительных запросов в строку чтобы вытащить инфорацию И может быть отсортирован в заданом порядке... НО на всю таблицу он может быть только один;
 * – "некластеризованный индекс" ... применяется только для ключей (ссылки-указатели на строки), то есть требует выполнения дополнительных запросов в строку чтобы вытащить инфорацию И НЕможет быть отсортирован... Но в каждой таблице может быть много проиндексированных таких полей;
 *  
 * Ключи и индексы в базе
 * -----------------------
 * В таблице есть колонки которые содержат полезные данные (необходимые для работы). И таких строк (с полезными данными) в таблице очень много...
 * Поэтому существует проблема поиска данных - при условии что таких колонок много...процесс поиска становиться сложным и трудоемким.
 * Ключ - это колонка с (легковестными) простыми-уникальными значениями, которые являются как-бы ссылками на строки содержащие полезные объемные-данные
 * Недостатки "ключа" в том что требуется еще делать дополнительные запросы чтобы вытащить полезные данные со строки...
 * 
 * 1) Потенциальный ключ (KEY) ....... это любое 1-но поле (колонка) только с полезными данными, которое обладает уникальностью (неповторимостью)
 * 2) Уникальный ключ (UNIQUE) ....... это комбинация полей (колонок) только с полезными данными, которое обладают уникальностью (неповторимостью)
 * 3) Первичный ключ (PRIMARY KEY) ... (может быть только один на всю таблицу) добавляеться новое (специальное) поле-счетчик
 * 4) Альтернативные ключи ........... это все остальные поля (колонки), которые НЕявляются потенциальными, уникальными и первичными ключами
 * 5) Внешние ключи (FOREIGN KEY) .... это поля (колонки) которые ссылаются на первичные ключи в других таблицах (в такой способ связывая между собой таблицы в единую целостность)
 *                                     (поле с полезными данными которое ссылается на другое поле с первичным ключем называется - внешней ссылкой; а первичный ключ на который ссылаются называется - родительским ключом;)
 * На "внешний ключ" накладываются специальные ограничения (CONSTRAINT):
 * – CASCADE .... означает распространение действий родительской таблицы на дочерние, то есть, если значение ключа в родительской таблице изменится то оно автоматически (без специальных запросов) изменится и в дочерних таблицах
 * – RESTRICT ... означает что нельзя редактировать значение ключа или удалять строки из родительской таблицы пока есть соответвующие внешние ключи в дочерних таблицах (это правило является правилом по умолчанию).
 * Необходимо помнить, что единая сущность таблиц, которые связываются внешними ключами, имеют специальные ограничения на изменение таблиц (так чтобы сохранить эту самую единую сущность). 
 * 
 * Индекс - это улучшение "ключа" (но это не замена "ключа").
 * Идея в том что "индекс" применяет сортировку для организации более эффективного поиска-доступа к полезным данным.
 * А также "индекс" может непосредственно работать с полезными данными (то есть, отпадает необходимость в делать дополнительные запросы...) - это еще более ускоряет работу поиска-доступа
 * 
 * Работу "индекса" можно описать так:
 * – Интексирование столбца начинается с корневого узла "Root"; двигаясь дальше, на промежуточном уровне, определяется страница с более детальной информацийе "Intermediate"; И уже на самом нижнем уровне выясняеться нужный индекс (листья индекса) "Leaf";
 * Итак, индексы бывают:
 * 1) Кластеризованный индекс ..... это поля (столбцы) которые содержат полезные (реальные) данные-значения в строках - а еще такие проиндексированные поля (столбцы) называются - "кучей";
 * 2) Некластеризованный индекс ... это только 1-но поле (столбец) который является ссылкой-указателем (ключом) на строку;
 * 3) Составной индекс ............ может содержать несколько полей (столбцов - до 16 столбцов их общая длина ограничена 900 байтами);
 * 4) Уникальный индекс ........... это только 1-но поле (столбец) который содержит уникальные-неповторимые полезные (реальные) данные-значения в строках;
 * 5) Покрывающий индекс .......... позволяет запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к строкам самой таблицы;
 * Необходимо помнить что индексирвоание изменяет первоначальную структуру таблицы, поэтому добавление индексов в таблицу сопровождаеться 'ALTER'
 * 
 * (Стратегии работы с транзакциями: Распространенные ошибки) https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000002287754030 >> http://www.ibm.com/developerworks/ru/library/j-ts1/
 * (...) https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao.java
 * (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 *                          http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-map.html
 *                          http://info.javarush.ru/translation/2014/02/11/9-главных-вопросов-о-Map-в-Java.html
 *                          http://evilcoderr.blogspot.com/2013/01/hash-table-c.html
 *                          http://www.cyberguru.ru/dotnet/net-framework/dotnet-structures-analysis2-page7.html
 * (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *       (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html 
 * 
 * (какие бывают CONSTRAINT)
 * http://www.sql.ru/docs/mssql/tsql_ref/
 * https://msdn.microsoft.com/ru-ru/library/bb964742%28v=sql.120%29.aspx
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *                               (Стратегии работы с транзакциями: Распространенные ошибки) http://www.ibm.com/developerworks/ru/library/j-ts1/
 * (Стратегии работы с транзакциями: Oбзор моделей транзакций и стратегий их использования) http://www.ibm.com/developerworks/ru/library/j-ts2/
 *                                                               (Транзакционные стратегии) http://www.k-press.ru/cs/2009/3/ts/ts.asp
 *                                                               
 *                                                     (Alex Tretyakov Blog ** Основы JPA) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
 *                              (Alex Tretyakov Blog ** JPA-маппинг сущности и ее свойств) http://alextretyakov.blogspot.com/2013/06/jpa-mapping-suschnosti-i-ee-svojstv.html
 *             (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помо                       
 *щью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *                   (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Table-per-concrete-class стратегии) http://alextretyakov.blogspot.com/2014/04/jpa-table-per-concrete-class-strategija.html
 * 
 ** (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * 
 * Транзакционные стратегии:
 * 1) стратегия слоя API ................ подходящую для бизнес-приложений с грубо гранулированным слоем API;
 * 2) стратегия Client Orchestration .... пригодную для бизнес-приложений с более тонко гранулированным слоем API;
 * 3) стратегия высокого параллелизма ... подходящую для приложений с большим числом одновременно работающих пользователей;
 * Например, стандартная структура:
 * - 'DAO' (на самом низком слое) происходит физическая связь/реализация транзакций между JAVA и базой
 * - 'Сервис' здесь реализована бизнес-логика приложения, она полностью описывает механизм транзакций и способы их откатов (методы для взаимодействия с физическим слоем И более тонко описывает транзакции)
 * - 'Контролер' (слой верхнего уровня, привязывается к пользовательским сессиям) на этом уровне программный код распаралеливается на пользовательские сессии и несет нагрузку на обработку паралельных запросов...
 * 
 * Модели транзакций:
 * – локальная модель ....... управление транзакциями осуществляется менеджером базы данных (а не приложением, то есть, управляем только соединениями но не транзакциями).
 *                            Эту модель можно использовать для доступа через JDBC к данным и хранимым процедурам.
 *                            Нельзя использовать локальную модель для выполнения изменений в базе данных через ОРМ (например: Hibernate, TopLink, Java Persistence API (JPA))
 *                           
 * – программная модель ..... ответственность за управление транзакциями возлагается на разработчика (мы сами управляем транзакциями которые оказываются изолированными от низкоуровневых соединений с базой данных);
 *                            Разработчик должен самостоятельно получить ссылку на транзакцию от менеджера транзакций, начать ее, затем подтвердить ее, а если возникло исключение – то откатить ее.
 *                          
 * – декларативная модель ... при работе с этой моделью контейнер самостоятельно начинает, подтверждает и откатывает транзакции.
 *                            Задачей разработчика является только описание поведения транзакций.
 *                            (это наиболее часто применяемая модель, которая известная как модель транзакций управляемых контейнером "Container Managed Transactions" (CMT)); 
 * 
 * (JPA-маппинг сущности и ее свойств)
 *  JPA-маппинг отношений типов: "один-к-одному","один-ко-многим","многие-к-одному","многие-ко-многим";
 *  JPA-маппинг иерархии классов с помощью: "Single-table стратегии","Joined стратегии","Table-per-concrete-class стратегии";
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *                               https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao.java
 *                               https://github.com/JobTest/vitrinaPredmainTask/blob/jpa_demo/src/main/java/com/jpa/dao/Person2Dao2.java
 *                               https://github.com/JobTest/AddressBookDB/blob/master/src/main/java/com/dao/UserRolesDao.java
 * (Java Persistence/Persisting) https://en.wikibooks.org/wiki/Java_Persistence/Persisting
 *   (Java Persistence/Criteria) https://en.wikibooks.org/wiki/Java_Persistence/Criteria
 *                       
 *
 * Для JPA:
 * *****************
 *    find (SELECT)
 * persist (INSERT)
 *  remove (DELETE)
 *   merge (UPDATE)
 * 
 * Для Hibernate
 * *****************
 * get|list|load (SELECT)
 *          save (INSERT)
 *        delete (DELETE)
 *        update (UPDATE)
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 **                            (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 *  (Время против памяти на примере хеш-таблиц на Java) http://habrahabr.ru/post/230283/
 *  (Под капотом Redis: Хеш таблица (часть 1)) http://habrahabr.ru/post/271205/
 * 
 * 1) Хеширование с цепочками (ОТКРЫТОЕ ХЕШИРОВАНИЕ)
 *    > это список обвернутый в массив.
 *    > Хеш-функция конвертирует хеш-код ключа в индекс ячейки для массива.
 *    > Если эта ячейка массива уже зайнята тогда:
 *      >> при поиске элемента в списке по 'equals' сравниваем ключи и для найденного элемента возвращаем состояние объекта
 *      >> при добавлении элемента, просто добавляем в конец списка
 *    ?????????????????????????????????????????????????????????
 *    Хеш-таблица - это ассоциативный массив - представление одних данных в другое.
 *    (Объекты) ключи - это элементы которыми внутри себя оперирует хеш-таблица. Данные - это есть ассоциативное представление ключей.
 *    (Объекты) ключи - должны быть легковестными (НЕбольшими) и пригодными для операций... Данные - обычно являются громоздкими (большими) объектами которыми трудно оперировать.
 *    Поэтому контракт 'hashCode|equals' применяется для (объекта) ключа (все операции внутри хеш-таблицы выполняются по ключу).
 *    В хеш-таблице существует ХЕШ-ФУНКЦИЯ которая вычисляет индекс-массива для хранения объекта по КЛЮЧУ. Проблема в том что относительная точность индекса-массива сравнительно с хеш-кодом очень низкая - именно это является основной причиной коллизии!
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    то есть, согласно контракту (Если объекты равны - тогда их хеш-коды гарантировано равны; Если хеш-коды разные - тогда объекты гарантировано разные; Но бывают случаи когда разные объекты имеют равные хеш-коды - это колизия;)
 *    поэтому в 'бекет-е' (список на который ссылаеться ячейка массива) лежат разные объекты-ключи с равными хеш-кодами. Теперь с помощью 'equals' проверяем на равенство (разных) объектов-ключей - таким способом находим элемент...
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    При поиске элемента: хеш-функция через хеш-код находит индекс-массива, а 'equals' находит/возвращает равный элемент.
 *    При добавлении элемента: хеш-функция через хеш-код определяет индекс-массива, а 'equals' находит равный элемент И заменяет его данные ИЛИ в случае отсутствия добавляет его в конец списка.
 *    Если изменить параметры определения хеш-кода (объекта) ключа - тогда потеряем ссылку на элемент внутри хеш-таблицы.
 *    А если НЕпереопределить 'equals' (объекта) ключа - тогда хеширование работать будет... но в случае коллизии элемент будет утерян (НЕзащищен).
 *    ?????????????????????????????????????????????????????????
 *    LinkedList - доступ к элементам выполняентся по итератору.
 *                 Достоинства: добавление нового элемента в конец списка выполняется за короткое-константное время
 *                              эффективно расходуется размер списка (размер не нужно иннициализировать)
 *                 Недостатки: на Чтение-Поиск элементов тратиться большое время...
 *                             добавление нового элемента в середину список выполняется за большое время (потому-что тратиться много времени на перемещение...)
 *    ArrayList - доступ к элементам выполняентся по индексу.
 *                Достоинства: на Чтение-Поиск элементов тратиться короткое-константное время
 *                             добавление нового элемента в конец списка выполняется за короткое-константное время (с тем расчетом что размер списка ранее был проиннициализирован)
 *                Недостатки: для улучшения эффективности нужно иннициализировать размер списка.
 *                            может занимать лишний размер рессурса (если ранее непредвиден размер списка) что является неэффективным к применению
 *                            в случае превышения исходного размера списка тратиться большое время на реорганизацию списка...
 *                            добавление нового элемента в середину списка выполняется за большое время
 *    Отличие HashMap <> HashTable:
 *    - 'Hashtable' является синхронизированным
 *    - 'HashMap' может иметь 'NULL'-ключи
 *    ThreeMap - можна использовать сортировку.
 *               Для этого нужно переопределить интерфейс Comparable|Comparator (через метод compareTo)
 *    
 *     join fetch c.hobbies h where c.id = :id
 *    HashMap
 *            Достоинства: хранит ключи в хеш-таблице, из-за чего имеет наиболее высокую производительность
 *                         может содержать как null-ключи, так и null-значения
 *            Недостатки: не гарантирует порядок элементов
 *            
 *    TreeMap - сортироваться элементы будут либо в зависимости от реализации интерфейса Comparable, либо используя объект Comparator
 *            Достоинства: хранит ключи в отсортированном порядке
 *                         может содержать null-значения
 *            Недостатки: работает медленнее чем HashMap
 *                        не может содержать null-ключи
 *    
 *    LinkedHashMap
 *                  Достоинства: отличается от HashMap тем, что хранит ключи в порядке их вставки в Map
 *                               немного медленнее HashMap
 *                               может содержать как null-ключи, так и null-значения
 *    
 *    (различия между HashMap и HashSet) HashMap — коллекция пар ключ/значение, тогда как HashSet это упорядоченная коллекция уникальных элементов.
 *    (SortedSet это интерфейс, реализуемый классом TreeSet)
 *    Класс TreeSet создаёт коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию.
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    ArrayList - быстрый поиск И быстрая вставка в конец списка (за константное время)
 *    LinkedList - быстрая вставка в конец списка (за константное время) И экономит размер списка
 *    HashMap - быстрый поиск И быстрая вставка в список И может работать с NULL
 *    HashTable - синхронизированный
 *    TreeMap - сортирует кастомерский-порядок элементов (через Comparable)
 *    TreeSet - создаёт коллекцию которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию.
 *    LinkedHashMap - сортирует элементы по истории их добавления И работает быстрее за 'TreeMap'
 *    
 *    - Map
 *    - Collection >> List + Set
 *    --------------------------
 *    -- List: массив обвернутый в список (по индексу), двухсвязанный список (по итератору)
 *    -- Set: (множество) исключает дублирование элементов
 *    -- Map: пара ключ-значение
 *    --------------------------
 *       --- ArrayList: быстрый поиск элемента за константное время + добавление элемента в конец списка за константное время
 *       --- LinkedList: добавление элемента в конец списка за константное время + динамическое выделение размера на память
 *       ---
 * ПОСЛЕ --- HashMap: быстрый поиск элемента за константное время + добавление элемента в любое место за константное время + умеет работать с NULL-значениями
 * ПОСЛЕ --- HashTable: (это предок HashMap) синхронизированный
 * ПОСЛЕ --- TreeMap: упорядоченное хранение элементов + поддерживает сортировку через пере-определение Comparable|Comparator
 *       ---
 *  ДО   --- HashSet: (механизм распределения списка элементов аналогично HashMap) в качестве ключа выступает сам элемент (значение) + недопускает дублирующих элементов
 *  ДО   --- TreeSet: основан на красно-черном дереве + упорядоченное хранение элементов по возрастанию
 *  ДО   --- LinkedHashMap: (упорядоченое хранение элементов) сортирует элементы по истории их добавления
 *       ---
 *         > (List - простой список) ........................ (допускаются дублирующие элементы, это НЕассоциативный массив)
 *         > (Set  - множество, НЕдопускает дублирование) ... НЕдопускаются дублирование элементов (сортирует ДО того как список-коллекция будет сформирован)
 *         > (Map  - пара ключ-значение) .................... ассоциативный массив (позволяет переопределять механизм сортировки ПОСЛЕ того как список-коллекция будет сформирован)
 *        >> (Hash - хеширование, НЕсохраняет порядок) ...... механизм сортировки основан на хеш-функции (открытое хеширование, закрытое хеширование)
 *        >> (Tree - сбалансированное дерево) ............... механизм сортировки основан на черно-красном дереве (правильно сбалансированное дерево, неправильно сбалансированное дерево)
 *    --------------------------
 *    > Рефлексивность: сравнение объекта самого-себя - гарантированно возвращает равенство (при условии что объекты неNULL)
 *    > Симметричность: если два объкекты 'A' и 'B' равны - тогда при обратном условии сравнения (либо 'A==B' либо 'B==A') гарантируется их равенство
 *    > Транзитивность: три объекта 'A','B','C'; при двух условиях равенства объектов если 'A==B' и 'B==C' - тогда гарантируется равенство между 'A==C'
 *    ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *    (Время против памяти на примере хеш-таблиц на Java) http://habrahabr.ru/post/230283/
 *    (Коллекции (Collections) в Java. Map) http://www.seostella.com/ru/article/2012/08/09/kollekcii-collections-v-java-map.html
 *    (9 главных вопросов о Map в Java) http://info.javarush.ru/translation/2014/02/11/9-главных-вопросов-о-Map-в-Java.html
 **   (Множества: Set, HashSet, LinkedHashSet, TreeSet) http://developer.alexanderklimov.ru/android/java/set.php
 **   (Часто задаваемые на собеседованиях вопросы по классам коллекциям в Java (Часть 2)) http://info.javarush.ru/translation/2013/10/08/Часто-задаваемые-на-собеседованиях-вопросы-по-классам-коллекциям-в-Java-Часть-2-.html
 **   (Волшебный мир Java ** Рефлексивность,Транзитивность,Симметричность) http://echuprina.blogspot.com/2012/01/equals-hashcode.html
 **   (Волшебный мир Java) http://echuprina.blogspot.com/
 **   (Паршин Павел ** Вопросы и ответы на собеседовании по теме Java Collection Framework ** Часть-1,Часть-2,Часть-3) http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1
 **                                                                                                                    http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-2
 **                                                                                                                    http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-3
 **   (Про Java ** HashSet и HashMap) http://javaoutsource.blogspot.com/2012/10/hashset-hashmap.html
 **   (Java собеседование. Коллекции) http://habrahabr.ru/post/162017/
 *    ?????????????????????????????????????????????????????????
 * 2) Хеширование с открытой адресацией (ЗАКРЫТОЕ ХЕШИРОВАНИЕ)
 *    > здесь имеем просто массив.
 *    > Хеш-функция конвертирует хеш-код ключа в индекс ячейки для массива.
 *    > Если эта ячейка массива уже зайнята тогда:
 *      >> делаем <линейный> поиск следующей (первой попавшийся) пустой ячейки и вставляем туда элемент...
 *         (в этом случае возникает проблема когда в какой-то элементы в массиве могут распределяться неравномерно - неэфективно заполняемое пространство ячеек...)
 *      >> для решения такой пролемы существует специальная <линейная> функция, которая ищет следующую ячейку (НЕпервую попавшеюся) с определенным шагом-пропуска...
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * (Что нам дает JPA) http://atamanenko.blogspot.com/2012/04/spring-data-jpa.html
 * Вообще Spring Data JPA пытается быть умным, поэтому реализация findBy{...} методов ищется следующим образом:
 * 1. Сначала смотрится аннотация @Query на объявлении метода, если она есть, то используется.
 * 2. Затем смотрится аннотация @NamedQuery с именем вида Entity.findMethodName, для вышеприведённого случая это будет User.findByLoginAndPassword.
 * 3. Если ничего не нашли. то по сигнатуре метода генерируется запрос.
 * У @Query следующие плюсы:
 * 1. Позволяет не засорять объявление доменной сущности.
 * 2. Сильно помогает, если у нас в запросе есть неявные джойны, потому что для таких запросов Spring Data JPA не умеет корректно генерировать запрос SELECT COUNT(*), который нужен в тех случаях, когда метод должен вернуть Page.
 * 
 * (spring технологии)
 *                                                        (...) http://javabegin.ru/products/spring/
 *                                                        (...) http://devcolibri.com/3732
 *                                                        (...) http://mai.pmoproject.ru/pages/viewpage.action?pageId=4424007
 * (Учимся готовить: Spring 3 MVC + Spring Security + Hibernat) http://habrahabr.ru/post/111102/
 * - Добавление класса сущности в модель домена.
 * - Слой доступа к данным.
 * - Сервис-слой.
 * - Добавление веб.
 * - Контроллер.
 * - Вид.
 * - Безопасность.
 * (Spring DATA, Spring REST, Spring MVC, Spring Security)
 * 
 * 
 * 
**  (Re: GWT MVP: pdf (еще) + Eclipse +++ (Фишай,Абсорс) + Spring Roo GWT & Spring Test/ Spring ORM/ Spring Data JPA +++) https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000002329443356
                                        (Евгений Беркунский ** Java Persistence API (JPA):Основы > Жизненный цикл Entity) http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
***                                        (Java для белок ** Вопросы на интервью по технологиям Java Spring и Hibernate) http://j4sq.blogspot.com/2012/01/java-spring-hibernate.html
***                                                 (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
**                                                                 (Alex Tretyakov Blog ** Основы JPA) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
**                                          (Alex Tretyakov Blog ** JPA-маппинг сущности и ее свойств) http://alextretyakov.blogspot.com/2013/06/jpa-mapping-suschnosti-i-ee-svojstv.html
**                                 (Alex Tretyakov Blog ** JPA-маппинг отношений типа "один-к-одному") http://alextretyakov.blogspot.com/2013/06/jpa-mapping-tipa-odin-k-odnomu.html
**           (Alex Tretyakov Blog ** JPA-маппинг отношений типов "один-ко-многим" и "многие-к-одному") http://alextretyakov.blogspot.com/2013/06/jpa-mapping-tipa-odin-ko-mnogim-i.html
**                              (Alex Tretyakov Blog ** JPA-маппинг отношений типа "многие-ко-многим") http://alextretyakov.blogspot.com/2013/07/jpa-mapping-tipa-mnogie-ko-mnogim.html
**                                              (Alex Tretyakov Blog ** Упорядочиваем коллекции в JPA) http://alextretyakov.blogspot.com/2013/07/uporyadochivaem-kollektsii-v-jpa.html
**                                            (Alex Tretyakov Blog ** JPA-маппинг перечисляемых типов) http://alextretyakov.blogspot.com/2013/07/mapping-perechislyaemyh-typov-v-jpa.html
**                                            (Alex Tretyakov Blog ** JPA-маппинг встроенных объектов) http://alextretyakov.blogspot.com/2013/08/jpa-mapping-vstroennyh-obyektov.html
**              (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
**                    (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
**  (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Table-per-concrete-class стратегии) http://alextretyakov.blogspot.com/2013/06/osnovy-jpa-i-hibernate.html
*   (JPA работа с базой данных) http://devcolibri.com/1658
*   (Hibernate cache) http://habrahabr.ru/post/135176/
**  (Пример настройки Database Connection Pool) http://articles.javatalks.ru/articles/8
*   (Hibernate 3: введение и написания Hello world приложения) http://www.quizful.net/post/Hibernate-3-introduction-and-writing-hello-world-application
*   (Hibernate Tutorial) https://javatalks.ru/topics/11004
*
 * ********************************************************** join fetch c.hobbies h where c.id = :id*****************************************
 * >     (Загрузка загрузка файла-конфигурации и настройка среды) объекты сессии могут находиться в трёх состояниях: Transient,Persistent,Detached
 * >>    (Entity, Embeddable, Mapped Superclass) четыре статуса жизненного цикла Entity: new,managed,detached,removed
 * >>>   (JPA-маппинг сущности и ее свойств) типы связей между Entity, fetch-стратегии загрузки объектов, стратегии наследования мапинга в JPA: Single-table, Joined, Table per concrete, Transactional
 * >>>>  (кэш сесии|первого уровня, кэш фабрики сессий|второго уровня, методы очистки сессии) типы стратегий кэша: Read-only, Read/write, Нестрогий read/write, Transactional
 * >>>>> (SQL|JPQL диалект, Criteria) язык HQL|SQL-запросов, полиморфизм
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * > ORM - механизм сохранения java-объектов в базу данных.
 * > JPA - это описание спецификации.
 * > JPA/JDO - Это две спецификации для сохранения java-объектов в базу данных.
 *             JPA позволяет работать с реляционными базами.
 *             JDO более общая спецификация позволяет работать с реляционными базами и noSQL базами.
 * > Hibernate - это одна из реализаций JPA.
 * > EntityManagerFactory - соответствует persistence который содержит настройки для соединения с базой данных.
 *                          Persistence описывается в файле persistence.xml который должен находиться в директории resources/META-INF.
 * > EntityManager - это интерфейс который описывает API для всех основных операций над Entity (persist|merge|remove|refresh||detach|lock). EntityManager создается с помощью объекта типа EntityManagerFactory.
 *                   обеспечить механизмы создания/чтения/удаления для объектов:
 *                   - Для JPA: find (SELECT)
 *                              persist (INSERT)
 *                              remove (DELETE)
 *                              merge (UPDATE)
 * > SessionFactory - позволяет создавать сессии согласно конфигурации 'hibernate.cfg.xml' (создается один раз и используется во всем приложении)
 *                    Configuration - загрузка файла-конфигурации 'hibernate.cfg.xml' и настройка среды Hibernate (для коннекта к базе)
 * > Session - (Hibernate сессия) это главный интерфейс взаимодействия Java-приложения и Hibernate.
 *             Задача сессии обеспечить механизмы создания/чтения/удаления для объектов:
 *             - Для Hibernate: get|list|load (SELECT)
 *                              save (INSERT)
 *                              delete (DELETE)
 *                              update (UPDATE)
 *   ?????????????????????????????????????????????????????????
 *   EntityManagerFactory - это фабрика сущностей которая загружает и настраивает соединение с базой в среде Java-приложения.
 *                          А еще 'EntityManagerFactory' создает объекты типа 'EntityManager'.
 *   EntityManager - это основной интерфейс который применяется для выполнения CRUD-операций к базе.
 *   ?????????????????????????????????????????????????????????
 * > Объекты сессии могут находиться в трёх состояниях:
 *   1. Transient - никогда не сохранялись и не ассоциированы ни с одной сессией (игнорируются);
 *   2. Persistent - ассоциированы с уникальной сессией (включаются);
 *   3. Detached - ранее сохраненные, но не ассоциированы с сессией.
 * 
 * >> Entity - это легковестный объект бизнес логики.
 * >> Четыре статуса жизненного цикла Entity:
 *    1. new (объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных);
 *    2. managed (объект создан, управляется JPA, имеет сгенерированные первичные ключи);
 *    3. detached (объект был создан, но больше не управляется JPA);
 *    4. removed (объект создан, управляется JPA, но будет удален после commit-a транзакции);
 * >> Требования к Entity:
 *    1. класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации;
 *    2. класс должен содержать public/protected конструктор без аргументов (он также может иметь конструкторы с аргументами);
 *    3. класс не может быть enum или интерфейсом;
 *    4. класс не может быть финальным классом;
 *    5. класс не может содержать финальные поля или методы, если они участвуют в маппинге;
 *    6. поля класса должны быть доступны только методам самого класса и не должны быть напрямую доступны другим классам (getter/setter методам или другим методам бизнес-логики в Entity классе);
 *    7. класс должен содержать первичный ключ;
 * >> типы данных допустимы в Entity:
 *    1. примитивные типы и их обертки Java;
 *    2. строки (String) И BigDecimal, BigInteger;
 *    3. любые сериализуемые типы Java (реализующие Serializable интерфейс);
 *    4. enums;
 *    5. entity классы; 
 *    6. embeddable классы
 *    7. коллекции;
 * >> Можно использовать типы данных входящих в первичный ключ Entity:Comparable
 *    1. примитивные типы и их обертки Java;
 *    2. строки;
 *    3. BigDecimal и BigInteger;
 *    4. java.util.Date и java.sql.Date;
 * >> Embeddable - встраиваемый класс который не используется сам по себе (только как часть Entity):
 *                 класс должен быть отмечен аннотацией Embeddable;
 *                 классы должны удовлетворять тем же правилам что Entity;
 * >> Mapped Superclass - это класс-родитель от которого наследуются Entity:
 *                        класс должен быть отмечен аннотацией MappedSuperclass или описан в xml-файле;
 *                        он может содержать JPA-анотации;
 *                        такой класс не является Entity;
 *                        и ему не обязательно выполнять все требования установленные для Entity;
 *                        класс не может использоваться в операциях EntityManager или Query;
 *
 * >>> Базовая JPA-аннотация (JPA-маппинг сущности и ее свойств) - указывает на простейший тип маппинга данных (на колонку/таблицы/базы данных, можно указать fetch-стратегию доступа к полю и является ли поле обязательным);
 * >>> Converter JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяют указать класс для конвертации Базового аттрибута Entity в другой тип;
 * >>> Access JPA-аннотация (JPA-маппинг сущности и ее свойств) - имеет два типа доступа к атрибутам (свойствам) Entity:
 *     1. через аннотацию на поле класса;
 *     2. через аннотацию на метод класса;
 * >>> EntityListeners JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет задать класс Listener который содержит сallback-методы обработки событий (PrePersist|PostPersist||PreRemove|PostRemove||PreUpdate|PostUpdate||PostLoad); 
 * >>> Cacheable JPA-аннотация (JPA-маппинг сущности и ее свойств) - позволяет включить или выключить использование кеша второго уровня;
 * >>> Стратегии наследования мапинга в JPA:
 *     1. Single-table - одна таблица на всю иерархию наследования = Минусом является что в общей таблице будут пустые поля для всех других классов-потомков;
 *     2. Joined - (объединяющая стратегия) каждый entity сохраняется в свою таблицу, а все унаследованные колонки записываются в таблицы класса-предка (устанавливается связь relationships между этими таблицами) = Минусом являются потери производительности от объединения таблиц;
 *     3. Table per concrete - каждый отдельный класс-наследник имеет свою таблицу = Минусом является плохая поддержка полиморфизма;
 * >>> Типы связей (relationship) между Entity:
 *     1. OneToOne
 *     2. OneToMany
 *     3. ManyToOne
 *     4. ManyToMany
 *     Каждую из которых можно разделить ещё на два вида:
 *     -  Bidirectional (ссылка на связь устанавливается только с обоих сторон) 
 *     -  Unidirectional (ссылка на связь устанавливается только с одной стороны)
 * >>> Fetch стратегии загрузки объектов:
 *     - Fetch-стратегии загрузки объектов в JPA:
 *       1. LAZY (ленивая загрузка - данные поля будут загруженны только во время первого доступа к этому полю)
 *       2. EAGER (данные поля будут загруженны немедленно)
 *     - Fetch-стратегии загрузки объектов в Hibernate
 *       1. Join fetching (получает объекты одним SELECT-ом используя OUTER JOIN)
 *       2. Select fetching (использует уточняющий SELECT чтобы получить объекты)
 *       3. Subselect fetching (использует уточняющий SELECT чтобы получить объекты + будут загружены родительские-объекты и объекты-наследники)
 *       4. Batch fetching (оптимизированный SELECT)
 * >>> EntityGraph - изменяет настройки fetch-стратегии (загрузки объектов) атрибутов Entity для отдельных запросов
 * 
 * >>>> Типы кэша используются в Hibernate:
 *      1. кэш сесии (кэш первого уровня) - только для данного конкретного пользователя.
 *      2. кэш фабрики сессий (кэш второго уровня) - является общим для всего приложения и используется чтобы уменьшить трафик с базой данных.
 *         Чтобы указать кэш второго уровня нужно определить hibernate.cache.provider_class в hibernate.cfg.xml
 *         Реализации кэша второго второго уровня:
 *         - EHCache (поддерживает read-only и read/write кэширование, но не поддерживает кластеризацию)
 *         - OSCache (поддерживает read-only и read/write кэширование, поддерживает кластеризацию)
 *         - SwarmCache (поддерживает read-only и нестрогое read/write кэширование)
 *         - JBoss TreeCach (предоставляет полноценный кэш транзакции)
 * >>>> Типы стратегий кэша:
 *      - Read-only (используется когда данные вычитываются но никогда не обновляется)
 *      - Read/write (используется когда данные должны обновляться)
 *      - Нестрогий read/write (гарантирует что две транзакции не модифицируют одни и те же данные синхронно)
 *      - Transactional (полноценное кэширование транзакций...доступно только в JTA окружении)
 * >>>> Методы очистки сессии:
 *      - flush (синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии)
 *      - evict (нужен для удаления объекта из кеша cессии)
 *      - contains (определяет находится ли объект в кеше сессии или нет)
 *      - clear (очищает весь кеш)
 * >>>> Варианты настройки кэша второго уровня в JPA из persistence.xml:
 *      1. ALL (все Entity могут кэшироваться в кеше второго уровня) 
 *      2. NONE (кеширование отключено для всех Entity) 
 *      3. ENABLE_SELECTIVE (кэширование работает только для тех Entity, у которых установлена аннотация Cacheable(true), для всех остальных кэширование отключено)
 *      4. DISABLE_SELECTIVE (кэширование работает для всех Entity, за исключением тех у которых установлена аннотация Cacheable(false))
 *      5. UNSPECIFIED (кеширование не определенно, каждый провайдер JPA использует свою значение по умолчанию для кэширования)
 * 
 * >>>>> Hibernate поддерживает управляемые и не управляемые транзакции (он взаимодействует с БД через JDBC-соединение)
 * >>>>> SQL - (диалект) это язык запросов с простыми-стандартными командами которые поддкрживаюся всеми типами баз данных;
 * >>>>> JPQL (Java Persistence query language) - (диалект) это язык HQL-запросов такой же как SQL только (вместо имен и колонок таблиц базы данных) он использует имена классов Entity и их атрибуты;
 * >>>>> В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но так же объекты всех его классов-потомков.
 *       Чтобы исключить такое поведение используется функция TYPE в where условии.
 *       ('JPQL' удобно использовать в именнованных запросах на уровне 'доменного слоя' в классе определения Entity-сущности - потому-что здесь ожидаются стандартные запросы к базе...)
 * >>>>> Criteria - это тоже язык запросов аналогичным JPQL, только запросы основаны на методах и объектах;
 *       ('Criteria' удобно использовать на уровне 'DAO-слоя' - потому-что здесь требуются специфические требования к запросу от 'сервисного слоя'...)
 * >>>>> преимущства от использования Hibernate:
 *       1. прозрачный механизм связи БД и POJO;
 *       2. HQL;
 *       3. автоматическая генерация primary key;
 *       4. кэш: Session Leve, Query и Second level;
 *       5. производительность: ленивая инициализация, выборка outer join;
 *       ?????????????????????????????????????????????????????????
 *       Представление (VIEW) - это объект базы данных являющийся результатом выполнения запроса к базе данных с помощью оператора SELECT
 *                              Преимущества использования представлений:
 *                              - дает возможность гибкой настройки прав доступа к данным за счет того, что права даются на представление (а не на таблицу);
 *                              - позволяет разделить логику хранения данных и программного обеспечения (можно менять структуру данных не затрагивая программный код, нужно лишь создать представления аналогичные таблицам);
 *                              - удобство в использовании за счет автоматического выполнения действий (доступ к определенной части строк, столбцов, получение данных из нескольких таблиц и их преобразование с помощью различных функций);
 *       Существует два алгоритма в MySQL при обращении к представлению:
 *       1. MERGE - включает определение представления в использующийся оператор SELECT (заменяет имя представления на имя таблицы);
 *       2. TEMPTABLE - заносит содержимое представления во временную таблицу, над которой затем выполняется оператор обращенный к представлению;
 *       
 *       Схема (Shema) - это есть структура данных (таблицы базы данных, базы данных) которая может быть наследоваться и на которую можно выдавать ролевые права для пользования клиентам
 *                       к примеру клиент создал какую-нибудь таблицу, добавл в нее данные и отдал ее в работу. А потом этот клиент уйдет и захочет удалить все свои базы над которыми он работал... - так можно потерять данные
 *       
 *       Mapping - сопоставление-проецирование Java-классов с таблицами Базы Данных, возможность по организации отношения между классами «один-ко-многим» и «многие-ко-многим»...
 *       Диалект SQL - поддерживает базовые запросы которые поддерживаются всеми типами баз:
 *                     CREATE,ALTER,DROP  GRANT  SELECT,INSERT,UPDATE,DELETE  COMMIT,ROLLBACK,SAVEPOINT
 *                     Преимущества: Независимость от конкретной СУБД, Наличие стандартов, Декларативность
 *                     Недостатки: Сложность, Отступления от стандартов
 *       Диалект JPQL - вместо декларативных команд испоьзуются классы, здесь используются именованные параметры, и полиморфизм
 *                      Query query = entitymanager.createQuery("SELECT DISTINCT a FROM Author a ORDER BY a.firstName, a.lastName")
 *                      Query query = entitymanager.createQuery("SELECT DISTINCT a FROM Author a INNER JOIN a.books b WHERE b.publisher.name = 'XYZ Press'")
 *                      Query query = entitymanager.createQuery("SELECT DISTINCT a FROM Author a WHERE LOWER(a.lastName) = :lastName")
 *       JPA Criteria API:
 *                         CriteriaQuery<Object> select = criteriaQuery.select(from);
 *                                               select.orderBy(criteriaBuilder.asc(from.get("ename")));
 *                         TypedQuery<Object> typedQuery = entitymanager.createQuery(select);
 *                         List<Object>       resultlist = typedQuery1.getResultList();
 *       
 *       шесть видов блокировок (lock) описаны в спецификации JPA:
 *       @org.hibernate.annotations.Entity(optimisticLock = OptimisticLockType.ALL)
 *       1. NONE - без блокировки
 *       2. OPTIMISTIC (или синоним READ, оставшийся от JPA 1) - оптимистическая блокировка,
 *       3. OPTIMISTIC_FORCE_INCREMENT (или синоним WRITE, оставшийся от JPA 1) - оптимистическая блокировка с принудительным увеличением поля версионности,
 *       4. PESSIMISTIC_READ - пессимистичная блокировка на чтение,
 *       5. PESSIMISTIC_WRITE - пессимистичная блокировка на запись (и чтение),
 *       6. PESSIMISTIC_FORCE_INCREMENT - пессимистичная блокировка на запись (и чтение) с принудительным увеличением поля версионности
 *
 *       Небазовые аннотации Entity:
 *       @NamedQueries({..,..,..,..})
 *       @NamedQuery
 *       @NamedQuery(name = "ContactEntity.findById", query = "select distinct c from ContactEntity c left join fetch c.contactTelDetails t left join fetch c.hobbies h where c.id = :id")
 *       
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       // (это простой запрос, но обычно в приложении простые запросы НЕиспользуются...)
 *       // В месте объявления таблицы создаем асоциативную ссылку и работаем уже только с этой ассоциативной ссылкой
 *       // Ограничиваем размер страницы запроса чтобы присутствовал лимит на случай тяжеловестных таблиц
 *       // Сортирируем список полей на стороне сервера для удобства представления
 *       >  SELECT tu.user_name,tu.user_fio FROM tomcat_users tu ORDER BY tu.user_fio ASC LIMIT 1, 30;
 *       // Список полей можно сортировать как по имени так и по номеру колонки
 *       >  SELECT tu.user_name,tu.user_fio FROM tomcat_users tu ORDER BY 2 ASC LIMIT 1, 30;
 *       
 *       // (обычно в приложении используются условия-поиска для выполнения запроса)
 *       // Критерий запроса - это условие-поиска по которому запрос должен выполняться
 *       >  SELECT tu.user_name,tu.user_fio FROM tomcat_users tu WHERE status='Inactive' ORDER BY 2 ASC LIMIT 1, 30;
 *       
 *       // (бывают нештатные случаи для выполнения специальных агрегатных запросов - которые выполняют подсчет... - такие запросы используются в ПОДзапросах)
 *       >  SELECT COUNT(tu.user_name) AS finds FROM tomcat_users tu WHERE status='Inactive';
 *       
 *       >  SELECT tur.user_name FROM tomcat_users_roles tur WHERE tur.role_name='admin';
 *       // (Простая задача: выполнить выборку из двух таблиц и по условию из одной таблицы отобразить информацию из другой таблицы)
 *       // Обычно информация сортируется по типам и расскладывается по разным таблицам...
 *       // А чтобы вытащить информацию нужно выполнить обратное - сгруппировать-объеденить таблицы
 *       // Проблема в том, что при объединении таблиц оператор 'SELECT' работает подобно вложенным циклам - умножает строки из таблиц...
 *       // Эта проблема решается с помощью оператора 'JOIN' - позволяет объеденить две и больше таблиц (например: есть школа и ученики, нужно вывести список всех учеников которые учаться в N-классе)
 *       >  SELECT tu.user_name,tu.user_fio FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
 *       >  SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users_group tug RIGHT OUTER JOIN tomcat_users tu ON tug.group_name=tu.group_name LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin' AND (tug.group_name='Biplane-Cashier' OR tug.group_name='Biplane-Admin');
 *       // Бывают случаи когда нужно выполнить специальные арифметические запросы (через агрегатные функции) - такие запросы обычно возращают результат одного поля И поэтому по типу результатов бывают несовместимыми
 *       // Поэтому делают ПОДзапросы для специальных агрегатных функций
 *       >  SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu WHERE tu.group_name IN (SELECT tr.role_name FROM tomcat_roles tr WHERE tr.role_name='admin');
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       
 *       (jpql примеры) https://ru.wikipedia.org/wiki/Java_Persistence_Query_Language
 *                      https://ru.wikipedia.org/wiki/Hibernate_(библиотека)
 *                      https://ru.wikipedia.org/wiki/SQL
 *                      https://ru.wikipedia.org/wiki/Java_Persistence_Query_Language
 *                      http://www.tutorialspoint.com/ru/jpa/jpa_jpql.htm
 *                      http://javatalks.ru/topics/37094
 *       (JPA - Критерии API) http://www.tutorialspoint.com/ru/jpa/jpa_criteria_api.htm
 *       (Представления (VIEW) в MySQL) http://habrahabr.ru/post/47031/
 *       (Вопрос 39. Какие шесть видов блокировок (lock) описаны в спецификации JPA) http://habrahabr.ru/post/265061/
 *       (Hibernate 3: введение и написания Hello world приложения) http://www.quizful.net/post/Hibernate-3-introduction-and-writing-hello-world-application
 *       (Вопрос 39. Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?) http://habrahabr.ru/post/265061/
 *       (jpa jpql примеры)
 **                         http://javastudy.ru/spring-data-jpa/jpa-insert-update-delete/
 **                         http://javastudy.ru/spring-data-jpa/jpa-hello-world-2/
 *                          http://forum.codenet.ru/q48397/Java+Persistence+Query+Language(JPQL)+%26%26+NetBeans+Database+Application
 **                         http://docs.oracle.com/javaee/5/tutorial/doc/bnbtl.html
 *       .........................................................
SELECT tu.* FROM tomcat_users tu;
SELECT tu.* FROM tomcat_users tu LIMIT 10;
SELECT tu.user_name,tu.user_fio FROM tomcat_users tu LIMIT 30;
SELECT tu.user_name,tu.user_fio FROM tomcat_users tu ORDER BY tu.user_fio ASC LIMIT 1, 30;
SELECT tu.user_name,tu.user_fio FROM tomcat_users tu ORDER BY 2 ASC LIMIT 1, 30;

SELECT tu.user_name,tu.user_fio FROM tomcat_users tu WHERE status='Inactive' ORDER BY 2 ASC LIMIT 1, 30;

SELECT COUNT(tu.user_name) AS finds FROM tomcat_users tu WHERE status='Inactive';

SELECT tur.* FROM tomcat_users_roles tur;
SELECT tur.user_name FROM tomcat_users_roles tur WHERE tur.role_name='admin';
SELECT tu.user_name,tu.user_fio FROM tomcat_users_roles tur, tomcat_users tu WHERE tur.role_name='admin';
SELECT tu.user_name,tu.user_fio FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users_group tug RIGHT OUTER JOIN tomcat_users tu ON tug.group_name=tu.group_name LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin' AND (tug.group_name='Biplane-Cashier' OR tug.group_name='Biplane-Admin');

SELECT COUNT(tur.user_name) AS contains FROM tomcat_users_roles tur WHERE tur.role_name='admin';
SELECT COUNT(tu.user_name) AS finds FROM tomcat_users tu;
SELECT COUNT(tu.user_name) AS users, COUNT(tur.user_name) AS roles FROM tomcat_users tu, tomcat_users_roles tur WHERE tur.role_name='admin';
SELECT tu.user_name AS users, tur.user_name AS roles FROM tomcat_users tu, tomcat_users_roles tur WHERE tur.role_name='admin';
SELECT tur.user_name AS roles FROM tomcat_users_roles tur;
SELECT tu.user_name AS users FROM tomcat_users tu;
SELECT tur.user_name AS roles, tu.user_name AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT tu.user_name AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT tur.user_name AS roles FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles, COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu;
SELECT COUNT(tur.user_name) AS roles, COUNT(tu.user_name) AS users FROM tomcat_users_roles tur, tomcat_users tu WHERE tur.role_name='admin';

SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu WHERE tu.group_name IN (SELECT tr.role_name FROM tomcat_roles tr WHERE tr.role_name='admin');
 *       . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users_group tug RIGHT OUTER JOIN tomcat_users tu ON tug.group_name=tu.group_name LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin' AND (tug.group_name='Biplane-Cashier' OR tug.group_name='Biplane-Admin');
SELECT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT DISTINCT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT OUTER JOIN tomcat_users_roles tur ON tu.user_name=tur.user_name WHERE tur.role_name='admin';
SELECT DISTINCT tu.user_name,tu.user_fio,tu.group_name FROM tomcat_users tu LEFT JOIN FETCH tu.user_fio fio LEFT JOIN FETCH tu.group_name g;
 *       .........................................................
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       JOIN - пересечение двух множеств для выполнения внутренней сортировки на стороне сервера
 *       'JOIN' позволяет находить-сравнивать одинаковые данные в полях И тем самым уже НЕнужно перебирать всю таблицу, а только связанные данные - это намного экономит количество перебираемых строк при поиске-выборке и затрачиваемое время...
 *       (JOINом может называться не только запрос объединяющий результаты из нескольких таблиц, но и запрос к одной таблице, например, SELECT по одной таблице — это тоже джоин)
 *       
 *       > В реляционной базе данных сущность является определенным типом. И хранит разные типы данных в отдельных таблицах.
 *         (а в нереляционных базах данных все данные лежат в одной таблице - логируются...)
 *         Поэтому клиентские запросы делают выборку паралельно из нескольких таблиц.
 *       > 'FROM' - делает выборку таблиц из файла на диске и загружает данные из нее в рабочую память-ОЗУ сервера базы данных
 *                  Данные из таблиц загружаются в цыкле!
 *                  Если таблиц много - тогда цыклов тоже много И такие цыклы являются вложенными И выполняются такие вложенные цыклы многократно раз. Например:
 *                  если три таблицы имеют по 10-строк тогда запрос вернет[10*10*10=] 1000-строк (вместо 30-строк)
 *       >> 'JOIN' - тоже делает выборку таблиц из файла на диске и загружает данные из нее в рабочую память-ОЗУ сервера базы данных
 *                   НО еще JOIN выполняет проверку и пропускает или сортирует дублирующие записи...
 *                   Такое дополнительное действие-проверки заставляет больше/дольше отрабатывать серверу базы данных
 *                   И в этом случае запрос вернет [10+-10+-10=] 10-30 строк
 *                   (такое действие называется - внутренней сортировкой)
 *       > 'SELECT' - каждая строка имеет набор полей (колонок в таблице), так вот, от количества полей которые выбираем из таблицы зависит длина строки (то етсь, чем больше полей выбираем тем длинее получаем строку).
 *                    И уже после этого выбираемые данные таблицы из файла сохраняются в рабочую память сервера базы данных (Memory) - она называется КЕШЕМ БАЗЫ ДАННЫХ
 *                    Конечно-же размер используемого кеша базы данных данных которые будут занимать выбираемые данные зависит от того сколько данных вытягиваем из файла-таблицы на диске...
 *                    (если неправильно построить и сделать выборку данных из файла-таблиц, тогда много лишних данных загрузяться в кеш и затруднит дальнейшую работу с этими данными)
 *       > 'WHERE' - следующим шагом является выборка актуальных данных для клиента. По внешнему условию WHERE выполняется поиск-выборка данных уже актуальных данных и кеша базы данных
 *                   И здесь (на втором этапе выборки) от размера кеша зависит количество выполняемых действий и затрачиваемое время
 *       > 'LIMIT' - оператор WHERE проходит по всей таблице из кеша и выполнить проверку актуальных-данных на выборку. Если поставить ограничение LIMIT тогда при условии найденных актуальных-данных работа оператора WHERE завершиться без полного сканирования данных в таблице
 *                   Тоесть, LIMIT исключает полное сканирование таблицы из кеша по внешнему условию и экономит затрачиваемое время на выполнение
 *       > 'GROUP BY' - Итак, нашли-получили результат актуальных-данных для клиента...теперь можно по результату этих данных (арифметическими) агрегатными функциями подсчитать количество каких-нибудь строк
 *                      Например: по полученным уже конечным результатам можно выполнить внешнюю сортировку данных из кеша базы данных 
 *       > 'HAVING' - (это аналог WHERE) внешее условие которое накладывается на агрегатные функции...
 *       > 'INDEX' - сортирует порядок строк по условным полям из таблицы...
 *                   Для INDEX-данных создается отдельная файл-таблица на диске. Также для выполнения (индексирования) сортировки порядка строк из таблиц требуется рабочая область памяти из кеша базы данных И затрачиваемое время для выполнения сортировки...
 *                   Каждый раз при изменении содержимого основной таблицы, автоматом происходит изменение и индексированной таблицы - на выполнение такой операции затрачивается больше времени И места в кеше и на диске...
 *                   НО для поиска-чтения данных тратим очень мало времени и ресурсов кеша (поскольку будут возращаться данные которые отсортированы по актуальности...) И увеличиваем производительность...
 *                   (при высоких затратах на INDEX, в таких случаях лучше применять некластерные индексирование - на ключи, потому-что они маленькие...)
 *       
 **      (Разработка приложений баз данных с использованием средств объектно-реляционного отображения) http://ivt.corp7.uniyar.ac.ru/moodle/pluginfile.php/65/mod_page/content/4/edu/ormbook.pdf
 **      (Объяснение SQL объединений JOIN: LEFT/RIGHT/INNER/OUTER) http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html
 **                                                                http://sqlfiddle.com/#!2/659f69/43
 **      (SQL и оператор JOIN) http://www.k-press.ru/cs/2009/3/join/join.asp
 **      (Ленивая инициализация коллекций в JPA) http://javacore.ru/topic/31-jpa.htm
 ***     (20 советов по оптимальному использованию MySQL) http://ruseller.com/lessons.php?id=692
 ***     (Конспект "Hibernate reference manual") http://j4sq.blogspot.com/2011/09/hibernate-reference-manual.html
 *       (Сортировка внутренней коллекции при LEFT JOIN FETCH) http://www.sql.ru/forum/820769/sortirovka-vnutrenney-kollekcii-pri-left-join-fetch
 **      (Десять распространенных ошибок SQL-программирования) http://www.k-press.ru/cs/2009/3/10sql/10sql.asp
 **                                                            http://habrahabr.ru/post/208264/
 *       (Выбор технологий для корпоративного приложения) http://2014.javapoint.ru/presentations/Krivopustov-apps.pdf
 **      (hibernate) http://www.liveinternet.ru/users/atum/post319823966/
 *       (Удаление любовно составленных join fetch улучшило среднюю производительность в 5 раз) http://www.sql.ru/forum/1049242/hibernate-neskolko-hql-dlya-zapolneniya-sushhnosti
 **      (Команда Left Join SQL - смысл использования) http://it-student.com.ua/verkhnee-menju/programmirovanie/left-join-sql-primer-select-zaprosa-s-objjasneniem.html
 *       (Jpa jpql запрос, сортировать..... (перейти)) http://www.programru.com/blog/McDO0ADMwIT5.html
 *       (How to use the LEFT JOIN vs. RIGHT OUTER JOIN in SQL) http://searchsqlserver.techtarget.com/feature/How-to-use-the-LEFT-vs-RIGHT-OUTER-JOIN-in-SQL
 *       http://www.objectdb.com/java/jpa/query/jpql/structure
 **      (20 советов по оптимальному использованию MySQL) http://ruseller.com/lessons.php?id=692
 **      (индексы в основном лежат на диске) http://www.sql.ru/forum/906263/hranenie-indeksov-innodb-na-diske-i-obem-ram
 ***     (Кучи и Индексы) http://www.sql.ru/articles/mssql/03013101indexes.shtml
 *       (MySQL и JOINы) http://habrahabr.ru/post/44807/
 *                       http://softtime.ru/forum/read.php?id_forum=3&id_theme=91694
 *       (Тайны оператора JOIN) http://www.slideshare.net/itweekend/join-22008919
 *       
 **      (Стратегии работы с транзакциями: Распространенные ошибки ** @Transactional в Spring Framework) http://www.ibm.com/developerworks/ru/library/j-ts1/
 *       (Собеседование Java вопросы) http://www.quizful.net/interview/java?page=2
 *                                    http://becomejavasenior.com/blog/2015/07/01/327-interview-questions-java-developer/
 *
 *       http://www.firststeps.ru/sql/oracle/r.php?54
 *       http://www.sql.ru/forum/913549/hibernate-n-1-best-practice
 *       http://www.sql.ru/forum/883435/eclipselink-fetching
 *       http://www.sql.ru/forum/787241/hibernate-hql-filtraciya-v-zavisimoy-kollekcii
 *       http://javatalks.ru/topics/28747
 *       (Лекция №6) http://www.lib.mdpu.org.ua/e-book/web/lec7.htm
 *       http://forundex.ru/sql/JOIN-s-boljshim-peresecheniem-65599
 *       http://axforum.info/forums/showthread.php?t=21270
 *       http://www.sql.ru/forum/996526/jpa-fetch-i-join-fetch
 *       http://devcolibri.com/2046
 *       (JPA SQL и выбор настройки (EclipseLink)) http://www.rootfront.com/article/4346811/2012-11-21/jpa-sql-i-vybor-nastrojki-_eclipselink_
 *       http://jexp.ru/index.php/Java/Hibernate/HQL_JOIN
 *       http://javatalks.ru/topics/29267
 *       https://msdn.microsoft.com/ru-ru/library/ms191183%28v=sql.120%29.aspx
 *       https://msdn.microsoft.com/ru-ru/library/ms188783%28v=sql.120%29.aspx
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       ?????????????????????????????????????????????????????????
 *       
 *       
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * (Вопрос из теста ООП в Java) http://www.quizful.net/question/J36mdSfp83wM
 * 
 * Исключения - это наследники класса 'Throwable':
 *              Error (системные ошибки при работе виртуальной Java-машины... - StackOverFlowError, OutOfMemoryError) - такие ошибкиm безсмысленно обрабатывать
 *              Exception >> 'Checked' (проверяемые исключения - FileNotFoundException, IOException, ModificationException, InterrupdetException) - такие исключения/ошибки НЕвозможно ранее предугадать в программе, поэтому их обизательно нужно обрабатывать
 *              RuntimeException >> 'Unchecked' (НЕпроверяемые исключения - NullPointerException, IndexOutOfBundlesException, ClassNotFoundException, IllegalTypeException, ClassCastException, ArithmeticException) - такие исключения/ошибки можно и нужно предугадать в программе (их нет нужды обрабатывать)
 * сигнатура throws... - помечаем в момент описания/определения метода который может выбросить исключение
 * try/catch/finally - используем в момент вызова метода (который может выбросить исключение) когда мы сами хотим обрабатывать это исключение
 * try/finally - используем в момент вызова метода (который может выбросить исключение) но НЕхотим сами обрабатывать это исключение
 * 
 * Обработка исключений выполняется уже в момент вызова И такие методы описываются внутри блока try/catch/finally. А к методам которые могут возбудить исключение применяется сигнатура этого исключенимя (throws...)
 * Следует помнить что catch-блоков может быть много и при первом-же нахождении catch-блока программа больше НЕделает проверок для других catch-блоков... При построении catch-блоков важно соблюдать иерархию порядка наследования объектов-исключений...
 * try/finally - если в точке вызова мы нехотим обрабатывать исключение, тогда можем просто передать его (при этом возбуждая внутри блока 'try' этот тип исключения >> new XXXException...)
 * 
 * try/catch/finally >>> иерархия вызова
 * * * * * * * * * * * * * * * * * *
 * Здесь если в блоке 'try' будет выброшено исключение - тогда программа прервется и передаст выполнение в блок 'catch' - где условия программы ГАРАНТИРОВАННО будет выполнена...
 * Если есть список блоков 'catch' - тогда выбран будет только один, первый подходящий catch из списка (больше ничего)
 * Дальше выполниться блок 'finally'
 * *********************************
 * Если внутри блока 'catch' бросить исключение - тогда блок 'finally' никогда невыпониться (программа просто прервется...)
 * Если блоки 'try/catch' будут вложены их будет много - тогда исключение перейдет к внешнему блоку 'catch'
 * *********************************
 * Если внутри блока 'finally' бросить исключение - тогда программа просто прервется...исключение перейдет к внешнему блоку 'catch'
 * *********************************
 * Множество 'catch' блоков - это такой себе список кейсов - из которого (по типу исключения) будет выбран только один (остальные НЕбуду выполнены)!
 * Дальше будет выполнен блок 'finally' (если тактой есть)
 *  
 *       
 *** (Spring / @SessionAttributes("myobject")) http://vmustafayev4en.blogspot.com/2012/10/power-of-springs-modelattribute-and.html
 ***                     (Spring / Controller) https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task/src/test/java/com/miratex
 ***                 (Spring / @Transactional) https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task
 **                                            https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2560000001901539095
 *   https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/2370000006060497655/r=%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D0%BA&pos=91&reqid=3487605fa0b4b225ee74c7fa6abe398d&filter=folder:,attaches:no,dates=-
 * ***************************************************************************************************************************************************************************
 * https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task/src/test/java/com/miratex
 * https://github.com/Home-SignUp/Jenkins-SignUp/blob/release-3.0/frontend/src/main/java/com/addrbook/frontend/controller/UserController.java
 * 
 ** https://www.genuitec.com/spring-frameworkrestcontroller-vs-controller/
 *  https://spring.io/guides/gs/rest-service/
 *  http://spring.io/blog/2009/03/08/rest-in-spring-3-mvc/
 ** https://netbeans.org/kb/docs/web/quickstart-webapps-spring_ru.html
 *  http://spring-projects.ru/guides/lessons/lesson-2/
 *  http://spring-projects.ru/guides/serving-web-content/
 *  http://spring-projects.ru/guides/
 *  https://spring.io/guides/gs/serving-web-content/
 ** https://www.ibm.com/developerworks/ru/library/wa-restful/
 ** http://javastudy.ru/spring-mvc/hello-world-example/
 *  http://crunchify.com/simplest-spring-mvc-hello-world-example-tutorial-spring-model-view-controller-tips/
 *  
 *
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * > Процесс - это участок программного кода который лежит в области ОЗУ
 * > Поток - это выделенное процессорное время на выполнение программного кода (процесса)
 * > Критическая секция - когда несколько потоков пытаются одновременно получить доступ к общему рессурсу
 * >> Захват монитора - когда один поток получает доступ к ресурсу, другие потоки в это время ожидают освобождения этого ресурса...
 * (Приоритеты - потоки имеют приоритеты...)
 * 
 * - 'sleep': удерживает монитор потока на некоторое время (НЕусыпает поток)
 * - как работает 'notify':
 *   -- объектный метод 'wait' вызывается внутри потока и усыпляет его (передает монитор другому потоку)
 *      объектный метод 'notify' вызывается уже другим потоком но на этом-же объекте и пропуждает спящий поток (то есть, доступен только при locks-синхронизации, относительно 1-объекта)
 *   -- 'notifyAll': может быть вызван на любом объекте и пропуждает аболютно все спящие потоки
 * 
 * jvm (неумеет работать с потоками) только посылает команды Операционной Системе, а Операционная Система управляет потоками
 * Существует 4-состояния потока:
 * 1. новый
 * 2. рабочий (действующий)
 * 3. удаленный
 * 4. пасивный
 * - NEW
 * - RUNNING
 * - BLOCKING
 * - WAITING
 * - TIME-WAITING
 * - TERMINATE
 * 
 * > jvn неумеет работать с потоками, с потоками работает операционая система согласно с порядком очереди потоков и их приоритетами
 *   с потоками умеет работать операционная система, jvn только передает команды операционной системе что нужно сделать с потоком...
 * > После того как оператор 'new' создаст новый объект потока - поток получает статус 'NEW'
 *   Вызов статического метода 'start()' переводит поток в статус 'RUNNING'
 *   Есть 2-способа завершения потока:
 *                                  1. после успешного выполнения поток получает статус 'TERMINATE'
 *                                  2. либо принудительно переводим поток в статус 'TERMINATE', через статический метод 'interrupted()' - перед изменением статуса проверяет свое состояние; объектный метод 'interrupt()' - принудительно изменяет статус потока на 'TERMINATE';
 *                                  После того как поток получил статус 'TERMINATE' - этот поток уже не может вернуться в состоние 'RUNNING'
 *   Но если поток блокируется (получает пасивный статус, засыпает) - такой поток еще можно вернуть в состояние 'RUNNING'
 * 
 * 'Runnable', 'Thread'
 * 
 * Статические методы:
 * - start
 * - interrupted ... возвращает значение флага прерывания того потока, из которого он был вызван и сбрасывает его (поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания)
 * - join (позволяющий одному потоку ждать завершения выполнения другого)
 * - sleep
 * - yield (заставляет процессор переключиться на обработку других потоков)
 * - currentThread
 * Другие методы:
 * - interrupt (установить флаг прерывания), isInterrupted (возвращает состояние флага прерывания и оставляет этот флаг нетронутым)
 * - isAlive
 * - wait, notify, notifyAll
 * - getName
 * - getId
 * 
 * - 'Locks': (аналог synchronized|wait|notify) альтернативные и более гибкие механизмы синхронизации потоков
 * - 'Atomics': (аналог volitale|get|set) гарантирует атомарные операции над примитивными и ссылочными типами
 * - 'Synchronized': (симафоры на самом низком аппаратном-уровне позволяет выводить потоки-мьютексы из состояния дедлока) для управления ограничениями количества существующих потоков
 * - 'Concurrent Collections': разделяет доступ между потоками за счет атомарных операций
 * - 'Queues': (блокирующие, неблокирующие) очереди потоков
 * - 'Executors': (fork-join) фреймворк для создания пулов|шедулера потоков
 * 
 * >> со спецификацией языка вы не можете использовать synchronized в конструкторе это приведет к ошибке компиляции.
 * 
 * >> Это верно только для разных потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него – другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не создаст.
 *    Это верно только для вызовов методов одного экземпляра. У разных экземпляров разные мониторы, потому одновременный вызов нестатических методов проблем не создаст
 *    В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы, или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса
 *    - для синхронизации статических классов важное каким класс-лоадером был такой класс загружен = то есть, два разных синхронизированных метода в статическом класса можно вызывать одновремено НО  
 * они небудут синхронизированы (поскольку класс-лоадеры у них разные)
 * 
 ** (Многопоточность в Java) http://habrahabr.ru/post/164487/
 ** (как работает notify) http://javatalks.ru/topics/35261
 *** (Как ведет себя static метод в многопоточном приложении) http://ru.stackoverflow.com/questions/19452/Как-ведет-себя-static-метод-в-многопоточном-приложении
 *** (Синхронизация потоков) http://www.skipy.ru/technics/synchronization.html
 *
 *                                       (java synchronized примеры)
 *                                                                   http://www.javenue.info/post/87
 *                                                                   http://www.quizful.net/interview/java/volatile-vs-synchronized
 *** (Синхронизация потоков, блокировка объекта и блокировка класса) http://info.javarush.ru/translation/2014/10/27/Синхронизация-потоков-блокировка-объекта-и-блокировка-класса.html
 *                                                                   http://sandro-omsk.livejournal.com/6622.html
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * 
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * > 'Представления' управляются 'контроллером' (контроллером получает запросы к приложению и принимает решение какие представления вернуть)
 * > 'Контроллер' передает в 'представления' информацию для отображения - такая информация называется 'модель'
 * > 'Служба' - это бизнес-логика веб-приложения которая размещается вне 'контроллера'
 * > JSP-страницу называются 'представлениям'
 *   Сервлет (в котором определены GET/POST-методы) называют 'контролером'
 *   webapp/WEB-INF/web.xml - дескриптор развертывания, это карта веб-приложения для сервера приложений (чтобы веб-приложение могло работать внутри сервера приложения (веб-контейнера))
 * > REST (RESTful) - это web-сервис для построения структурированной формы HTTP-запроса доступа к общественным/внешним данным (не имеет стандартов, а только набор общепринятых правил)
 *                    используется для передачи информации с 'клиента на сервер' и с 'сервера на клиент'
 *                    ('AngularJS' - самый популярный MVC-фреймворк)
 * 
 * 'Spring' и технологии ('Spring Core','Spring DATA','Spring MVC','Spring Security','Spring REST')
 * 
 * - Dependency injection (DI) или Inversion of Control (IoC) - описывает ситуацию когда один объект реализует свой функционал через другой объект.
 * - Существует два типа DI:
 *   1. через сэттер;
 *   2. через конструктор;
 * - IoC предоставляет возможность объекту получать ссылки на свои зависимости, это реализуется через lookup-метод. Преимущество IoC в том что эта модель позволяет отделить объекты от реализации механизмов которые он использует.
 *   @Autowired
 * 
 * **************************************[ Spring MVC: DAO-cлой,Сервис-слой,Доменный-слой,Веб-слой,Слой-представления ]**************************************
 * 
 * **************************[ dao Слой доступа к данным - в нём будем размещать Data Access Objects – объекты доступа к данным ]****************************
 * ***********[ Сервис-слой приложения(Содержит интерфейсы, в которых описано ЧТО ДЕЛАТЬ С ДАННЫМИ или, другими словами, бизнес логика приложения ]**********
 * ********************[ Доменный слой (Здесь находятся POJO-классы, такие как User - это то, ЧЕМ приложение оперирует в бизнес логике) ]********************
 * 
 * В приложении Spring-MVC существует два контекста Spring:
 * 1. корневой контекст - для описания бинов приложения (имеющих по большей части отношение к бизнес-логике)
 * 2. контекст сервлета-диспетчера Spring MVC - для бинов относящихся только к Web MVC-части приложения (но в котором могут быть переопределены бины корневого контекста)
 * 
 * Есть два способа загрузки и регистрации бинов в Spring:
 * > Используя конфигурацию в XML-стиле (через дескриптор развертывания web.xml)
 *   ----------------------------------
 *   - сперва в XML-файле конфигурируем наш бин(ы)
 *   Как и раньше, при конфигурировании при помощи дескриптора развертывания приложения 'web.xml':
 *   - мы сообщаем приложению о существовании корневого контекста через объявление листенера типа 'ContextLoaderListener'
 *   - Контекст Spring-MVC передается в качестве параметра при объявлении сервлета-диспетчера 'DispatcherServlet'
 *   <web-app ...>
 *       <context-param>
 *           <param-name>contextConfigLocation</param-name>
 *           <param-value>/WEB-INF/applicationContext.xml</param-value>
 *       </context-param>
 *       <listener>
 *           <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
 *       </listener>
 *       <servlet>
 *           <servlet-name>dispatcher</servlet-name>
 *           <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
 *           <load-on-startup>2</load-on-startup>
 *       </servlet>
 *   </web-app>
 * 
 *   'applicationContext.xml' - туда можно будет добавлять настройки для Hibernate, JPA и т.д.
 *   'dispatcher-servlet.xml' - содержит описания бинов (Java-файлов) которые будет использовать DispatcherServlet
 *                              <context:component-scan base-package="org.app"/> - указывает Spring где нужно искать бины контроллеров и сервисов (@Controller и @Service).
 * 
 * > Используя конфигурацию в JAVA-стиле
 *   -----------------------------------
 *   Конфигурирование Spring:
 *   @Configuration - говорим что это конфигурация
 *   @EnableWebMvc - включаем MVC
 *   @ComponentScan("com...") - указываем где искать контроллеры и остальные компоненты
 *   @Bean
 *   public UrlBasedViewResolver setupViewResolver(){
 *       UrlBasedViewResolver resolver
 *                            resolver.setPrefix("/pages/") - указываем где будут лежать наши веб-страницы
 *                            resolver.setSuffix(".jsp") - формат представления который мы будем использовать
 *   }
 * 
 *   Добавления бинов в контекст Spring с помощью метода:
 *   AnnotationConfigWebApplicationContext ctx - зарегистрировать эту конфигурацию в Spring Context
 *                                         ctx.register(...class) - регистрируем конфигурацию созданую высше
 *   servletContext.addListener(new ContextLoaderListener(ctx)) - добавляем в контекст слушателя с нашей конфигурацией
 *   ServletRegistration.Dynamic servlet = servletContext.addServlet("dispatcher", new DispatcherServlet(ctx)) - настраиваем маппинг Dispatcher Servlet-а:
 *                               servlet.addMapping("/page");
 *                               servlet.setLoadOnStartup(1);
 * 
 * **********************************************************************[ Spring REST ]**********************************************************************
 * *****************[ Веб-слой приложения - классы-контроллеры описывающие КАК и КОГДА приложение взаимодействует с пользователем через веб ]*****************
 * 
 * >> Области видимости (scopes) бинов:
 *   1. singleton - (по умолчанию) IoC контейнер создает единственный экземпляр бина без сохранения состояния (stateless);
 *   2. prototype - Spring IoC контейнер создает любое количество экземпляров бина с сохранением состояния (stateful);
 *   3. request - жизненный цикл экземпляра ограничен единственным HTTP-запросом;
 *   4. session - жизненный цикл экземпляра ограничен в пределах одной (HTTP) сессией;
 *   5. global session - жизненный цикл экземпляра ограничен в пределах глобальной (HTTP) сессией;
 *   6. application - жизненный цикл экземпляра ограничен в пределах ServletContext;
 * 
 * >>> @Controller - в Spring HTTP-запросы обрабатываются 'контроллером' = говорит component-scan что нужно создать спринг-бин из этого класса (поэтому рекомендуется оставлять в нем конструктор по-умолчанию без параметров)
 *                   @Controller по умолчанию поддерживает web-сервис RESTful-формат запроса (другая форма аннотации @RestController)
 * >>> @RestController - появился в 4-ой версии Spring-а использует автоматическое преобразование данных из JAVA-формата в JSON
 * >>> @RequestMapping - слушает/ловит клиентские HTTP-запросы и привязывает адресс к методу-обработчику (@RequestMapping соответствует всем HTTP операциям по умолчанию)
 *                       @RequestMapping(value="/page/{id}") public ModelAndView main() {...}
 * >>> method=RequestMethod.GET - определяет/уточняет тип метода для HTTP-запроса (GET,PUT,POST..)
 *                                @RequestMapping(value="/page/{id}", method=RequestMethod.GET) public ModelAndView main() {...}
 * >>> produces="application/json" - определяет/уточняет формат данных веб-страницы
 *                                   @RequestMapping(value="/page/{id}", method=RequestMethod.GET, produces="application/json") public ModelAndView main() {...}
 *                                   По умолчанию это является гипер-текст
 * >>> @RequestParam - связывает значение строкового параметра HTTP-запроса с параметром передаваемый в метотод
 *                     public ModelAndView main(@RequestParam(value="name", required=false, defaultValue="World") String name, Model model) {...}
 *                     Значение параметра name добавлено в объект Model и делает его доступным в шаблоне представления
 * >>> @PathVariable - позволяет вводить из URL переменную пути в качестве параметра
 *                     @RequestMapping(value="/page/{id}", method=RequestMethod.GET, produces="application/json") public ModelAndView main(@PathVariable String id) {...}
 * >>> Другие полезные аннотации:
 *     Обычно внутри метода-обработчика @RequestMapping для модели добавляем содержимое HTTP-ответа И возвращаем ссылку на веб-страницу
 *     ...Model model){
 *        model.addAttribute("name", name);
 *        return "page";
 *     }
 *     @RequestHeader - чтобы HTTP-заголовок передать как параметр в метод
 *     @ResponseBody - чтобы передать объект как содержимое тела HTTP-ответа на веб-страницу
 *                     public @ResponseBody Employee getEmployeeBy(@RequestParam("name") String name, @RequestHeader("Accept") String accept, @RequestBody String body) {...}
 *     @Valid - служит для валидации требуемых параметров объекта-модели из содержимого HTTP-ответа 
 *     @ResponseStatus - чтобы передать статус результата операции в заголовке HTTP-ответа на веб-страницу
 *     @ExceptionHandler - в случае исключения на @RequestMapping метод-обработчик будет перенаправлен...
 *                         @ResponseStatus(value = HttpStatus.OK) public @ResponseBody ProductActive getUserUpdateId(@PathVariable("name") String name, @RequestBody @Valid TomcatUsers user) {...}
 *                         @ExceptionHandler(value = MethodArgumentNotValidException.class) @ResponseStatus(value = HttpStatus.BAD_REQUEST) public @ResponseBody String handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletResponse response) {...}
 * 
 * Про аннотации Spring IoC:
 * ------------------------
 * >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
 *                   Аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
 *                   Еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
 * >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
 * >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.
 * >>>> @Scope("singleton") -
 * >>>> @PostConstruct - 
 * >>>> @PreDestroy -
 * >>>> @Configuration — собственно эта аннотация и говорит о том, что данный класс является Java Configuration;
 * >>>> @EnableWebMvc — эта аннотация разрешает нашему проекту использовать MVC;
 * >>>> @ComponentScan(«com.devcolibri.common») — аналогично тому component-scan который был в mvc-dispatcher-servlet.xml, говорит, где искать компоненты проекта.
 * >>>> @Bean — указывает на то что это инициализация бина, и он будет создан с помощью DI.
 * >>>> Конфигурация:
 *           WebMvcConfigurerAdapter — унаследовавшись от этого класса мы получим возможность сконфигурировать ResourceLocations.
 *           addResourceHandlers(ResourceHandlerRegistry registry) — переопределив данный метод мы сможем указать где будут лежать ресурсы нашего проекта, такие как css, image, js и другие.
 *           InternalResourceViewResolver — аналогичная конфигурация с mvc-dispatcher-servlet.xml.
 * >>>> @Repository - аннотация показывает, что класс функционирует как репозиторий и требует наличия прозрачной трансляции исключений. Преимуществом трансляции исключений является то, что слой сервиса будет иметь дело с общей иерархией исключений от Спринга (DataAccessException) вне зависимости от используемых технологий доступа к данным в DAO слое.
 * >>>> @Transactional - Перед исполнением метода помеченного данной аннотацией начинается транзакция, после выполнения метода транзакция коммитится, при выбрасывании RuntimeException откатывается.
 * >>>> @Service - используем данную аннотацию, чтобы объявить, что этот класс представляет сервис – компонент сервис-слоя. Сервис является подтипом класса @Component. Использование данной аннотации позволит искать бины-сервисы автоматически (смотрите далее в root-context.xml)
 * >>>>> BeanFactory - это реализация паттерна Фабрика для создание бинов.
 * >>>>> ApplicationContext - (из-за большей функциональности рекомендуется использование вместо BeanFactory) может быть использован для загрузки и связывания бинов.
 *                            Существует 3 основных реализации:
 *                            1. ClassPathXmlApplicationContext (получает информацию из xml-файла, находящегося в classpath)
 *                            2. FileSystemXmlApplicationContext (получает информацию из xml-файла)
 *                            3. XmlWebApplicationContext (получает информацию из xml-файла за пределами web-приложения)
 *                        
 * >>>>> Для проверки работы приложения можно в 'public static void main(String[] args) {...}
 *       ApplicationContext context = new FileSystemXmlApplicationContext(new String[] {"/web/WEB-INF/dispatcher-servlet.xml"});
 * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * 
        // наш подопытный бин
        @Service("testBean")
        @Scope("singleton")
        public class TestBean {
            private String data = "I am a singleton!";
            
            public String getData() {
                return data;
            }
            public void setData(String data) {
                this.data = data;
            }
        }
 * 
 * 1. @Autowired примененный к полям бина
        // бин в который будем инъектить
        @Service("lab1Bean")
        @Scope("session")
        public class SimpleBean {
            @Autowired(required=false)
            private TestBean bean;

            @PostConstruct
            public void init() {
                System.out.println(bean.getData());
            }

            public void setBean(TestBean bean) {
                this.bean = bean;
            }
        }
 * 
 * 2. @Qualifier аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. @Qualifier принимает один входной параметр имя бина:
        // бин в который будем инъектить
        @Service("lab1Bean")
        @Scope("session")
        public class SimpleBean {
            @Autowired
            @Qualifier("testBean")
            private TestBean bean;

            @PostConstruct
            public void init() {
                System.out.println(bean.getData());
            }

            public void setBean(TestBean bean) {
                this.bean = bean;
            }
        }
 *         
 * 3. @Autowired примененный к сеттеру
 *    в таком случае если мы поставим @Autowired перед сеттером setBean: он заинъектит в поле бина-синглтон-TestBean и в консоли мы увидим
 *    «I am a singleton!»
        // бин в который будем инъектить
        @Service("lab1Bean")
        @Scope("session")
        public class SimpleBean {
            private TestBean bean;

            @PostConstruct
            public void init() {
                System.out.println(bean.getData());
            }

            @Autowired
            public void setBean(TestBean bean) {
                this.bean = bean;
            }
        }
 * 
 * 4. @Autowired примененный к конструктору
 *    Ситуация аналогичная — если мы добавим вот такой конструктор: то в консоли увидим долгожданное
 *    «I am a singleton!»
        // бин в который будем инъектить
        @Service("lab1Bean")
        @Scope("session")
        public class SimpleBean {
            private TestBean bean;
            
            @Autowired
            public SimpleBean (TestBean bean) {
                this.bean = bean;
            }

            @PostConstruct
            public void init() {
                System.out.println(bean.getData());
            }

            public void setBean(TestBean bean) {
                this.bean = bean;
            }
        }
 * 
 * 5. @Autowired примененный к методу
 *    Самая интересная ситуация — добавляем вот такой метод (Spring автоматически вызовет 'myFunction' и передаст ему экземпляр 'TestBean' — первое напечатает 'myFunction', а второе напечатает 'init'), в консоли появится:
 *    «I'm an autowired method and I am a singleton!»
 *    «I am a singleton!»
        // бин в который будем инъектить
        @Service("lab1Bean")
        @Scope("session")
        public class SimpleBean {
            private TestBean bean;
            
            public SimpleBean (TestBean bean) {
                this.bean = bean;
            }

            @PostConstruct
            public void init() {
                System.out.println(bean.getData());
            }

            public void setBean(TestBean bean) {
                this.bean = bean;
            }
            
            @Autowired
            public void myFunction(TestBean bean) {
                this.bean = bean;
                System.out.println("I'm an autowired method and " + bean.getData());
            }
        }
 * 
 * Обратите внимание, что необходимо устанавливать значение поля бина (Spring за вас этого не сделает).
 * То есть если не писать «this.bean = bean;» то в методе init будет 'NullPointerException'.
 * 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Ошибка банальная:
 * 1. создаете бин-AuthorService вручную а не делаете @inject в @Controller(тут лучше поменять на @Component).
 *    Т.е не пользуетесь средствами DI/IoC поэтому bean не был создан Spring-ом (значит и не получил нужные зависимости вин-AuthorDao).
 *    Также в бине-AuthorService аннотация @Autowired излишняя т.к bean-ы прописывает и в xml-зависимости.
 * 2. Оказывается нужно @inject-ить 'Service' через 'faces-config.xml' вот таким вот образом:
        <managed-bean>
            <managed-bean-name>authorBean</managed-bean-name>
            <managed-bean-class>domain.pagebean.AuthorPageBean</managed-bean-class>
            <managed-bean-scope>request</managed-bean-scope>
            <managed-property>
                <property-name>service</property-name>
                <value>#{authorService}</value>
            </managed-property>
        </managed-bean>
 * 
 * 'application-context.xml'
<context:annotation-config />
	     <context:component-scan base-package="domain.pagebean" />
	 
	    <bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean">
	        <property name="jndiName" value="jdbc/mainData"/>
	    </bean>
	 
	    <bean class="domain.dao.jdbc.AuthorDAO" id="authorDAO">
	        <property name="dataSource" ref="dataSource"/>
	    </bean>
	 
	    <bean id="authorService" class="domain.service.AuthorService">
	        <property name="dao" ref="authorDAO" />
	    </bean>
 * 
 * 'web.xml'
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:application-context.xml</param-value>
        </context-param>
        
        <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
        </listener>
     
        <servlet>
            <servlet-name>main</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <init-param>
                <param-name>contextConfigLocation</param-name>
                <param-value>classpath:servlet-context.xml</param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>
     
        <servlet-mapping>
            <servlet-name>main</servlet-name>
            <url-pattern>*.do</url-pattern>
        </servlet-mapping>
     
        <welcome-file-list>
            <welcome-file>index.jsp</welcome-file>
        </welcome-file-list>
     
     
        <servlet>
            <servlet-name>FacesServlet</servlet-name>
            <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
            <load-on-startup>1</load-on-startup>
        </servlet>
     
        <servlet-mapping>
            <servlet-name>FacesServlet</servlet-name>
            <url-pattern>*.faces</url-pattern>
        </servlet-mapping>
 * 
 * 
 * (Spring IoC Annotation-based configuration, часть 2) https://habrahabr.ru/post/48606/
 *                             (Spring Autowired + JSF) http://javatalks.ru/topics/36508
 *                                                      http://javatalks.ru/topics/36508?page=2
 * 
 * ******************************[ Слой представления - описывает ЧТО пользователь увидит при взаимодействии с приложением ]**********************************
 *
 * ?????????????????????????????????????????????????????????
 * (Использование Spring для работы с базой данных через JPA) https://github.com/wizardjedi/my-spring-learning/wiki/Работа-с-базами-данных-на-основе-jpa
 * ?????????????????????????????????????????????????????????
 *
 * 
 *** (Конфигурация приложения Spring MVC (почти) без использования XML) http://www.shafranov.net/blog/2013/05/16/konfighuratsiia-prilozhieniia-spring-mvc-pochti-biez-ispolzovaniia-xml
 ***                                       (REST на примере Spring MVC) http://devcolibri.com/3732
 ***                                                 (Spring Framework) https://ru.wikibooks.org/wiki/Spring_Framework
 **                                       (REST на примере Spring MVC) http://devcolibri.com/3732
 **                                          (Spring MVC шаг за шагом) http://mai.pmoproject.ru/pages/viewpage.action?pageId=4424007#SpringMVCшагзашагом-Шаг3:ДобавлениедиспетчераSpringMVC
 ** (Конфигурация приложения Spring MVC (почти) без использования XML) http://www.shafranov.net/blog/2013/05/16/konfighuratsiia-prilozhieniia-spring-mvc-pochti-biez-ispolzovaniia-xml
 **                                   (Spring MVC hello world example) http://www.mkyong.com/spring-mvc/spring-mvc-hello-world-example/
 * https://www.genuitec.com/spring-frameworkrestcontroller-vs-controller/
 * https://spring.io/guides/gs/rest-service/
 * http://spring.io/blog/2009/03/08/rest-in-spring-3-mvc/
 * http://habrahabr.ru/post/86433/
 ** (Spring MVC — JavaConfig либо конфигурация проекта без XML файлов) http://habrahabr.ru/post/226663/
 * http://www.mkyong.com/spring-mvc/spring-mvc-hello-world-example/
 * http://www.tutorialspoint.com/spring/spring_mvc_hello_world_example.htm
 * http://mai.pmoproject.ru/pages/viewpage.action?pageId=4424007#SpringMVCшагзашагом-Шаг3:ДобавлениедиспетчераSpringMVC
 * https://netbeans.org/kb/docs/web/quickstart-webapps-spring_ru.html
 * http://www.spring-source.ru/articles.php?type=manual&theme=articles&docs=article_06
 ** (Spring + Web MVC: dispatcher-servlet.xml vs. applicationContext.xml (plus shared security)) http://stackoverflow.com/questions/16458754/spring-web-mvc-dispatcher-servlet-xml-vs-applicationcontext-xml-plus-shared
 ** (Учимся готовить: Spring 3 MVC + Spring Security + Hibernate) http://habrahabr.ru/post/111102/
 *
 * (Spring Security)
 * http://devcolibri.com/3810
 * http://devcolibri.com/120
 ** (Краткий обзор Spring Security) http://habrahabr.ru/post/203318/
 * (Spring Security: Защити свое приложение) http://www.springbyexample.com.ua/2012/10/spring-security.html
 * https://www.ibm.com/developerworks/ru/library/j-acegi1/
 * http://xpinjection.com/trainings/spring-3/
 * http://javatalks.ru/topics/31659
 * (Spring Security/Ключевые сервисы Spring Security) https://ru.wikibooks.org/wiki/Spring_Security/Ключевые_сервисы_Spring_Security
 * (Spring Security/Технический обзор Spring Security) https://ru.wikibooks.org/wiki/Spring_Security/Технический_обзор_Spring_Security
 *** (Обзор способов и протоколов аутентификации в веб-приложениях) http://habrahabr.ru/company/dataart/blog/262817/
 * https://github.com/Home-SignUp/Jenkins-SignUp/blob/release-3.0/gui/src/main/webapp/WEB-INF/web.xml
 * https://github.com/JobTest/vitrinaPredmainTask/blob/miratex-master/Task/src/main/java/com/vitrina/controller/MainApp.java
 * https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task/src/main/resources
 * https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task/src/test/java/com/miratex
 * https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
 * 
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Spring Security (есть сикюрность по методу и секюрность через фильтр...)
 * X SecurityContextHolder: храним информацию о доверителе, взаимодействующим в настоящее время с приложением
 * X Authentication: для представления этой информации
 *                   >> Сервис 'UserDetails': пользователь это просто Object, может быть приведен к объекту 'UserDetails'
 *                   >> GrantedAuthority: это полномочия (роли) которые предоставляются пользователю
 * X SecurityContext:
 * 
 * 
 * > SecurityContextHolder ... чтобы обеспечить доступ к 'SecurityContext'
 *                             это информация о текущем контексте безопасности приложения (подробная информация о принципиале/пользователе)
 *                             ('SecurityContextHolder' использует стратегии для хранения такой информации: #1 'MODE_THREADLOCAL' локальный поток (по умолчанию); #2 'MODE_GLOBAL' глобальный поток; #3 'MODE_INHERITABLETHREADLOCAL' порожденные от одного защищенного потока)
 * > SecurityContext ......... содержит объект 'Authentication' и в случае необходимости информацию системы безопасности связанную с запросом
 *                             это интерфейс, имеет методы которые возвращают объект-принципиал/пользователя 
 * > Authentication .......... представляет принципала (пользователя авторизованной сессии) с точки зрения Spring Security
 * > GrantedAuthority ........ отражает разрешения выданные доверителю в масштабе всего приложения
 * > UserDetails ............. предоставляет необходимую информацию для построения объекта 'Authentication' из DAO объектов приложения или других источника данных системы безопасности
 * > UserDetailsService ...... чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное)
 * 
 * >> 1) Регистрация - добавление учетной записи пользователя в систему
 * >> 2) Аутентификация - сравнивает ваше имя пользователя с пользователем хранящимся в базе данных И проверяет что ваш пароль совпадает с записью
 *                        (это процесс позволяющий приложению убедиться что человек является именно тем за кого он себя выдает)
 * >> 3) Авторизация - включает в себя два отдельных подхода:
 *                  1. связывание аутентифицированного пользователя с ролями
 *                  2. проверка полномочий на защищенные ресурсы системы
 *                  (после аутентификации пользователя процесс авторизации определяет что этому пользователю разрешено делать в системе)
 *       ?????????????????????????????????????????????????????????
 *       >    'Authentication' -  хранит (объединяет) имя пользователя и пароль в объект (и передается экземпляру 'AuthenticationManager' для проверки)
 *                                пользователю будет предложено войти в систему предоставив имя (логин или email) и пароль
 *                                представляет пользователя (Principal):
 *                                # 'UserDetails' - предоставляет информацию для построения объекта 'Authentication' из DAO-объектов;
 *                                # 'UserDetailsService' - создает 'UserDetails';
 *            'GrantedAuthority' - представляет роли выданные пользователю в масштабе всего приложения
 *       (1)> Если аутентификация прошла успешно возвращает полностью заполненный объект 'Authentication'
 *            Инначе будет выброшено исключение 'BadCredentialsException' (с сообщением "Bad Credentials")
 *       (2)> 'SecurityContext' - для пользователя устанавливается контекст безопасности
 *                                в контексте безопасности храниться вся информация об аутентификации (логин/пароль пользователя) и авторизации (правила авторизации)
 *                                (содержит объект 'Authentication' И информацию системы безопасности 'GrantedAuthority' связанную с запросом от пользователя)
 *       (3)> 'SecurityContextHolder' - содержит полную информацию о текущем контексте безопасности приложения
 *                                      и устанавливает стратегии для хранения информации-'SecurityContext':
 *                                      #1 'MODE_THREADLOCAL' локальный поток (по умолчанию);
 *                                      #2 'MODE_GLOBAL' глобальный поток;
 *                                      #3 'MODE_INHERITABLETHREADLOCAL' порожденные от одного защищенного потока;
 *                                      Например: в веб-приложении сервер кэширует информацию пользователя (принципала) в течение сессии и хранит 'SecurityContext' как атрибут 'HttpSession' между HTTP-запросами
 *                                                (объект 'SecurityContext' извлекается из 'HttpSession' и восстанавливает контекст в 'SecurityContextHolder' для каждого запроса И очищает 'SecurityContextHolder' после завершения запроса)
 *                                                Другие типы приложений, например: 'RESTful веб-сервисы' без сохранения состояния НЕиспользуют HTTP-сессии и будут требовать аутентификации при каждом запросе
 *       >    Авторизированный доступ можно прикручивать на:
 *            - URL-адресса ... <intercept-url pattern="/add*" access="ROLE_USER"/>
 *            - методы ........ <global-method-security secured-annotations="enabled" /> | @Secured("ROLE_ADMIN")
 *       >    Форма (способ) аутентификации может быть:
 *            - базовый
 *            - на форму
 *            - ...
 *       >    Декларация Spring Security через xml-конфигурацию:
 *            - окружаем HTTP-запросы фильтром чтобы гарантировать их защищенность (включаем в web.xml делегирование 'DelegatingFilterProxy' И описываем в '<filter>','<filter-mapping>')
 *            - определяем xml-файл с настройками Spring Security ( security.xml ) для получения защищенного web-приложения
 *            - добавляем ссылки расположение на Spring Security xml-конфигурации (security.xml) в web.xml и перечисляем их: '<context-param>','<param-value>'
 *       
 *       Существует много разных способов аудитенфикации, например: базовый (средствами веб-браузера), через форму (разработчик создает отдельную веб-страницу с формой), цыфровой (другие источники: база данных), с цыфровой подписью (шифрованная строка от доверенного лица)
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *             относительно Spring-а 'сервлет' - это 'контроллер' И на такой сервлет (с тем же именем) можно повесить кофигурационные файлы Spring-а
 *          > : база данных
 *       (1)> 'доменный слой':
 *       (2)> 'DAO слой':
 *       (3)> 'сервисный слой':
 *       (4)> 'WEB-слой': это контроллер (вешает URL-адресс на функцию-обработчик >> распределять запросы по разным методам)
 *       (5)> 'слой представления': это JSP/HTTP-документ (на базе этого документа сервер приложений генерит веб-страничку и отдает ее клиентскому веб-браузеру)
 *          > : веб-браузер
 *       
 *       -------------------[ Модель-представление-контроллер ]-------------------
 *       >  В Spring-е 'контроллер' помечаеться аннотацией - @Controller (сообщет Spring-у что класс является bean-ом и его необходимо подгрузить при старте приложения)
 *
 *	     > Аналогично работают:
 *	       - @PathVariable .... использует параметры из строки URL-адресса
 *	       - @RequestParam .... использует параметры строковых переменных из тела клиентского запроса
 *         - @RequestHeader ... использует параметры из HAED-блока клиентского запроса
 *       > Аналогично работают:
 *         - 'Model' .......... 'модель' передается методу-обработчику в качестве параметра, а метод-обработчик возвращает название 'представления'
 *                              класс-Model передается в качестве параметра методу-обработчику
 *                              а сам же метод-обработчик возвращает строку, которая является адрессом на страницу представления
 *         - 'ModelAndView' ... метод-обработчик создает, определяет и возвращает 'модель' (а внутри этой 'модели' определено 'представление')
 *                              класс-ModelAndView определяется как объект внутри метода-обработчика И в нем-же определяется (в конструкторе) адресс-ссылки на страницу представления
 *                              а сам же метод-обработчик возвращает этот объект типа-ModelAndView
 *
 *			@RequestMapping(value = "/opers/{filialId}", method=RequestMethod.GET)
 *			public ModelAndView getOpers(@PathVariable("filialId") int filialId) {
 *			    ModelAndView model = new ModelAndView("opers");
 *			    model.addObject("opers", operService.getOperByFilialId(filialId));
 *			    return model;
 *			}
 *
 *
 *         - @ResponseBody .... возвращет строковое значение прямо на веб-браузер (минуя 'слой представления')
 * 
         > @ResponseBody - отдает ответ непосредственно браузеру (минуя слой представлений)
                           то есть, если говорить об Spring-MVC архитектуре (использование @ResponseBody предусматривает отсутствие 'слоя представления')
 *       
 *       >  Данные от контроллера к представлению могут передаться двумя способами:
 *       (1)> это можно сделать классом 'Model'
 *       >  @RequestMapping(value = "/myurl") - сообщаем что 'контроллер' будет обрабатывать запрос URL которого "/myurl"
 *			@Controller
 *			public class MyController {
 *				@RequestMapping(value = "/myurl")
 *				public String my() {
 *					return "my";
 *				}
 *			}
 *       (1)>> модель передается методу в виде параметра (метод должен вернуть название представления)
 *			@RequestMapping(value = "/myurl")
 *			public String my(Model model) {
 *				model.addAttribute("name", "Alex");
 *				model.addAttribute("path", "/url-1");
 *				return "my";
 *			}
 *       (2)> это можно сделать классом 'ModelAndView' (агрегирует параметры модели и имя отображения)
 *       >  сообщаем 'контроллеру' что имя 'представления' - "my" (по умолчанию это файл /WEB-INF/views/my.jsp)
 *			@Controller
 *			public class MyController {
 *				@RequestMapping(value = "/myurl")
 *				public ModelAndView my() {
 *					ModelAndView modelView = new ModelAndView();
 *					modelView.setViewName("my");
 *					return modelView;
 *				}
 *			}
 *       >> метод сам создает объект-'ModelAndView' (а 'контроллер' должен вернуть этот объект-'ModelAndView')
 *			@RequestMapping(value = "/myurl")
 *			public ModelAndView my() {
 *				ModelAndView modelView = new ModelAndView();
 *				modelView.setViewName("my");
 *				modelView.addObject("name", "Alex");
 *				modelView.addObject("path", "/url-1");
 *				return modelView;
 *			}
 *
 *       > Чтобы метод requestMapped получил управления, необходимо выполнить запрос вида "/url/my"
			@Controller
			@RequestMapping("/url")
			public class MyController {
				@RequestMapping(value = "/my")
				public String my() {
					return "my";
				}
			}
			или
			@Controller
			@RequestMapping("/")
			public class MyController {
				@RequestMapping(value = "/my")
				public String my() {
					return "my";
				}
			}
		 >  @PathVariable
		    @PathVariable("product") String productName - в аннотации @PathVariable можно как указывать название переменной
		    @PathVariable String category - если НЕделать этого будет использоваться название которое совпадает с названием переменной
			@RequestMapping(value = "/myurl/{category}/{product}")
			public String my(@PathVariable int category, @PathVariable("product") String productName, Model model) {}
			
 * ********************************************************************************************************************************************
 * 
 * @ModelAttribute - является специфической аннотации Spring-MVC и используется для подготовки данных модели
 * 
    @ModelAttribute("myobject")
    public MyObject getInitializeMyObject() {
        return serviceRegistry.myService.getInitializedObject();
    }
    
    @RequestMapping(value="/handle.htm", method=RequestMethod.GET)
    public ModelAndView handleRequest(@ModelAttribute("myobject") MyObject myObject) {
        myObject.setValue("test");
        return new ModelAndView("myView");
    }
    
 * Жизненный цикл @SessionAttributes : 
 * 1. @SessionAttributes - инициализируется, когда вы положили соответствующий атрибут в модели (явно или с помощью @ModelAttribute-аннотированных методов).
 * 2. @SessionAttributes - обновляется данными из параметров HTTP, когда метод контроллера с соответствующим атрибутом модели в своей подписи вызывается.
 * 3. @SessionAttributes - очищаются при вызове SetComplete () на SessionStatus объекта, переданного в метод контроллера в качестве аргумента.
 * 
		@Controller
		@SessionAttributes("myobject")
		public class MyController {
		
		    @RequestMapping(value="/handle.htm", method=RequestMethod.GET)
		    public ModelAndView handleRequest(@ModelAttribute("myobject") MyObject myObject) {
		        myObject.setValue("test");
		        return new ModelAndView("myView");
		    }
		
		}
 * 
 * 
	     (spring mvc контроллер)
	     (Spring 3 и @Controller. Часть 1) http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-1.html
	                                       http://www.seostella.com/ru/article/2012/04/23/spring-3-i-controller-chast-2.html
	          (REST на примере Spring MVC) http://devcolibri.com/3732
 ***     (Spring Security/Технический обзор Spring Security) https://ru.m.wikibooks.org/wiki/Spring_Security/Технический_обзор_Spring_Security
	                         (Краткий обзор Spring Security) http://habrahabr.ru/post/203318/
	     (Power of Spring's @ModelAttribute and @SessionAttributes) http://vmustafayev4en.blogspot.com/2012/10/power-of-springs-modelattribute-and.html
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       (spring mvc asynchronous controller)
 *       ** http://shengwangi.blogspot.com/2015/09/asynchronous-spring-mvc-hello-world.html
 *       ** http://nikcode.blogspot.com/2013/03/spring-mvc-32-servlet.html
 *       http://spring-projects.ru/guides/messaging-stomp-websocket/
 *       http://www.askdev.ru/java/8565/Многопоточность-WEB-приложения-на-Spring/
 *       https://www.flickr.com/photos/60896767@N00/89101625/sizes/l/
 *       
 *       https://spring.io/blog/2012/05/10/spring-mvc-3-2-preview-making-a-controller-method-asynchronous/
 *       https://dev.by/lenta/main/est-li-buduschee-u-mvc-shablona
 *       http://www.slideshare.net/springbyexample/spring-mvc-13512755
 *       https://www.youtube.com/watch?v=nh7eAt5RvZE
 *       * http://www.sql.ru/forum/916079/spring-mvc-ajax-upload-ne-mogu-normalno-poluchit-json-otvet-ot-kontrollera
 *       ** http://nikcode.blogspot.com/2013/03/spring-mvc-32-servlet.html
 *       http://devcolibri.com/2890
 *       http://www.seostella.com/ru/article/2012/04/27/interceptor-perehvat-zaprosov-v-spring-mvc.html
 *       http://habrahabr.ru/post/150034/
 *       ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
 *       ?????????????????????????????????????????????????????????
 * >>> Защита вашего приложения за три простых шага:
 * 
 *     1. создание конфигурационного XML-файла с настройками Spring Security ( WEB-INF/XXX-security.xml ) для получения защищенного web-приложения
 *        (такой Spring Security-диалект известный как - 'стиль пространства имен security')
 *			<http access-denied-page="/error403.jsp"> 
 *			   <intercept-url pattern="/index*" access="ROLE_USER,ROLE_ANONYMOUS"/> 
 *			   <intercept-url pattern="/add*" access="ROLE_USER"/> 
 *			   <intercept-url pattern="/delete/*" access="ROLE_ADMIN"/> 
 *			   <form-login login-page="/login.jsp" default-target-url="/index" authentication-failure-url="/login.jsp?error=true"/> 
 *			   <logout logout-url="/logout" logout-success-url="/index"/> 
 *			   <anonymous username="guest" granted-authority="ROLE_ANONYMOUS"/> 
 *			   <remember-me/> 
 *			</http> 
 *			<authentication-manager alias="authenticationManager">
 *			   <authentication-provider> 
 *			      <user-service> 
 *			         <user name="admin" password="pass" authorities="ROLE_ADMIN,ROLE_USER"/> 
 *			         <user name="user1" password="1111" authorities="ROLE_USER"/> 
 *			         <user name="user2" password="2222" disabled="true" authorities="ROLE_USER"/>    
 *			      </user-service> 
 *			   </authentication-provider>
 *			</authentication-manager>
 *
 *    2.1 добавление Spring DelegatingFilterProxy в 'web.xml'
 *        (DelegatingFilterProxy - это ServletRequest-фильтр позволяет SpringSecurity окружить все запросы и гарантировать что они защищены) 
 *			<filter>
 *			  <filter-name>XXX</filter-name>
 *			  <filterclass>
 *			    org.springframework.web.filter.DelegatingFilterProxy
 *			  </filter-class>
 *			</filter>
 *			<filter-mapping>
 *			  <filter-name>XXX</filter-name>
 *			  <url-pattern>/*</url-pattern>
 *			</filter-mapping>
 *    2.2 добавляем ссылки Spring Security XML (XXX-security.xml) в 'web.xml'
 *        (по умолчанию 'ContrextLoaderListener' ищет XML конфигурационный файл с тем же именем что и Spring Web сервлет 'XXX' - будет искать конфигурационный XML-файл под названием 'WEB-INF/XXX-servlet.xml')
 *        расположение XML-файлов для конфигурации 'ContextLoaderListener' перечисляется в 'web.xml' элементе <context-param>
 *			<context-param>
 *			  <param-name>contextConfigLocation</param-name>
 *			  <param-value>
 *			    /WEB-INF/XXX-security.xml
 *			  </param-value>
 *			</context-param>
 *
 *   (ModelAndView что делает) http://ru.stackoverflow.com/questions/484116/Внешний-ключ-в-hibernate
 *                             http://java-course.ru/old/students/students.php?name=part20
 *                             http://www.sql.ru/forum/1192351/spring-mvc-neskolko-sessionattributes-i-modelattribute
 *** (Spring Security/Технический обзор Spring Security) https://ru.m.wikibooks.org/wiki/Spring_Security/Технический_обзор_Spring_Security
 ***                                                     http://www.spring-source.ru/docs_intermedia.php?type=manual&theme=docs_intermedia&docs_intermedia=chap01_p01
 *                                                       http://habrahabr.ru/post/111102/
 *                                                       http://www.ibm.com/developerworks/ru/library/j-saas/
 *
 *
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Таймаут... и асинхронные приложения
 * 
 * Существуют базовые понятия об распределенной архитектуре веб-приложения. Веб-приложение имеет:
 * - клиентскую часть
 * - серверную часть
 * - и хранилище данных (базу данных)
 * 
 * 1. Клиентская часть
 *    может существовать неограниченное количество клиентов
 *    - клиентские запросы которые выполняются из (базовой) формы на страничке веб-браузера (такие запросы зависимые друг от друга))
 *    - клиентские запросы которые выполняются через AJAX (JavaScript) - такие запросы являются асинхронными (НЕзависимыми друг от друга) 
 * 2. На серверной стороне, прежде всего, все запросы в начале попадают на "сервер приложений"
 *    - сервер приложений имеет свой 'пул потоков', 'таймаут для потока' и еще... это настраивается в контексте сервера приложения
 *      то есть, сервер приложений может полностью управлять клиентскими запросами, выстраивая их в очередь и накладывает на каждый запрос лимит по времени...
 *      Такое поведение 'сервера приложений' гарантирует что серверное приложение будет нормально обрабатывать каждый клиентский запрос (без потери данных в побочных потоках)
 * 3. критерии соединения к базе могут настраиватся отдельно в контексте драйвера... И на стороне сервера базы данных
 *    - контекст драйвера держит свой 'пул соединений', 'время жизни сессии', 'таймаут запроса' и еще...
 *    - сервер базы данных (тоже) держит свой 'пул соединений', 'время жизни сессии', 'таймаут запроса' и еще...
 *      эти настройки гарантируют серверному приложению что запросы не будут бесконечно долго выполняться.
 *      То есть, всегда будет установлен какой-то лимит на выполнение...
    <bean id="dataSource"
          class="org.apache.commons.dbcp.BasicDataSource"
          destroy-method="close"
          p:driverClassName="${jdbc.driver.class}" p:url="${jdbc.url}"
          p:username="${jdbc.username}" p:password="${jdbc.password}"
          p:initialSize="${jdbc.initial.size}" 
          p:minIdle="${jdbc.min.idle}" p:maxIdle="${jdbc.max.idle}" 
          p:maxActive="${jdbc.max.active}"
          p:timeBetweenEvictionRunsMillis="${jdbc.time.between.eviction}" 
          p:minEvictableIdleTimeMillis="${jdbc.min.evictable.idle}" 
          p:testOnBorrow="true" 
          p:validationQueryTimeout="${jdbc.validation.query.timeout}"
          p:validationQuery="${jdbc.validation.query}" />
 * 
 * JDBC - является базовым интерфейсом, который предоставляет функции-методы для работы с базой данных.
 *        Но соединением к базе данных управляет драйвер базы данных (mesql, mssql, postgresql, hsqldb, oracle, ...)
 *        динамическим способом 'Class.forName(...)' - загружается реализация драйвера в jvm
 *        используя 'фабричный метод' - по строке выбираем и возвращаем нужный драйвер для соединения и работы с базой данных
 *        -- в результате получаем класс 'Statement' ('PreparedStatement','CollableStatement') - который предоставляет функции-методы для выполнения запросов к базе данных 
 * Любая реализация ORM-фреймворка (JPA/Persist, Hibernate, TopEclipse, ...) - представляет только функции-методы для работы с базой данных.
 *        Но провайдер, который обеспечивает драйверами для базы данных, реализуется отдельно:
 *        - Spring - 'datasource' (DriverManagerDataSource);
 *        - Apache - 'dbcp' (BasicDataSource);
 *        - MChange - 'c3p0' (ComboPooledDataSource);
 *        -- в результате получаем класс 'DataSource' - который предоставляет функции-методы для выполнения запросов к базе данных
 * 
 * @Repository - аннотация показывает, что класс функционирует как репозиторий и требует наличия прозрачной трансляции исключений.
 *               Преимуществом трансляции исключений является то, что слой сервиса будет иметь дело с общей иерархией исключений от Спринга (DataAccessException) вне зависимости от используемых технологий доступа к данным в DAO слое.
 * @Transactional - Перед исполнением метода помеченного данной аннотацией начинается транзакция, после выполнения метода транзакция коммитится, при выбрасывании RuntimeException откатывается.
 * Spring поддерживает DAO (работа с шаблонами JDBC):
 * - JdbcTemplate - основной шаблон JDBC в Spring предоставляет простой доступ к базе данных
 * - NamedParameterJdbcTemplate - JDBC шаблон позволяет выполнять запросы где значения параметров должны быть связаны с именоваными параметрами в SQL
 * - SimpleJdbcTemplate - шаблон JDBC использует такие новые возможности Java 5 (autoboxing, generics и varargs)
 * - JPATemplate - 
 * - HibernateTemplate - 
 * 
 * 
 ** (18. Data access with JDBC) http://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html
 **         (spring-by-example) https://github.com/spring-by-example/spring-by-example/blob/master/app/contact-app/contact-dao/src/main/resources/META-INF/spring/db/dao-datasource-context.xml
 *      (Spring + JDBC example) http://www.mkyong.com/spring/maven-spring-jdbc-example/
 ***                            https://github.com/JobTest/vitrinaPredmainTask/tree/miratex-master/Task
 * 
 *** (Spring IoC @Autowired NullPointerException) https://habrahabr.ru/post/48606/
 *                                                http://www.sql.ru/forum/898652/ispolovanie-autowired-ne-v-kontrollere
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 *                    (hibernate пул соединений провайдер)
 ***                            (Hibernate + MySQL + c3p0) http://smecsia.me/2008/02/26/hibernate-mysql-c3po/
 *** (Настройка пула соединений к базе данных за firewall) http://www.javaspecialist.ru/2011/04/firewall.html
 *                                                         https://books.google.com.ua/books?id=0OlhCgAAQBAJ&pg=PT24&lpg=PT24&dq=hibernate+%D0%BF%D1%83%D0%BB+%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9+%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80&source=bl&ots=hrp13hgp7z&sig=EAKdtENNmiLV4s3e2r3lOd9atVA&hl=ru&sa=X&ved=0ahUKEwjPw7Hh3oXKAhVomHIKHYXbD9AQ6AEIGjAA#v=onepage&q=hibernate%20%D0%BF%D1%83%D0%BB%20%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9%20%D0%BF%D1%80%D0%BE%D0%B2%D0%B0%D0%B9%D0%B4%D0%B5%D1%80&f=false
 *   http://examples.javacodegeeks.com/enterprise-java/hibernate/hibernate-connection-pool-configuration-with-c3p0-example/
 *   http://www.mkyong.com/hibernate/how-to-configure-the-c3p0-connection-pool-in-hibernate/
 *   http://samsonych.com/lib/hibernate/quickstart.html
 **  (Пулы соединений к БД — зачем и почему) http://habrahabr.ru/post/194142/
 * 
 * (Глава 3. Конфигурация SessionFactory) http://www.dil.univ-mrs.fr/~massat/docs/hibernate-2/reference/ru/html/session-configuration.html
 *                                        http://habrahabr.ru/sandbox/24224/
 * http://www.sql.ru/forum/1107163/jdbc-hibernate-i-pul-soedineniy-k-oracle
 * Есть так называемые "блокировки уровня приложения", они бы подошли тут
максимально. Это, в общем, блокировки сущностей уровня приложения,
которые выполняются тоже на уровне приложения. Т.е. ты их реализуешь
сам. У тебя есть сессии, пользователи, и объекты (документы), так вот,
ты в каке-то место записываешь, что пользователь такой-то в такой-то
сессии заблокировал такой-то документ(ы). Соответственно, при каждом
изменении проверяешь, что этот пользователь в этой сессии имеет блокировку.
 *
 *
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * 
 * > Требование для 'поверхностного клонирования':
 *   - нужно наследоваться от (маркера) Clonable и вызвать переопределить метод clonable() как public (не protected) чтобы расширить область видимости на клон...
 *   - допускаются только поля приметивных типов и такие поля НЕдолжны быть final...
 * > Требование для 'глубокого клонирования':
 *   - когда есть сылочные типы, нужно самому заботитьтся об клонировании сылочных типов.
 *   - дополнительно нужно переопределять clonable() ссылочного типа уже в нутри метода clonable() класса-наследника Clonable...
 * Начиная с Java-5 метод clonable() приводится к типу текущего класса (не к Object)
 * 
 * 
 * (Поверхносное клонирование, Глубокое клонирование) http://habrahabr.ru/post/246993/
 *                                                    http://javateaching.blogspot.com/2011/11/clone.html
 *                                                    http://echuprina.blogspot.com/2012/02/cloneable.html
 * 
 *  
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Java xml маршал / анмаршалинг
 * 
 * > XML - это язык разметки для описания правил документа...
 * > DTD - описывает схему-структуру по правилам которых можно создается XML-документ
 * > В XSD - определены правила которым должен подчинятся XML-документ и предназначен для проверки XML-документа на соответствие
 * 
 * > DOM - это есть объектная модель XML-документа
 *   DOM представляет собой дерево в виде специальных Node-объектов, каждый Node соответствует своему XML-тегу.
 *   Примечание: одно из достоинств DOM перед SAX - скорость обработки информации, но чем больше объем переработанной информации, тем дольше начинает работать DOM.
 * > Если нужно просто прочитать и проанализировать XML-документ тогда лучше использовать SAX.
 *   Но если нужно изменять писать в XML-документ тогда нужно использовать DOM.
 *   
 * > XStream - является примером легковесной и простой в использовании Java-библиотеки для сериализации объектов в XML и обратно.
 * > JAXB - если нужно построить объектное представление XML данных, а также обойти ограничения памяти DOM, то следует использовать JAXB.
 *   Классы созданные с помощью JAXB не обладают возможностью управления деревьями, а это приводит к тому, что дерево объектов JAXB занимает небольшой объем памяти.
 * 
 * (java xstream and jaxb) https://www.ibm.com/developerworks/ru/library/x-xjavaforum5/
 *                         http://www.quizful.net/post/getting-started-with-xml-in-java
 *                         https://javaswing.wordpress.com/2010/03/14/java_dom_xml/
 *                         http://alexandr.logdown.com/posts/22515
 *                         http://develnotes.org/posts_by_tag?tag=java&#.Vo73JITGztI
 *                         https://www.ibm.com/developerworks/ru/library/x-xstream/
 *                         
 *                         
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 ** https://javatalks.ru/topics/29560
 ** http://habrahabr.ru/post/224077/
 ** http://habrahabr.ru/post/243155/
 ** http://habrahabr.ru/post/72617/
 ** http://www.sql.ru/forum/1024273/kak-unit-testit-abstraktnye-klassy
 *
 * > Mockito на ходу делает заглушки для абстрактных методов и поведением этих заглушек можно управлять. Сам mockito использует cglib для манипуляций с байткодом. Cо связностью всё в порядке, абстрактные матоды вызываются из уже реализованных.
 *   то рассказываю: единственный прямой запрет, который существует для абстрактных класов - создание экземпляров этого класса. И это - все! 
 *   Тут вся суть в том, что сам абстрактный класс может в своей логике обращатся к виртуальным методам и свойствам. Т.е. по сути абстрактный класс полностью и реализует всю логику, а за мелочами обращается к переопределенным методам.
 * > Отличие PowerMockiti от Mockito в том что PowerMockito может работать со статическими обектами
 * 
 * (mockito примеры) http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html
 *                   http://habrahabr.ru/post/224077/
 *                   http://ru.stackoverflow.com/questions/255385/%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D0%B0-builder-v4
 *                   http://habrahabr.ru/post/243155/
 *                   http://habrahabr.ru/post/172239/
 *                   http://nixx78.blogspot.com/p/blog-page.html
 *                   http://www.slideshare.net/nunafig/mockito-12079903
 * 
 * - Веб-приложение состоит из 3-ех частей: 'клиентская часть'; 'серверная часть'; 'база данных';
 *   Обычно ведуться паралельные (одновременно) разработки по каждой отдельной части веб-приложения..., а это значит что:
 *   -- на этапе разработки веб-приложения реализация большинства функций еще неготова (то есть, могут существовать какие-то интерфесы...которые описывают бизнес-логику, но пока без реализации).
 *      Например: при разработке сервиса... Поэтому очень часто в JUnit-тестировании применяют Mockito-фреймворк (org.mockito|org.powermock) - это заглушка для абстрактных классов (обычно абстрактные классы могут уже иметь внутри реализованную логику И доступ к своим интерфейсным методам класса)
 *      Кроме этого (обычно) Mockito-фреймворк применяют в JUnit-тестировании для 'сервисов' - это верхние слои приложения (причина: потому-что реальные методы сервисов выполняются очень долго для получения большого количества данных И такие методы сервисов используют другие-вложенные методы которые тоже нужно тестировать и гарантировать их работу...)
 *                                                                                             Mockito позволяет отключить (поставить заглушку) на такие методы сервисов, которые усложняют чистоту выполнения тестов...
 * - Разработка базы данных для веб-приложения...это отдельная тетма...
 *   Обычно база данных создается один раз, в самом начале проектирования веб-приложения И она же остаеться 'боевой' (каким-то способом в эту базу забивают данные - на которые накладываются права конфидециальности...)
 *   -- По причиная дорогостоющей процедуры, на проекте нет базиста который-бы создавал тестовую базу и накатывал-бы на нее скрипты обновления!
 *   -- Но и выполнение тестов на боевой базе данных тоже запрещено!
 *   Выполнение полного цыкла тестирования всех модулей для веб-приложения (включая базу данных) - это 'интеграционное тестирование' (обычно после прохождения таких тестов выполняеться 'ROLLBACK' откат в предыдуще состояние базы данных).
 *   Так как база данных имеет проблемное место в области тестирования, поэтому есть решение: 'HSQLDB' (или другие подобные базы данных) - это легковестная встроенная база данных (утилита написанная на Java) которая НЕтребует трудозатратных действия на установку и разворачивание...!
 *   + имея любой дамп боевой базы данных, можно накатить скрипты обновления на тестовую базу (HSQLDB) и провести интеграционное тестирование - это есть 'автотесты' (такие автотесты позволяют при минимальных ресурсо-затратах выполнять те-же тесты что и при интеграционном тестировании)
 * 
 * 
 * 1. SessionFactory (EntityManagerFactory) + Session: list|get,save,update,delete + (EntityManager: find,persist,merge,remote) ++ (<persistence-unit>|<properties>) (<hibernate-configuration>|<session-factory>)
 *    состояния объектов в сессии: transiend,persist,detach
 * 2. (Entity-сущность это легковесный класс бизнес-логики)
 *    Жизненные циклы Entity: new,manager,detach,remote
 *    требования к Entity что необходимо, поддерживаемые типы для Entity, поддерживаемые типы для первичного ключа наследование
 *    'Embedable','Superclass Entity'
 * 3. Отношения между Entity, стратегии наследования, fetch-стратегии для JPA|Hibernate (@EntityGraph)
 * 4. Уровни кеширование в Hibernate, стратегии кеширования, провайдеры кеширования, методы: clear,evict,flush,constains
 *    @Cacheble, управление в JPA: ALL,NONE, ENABLE|DISABLE SELECTIVE, SPECIFIED
 * 5. Базовая аннотация + @Convert, акцес анотация (2-стратегии)
 * 6. Spring @Repository, Spring @Transaction, Spring шаблоны: JdbcTemplate,NameParameterJdbcTemplate,SimpleJdbcTemplate,HibernateTemplate,JPATemplate
 *    JPA блокировки: NONE,OPTIMISTIC,OPTIMISTIC_FORCE_INCREMENT,PESSIMISTIC_READ,PESSIMISTIC_WRITE,PESSIMISTIC_FORCE_INCREMENT
 * 7. Диалект: SQL,JPQL+TYPE,Criteria (.createCriteria >> .add|.addOrder|.list|.iterate|.scroll >> Expression.like|between,Order.asc|desc)
 *    уровни изоляции + решает пролемы, состояния транзакции: COMMIT,ROLLBACK,CHECKPOINT, способы управления: явный,подразумеваемый,программируемый
 *    блокировки по ресурсам|по типу
 *    ключи, индексы
 *    SELECT-FROM-JOIN|WHERE|HAVING-COUNT-GROUPBY
 * 
 *    (для выборки и удаления строк из базы - выполняется предварительный поиск строки через выборку, то есть, здесь применяется - 'FROM')
 * >> SELECT <field1>,<field2>,<field3> FROM <tab> WHERE <field1>=<1>
 * >> DELETE                            FROM <tab> WHERE <field1>=<1>
 * >> UPDATE                                 <tab> SET   <field2>=<2>,<field3>=<3> WHERE <field1>=<1>
 * >> INSERT INTO                            <tab>       (<field1>,<field2>,<field3>) VALUE (<1>,<2>,<3>)
 *    (для вставки и обновления строк в базе происходит установка значения либо для одного поля - 'SET' либо для множества полей / все строки - 'VALUE')
 * 
 * 
 * Бит [Кбит] - может принимать значение 0 или 1
 *              (это минимальная единица измерения количества информации) в двоичной системе счисления бит равен одному разряду
 *              то есть в общем представлении 'бит' это единица физического элемента (тригер - состояние логического устройства)
 * Байт [Кб] – может принимать значение от 0 до 256 (-128...127)
 *             единица хранения цифровой информации (представляющая собой совокупность битов, в одном байте – 8 бит) которые система может обрабатывать одновременно
 *             то есть в общем представлении 'байт' это единица логического элемента (символ - машинное слово)
 * -- вычислительная техника бывает 8,16,32,64 разрядной И в зависимости от разрядности размера хранения информации (в битах) которая будет обрабатываться одновременно тоже будет разная...
 * 
 * Базовые типы в Java (их 8):
 * ----------------------- boolean=[~4-байта | переменные этого типа могут быть по-разному упакованы jvm]
 * - (цыферки) ----------- byte=[1 байт], char=[2 байта], short=[2 байта], int=[4 байта], long=[8 байт]
 * - (нецелые цыферки) --- float=[4 байта], double=[8 байт]
 * Примеры литералов:
 * false // литерал типа boolean
 * 'a'  // литерал типа char — печатный символ, задаётся в одинарных кавычках
 * '\t' // литерал типа char — специальный символ, не отображается в виде какого-либо значка на экране, но управляет выводом или его форматированием, например, данный символ добавляет в вывод символ табуляции (отступа)
 * 2  // литерал типа int
 * 2L // литерал типа long, можно использовать строчную букву l
 * 2F // литерал типа float, можно использовать строчную букву f
 * 2D // литерал типа double, можно использовать строчную букву d
 *
 * Ссылочная переменная (Объекты):
 * ++ у каждого объекта есть заголовок = [8(12) байт, для 32-х и 64-х разрядных системах]
 * ++ На каждый объект хранится ссылка = [4(8) байт, для 32-х и 64-х разрядных системах]
 * -- размеры экземпляров классов могут отличатся от одной JVM к другой
 * -- В 32-х разрядных системах размер указателя на ячейку памяти занимает 32 бита
 * -- В 64-х разрядных системах размер указателя на ячейку памяти занимает 64 бита
 * - Integer=[16 байт]
 * - String=[24 байта]
 * - Array=[16(24) байт]
 * - ArrayList=[80(144) байт]
 * - LinkedList=[24(40) байт]
 * - TreeSet=[64(104) байт]
 * - HashSet=[136(240) байт]
 * - LinkedHashSet=[176(320) байт]
 * - IdentityHashMap=[344(656) байт]
 * - ConcurrentHashMap=[1306=(2428) байт]
 *
 *
 * такая конструкция 'a--' делает следующее:
 * 1) первым делом ПОЛУЧАЕМ значение переменной ('a')
 * 2) следующим шагом: выполняем АРИФМЕТИЧЕСКУЮ ОПЕРАЦИЮ ('--')
 * 3) при переходе к следующей инструкции ПЕРЕДАЕТСЯ результат выпонения арифметической операции (>> 'a-1')
 *
 * такая конструкция '--a' делает следующее:
 * 1) первым делом выполняем АРИФМЕТИЧЕСКУЮ ОПЕРАЦИЮ ('--')
 * 2) следующим шагом: результат выпонения арифметической операции ПЕРЕДАЕТСЯ-ПРИСВАИВАЕТСЯ переменной (= 'a')
 * 3) и только после (перехода к следующей инструкции) ПОЛУЧАЕМ значение переменной ('a')
 *
 * такая конструкция 'a-- - --a' делает следующее:
 * 1) первым делом ПОЛУЧАЕМ значение из левого операнда ('a')
 * 2.1) следующим шагом: выполняем АРИФМЕТИЧЕСКУЮ операцию в левом операнде ('--')
 * 2.2) следующим шагом: из результата операции полученнго из левого операнда выполняем АРИФМЕТИЧЕСКУЮ операцию в правом операнде И результат передаем-присваиваем в переменную. В итоге получаем результат для правого операнда (>> 'a-1' '--' '=')
 * 3) итак уже имеем значение левого и правого операнда. Теперь выполняем локальную операцию между левым и правым операндом ('a' '-' 'a-2')
 *
 * такая конструкция '--a - a--' делает следующее:
 * 1) выполняем АРИФМЕТИЧЕСКУЮ операцию в левом операнде ('--') И результат передаем-присваиваем в переменную. В итоге получаем результат для левого операнда (= 'a-1')
 * 2) ПОЛУЧАЕМ значение в правом операнде - оно будет равно значению левого операнда ('a')
 * 3) выполняем АРИФМЕТИЧЕСКУЮ операцию между левым и правым операндом - то есть разница между двумя одинаковыми значениями ('-') (= 0)
 *
 * 
 * можно вызвать статические методы используя переменную ссылающую на NULL (потому что статические методы находяться на уровне самого класса, поэтому можна вызвать статические функции при помощи класса так и при помощи переменной равной NULL)
 * 
 *** (Анализ коэффициента заполнения Java-коллекций в Memory Analyzer) http://www.ibm.com/developerworks/ru/library/j-codetoheap/
 ***                                     (Memory Analyzer Version 1.4) http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/ >> http://www.eclipse.org/mat/
 *   (Базовые типы данных) http://frolov-lib.ru/programming/javasamples/vol1/vol1_1/index.html
 *   
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Как работает рекурсивная функция (функция вызывает саму-себя):
 * 1. (первое) в 'стеке' выстраивается свяазанная цепочка вызовов (рекурсивной) функции...
 *    особенность внутри такой цепочки в том, что для каждой следующей вызываямой функции передается уникальный параметр...
 * 2. выход из такого рекурсивного цыкла происходит через выброс 'return'
 *    при этом каждая последняя функция возвращает значение - такое значение можно суммировать...в блоке предшествующей функции
 * 3. условием для выхода из цыкла рекурсии можно управлять через передаваемый параметр И проверять его (условие) в теле функции...
 *    чтобы такое условие выполнялось нужно в передаваемом параметре, для функции, менять значение
		    public int fact(int n){
		        if (n == 0) return 1;
		        if (n == 1) return 5;
		        return 5 + fact(n-1);
		    }
 *
 * Идеология реализации такого алгоритма 'перевернуть массив' заключается в том что экономяться ресурсы память и шагов проходов по массиву (немного нагружается процессор)
 * 0. (при условии что это цифровой массив) планируется перебрать только половину массива...
 * 1. суммируем результат зеркальных (относительно центра - левая|правая половина) элементов массива и сохраняем его (результат), например, в элемент массива из левой половины...
 * 2. тогда для элемента массива из правой половины вычисляется разница от суммы (левого|правого элементов) минус значение элемента массива из правой половины...
 * 3. а для элемента массива из левой половины вычисляется разница от суммы (левого|правого элементов) минус значение элемента массива из, тоже, правой половины (поскольку здесь значение уже изменилось...)
	        for (int i=0; i<(iArr1.length/2); i++){
	            iArr1[i]                += iArr1[iArr1.length-i-1];
	            iArr1[iArr1.length-i-1] = iArr1[i] - iArr1[iArr1.length-i-1];
	            iArr1[i]                = iArr1[i] - iArr1[iArr1.length-i-1];
	        }
 * 
 * 
 * > В Java есть: 'передача по значению' - для приметивных типов; 'передача по ссылке' - для структур|классов;
 * > Есть 3-области:
 *   - Стек (Stack)
 *   - Куча (Heap)
 *   - PermGen (permanent generation)
 * 
 * > Память процесса различается на:
 *   - heap (куча);
 *   - и non-heap (стек) память;
 * >> И состоит из 5 областей (memory pools, memory spaces):
 *    1. Eden (heap) ....................... в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти — очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область.
 *    2. Survivor (heap) ................... сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space.
 *    3. Tenured (Old) Generation (heap) ... здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты.
 *    4. Permanent Generation (non-heap) ... здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.). В частноси
 *    5. Code Cache (non-heap) ............. эта область используется JVM, когда включена JIT-компиляция, в ней кешируется скомпилированный платформенно — зависимый код.
 * 
 * > Изначально когда мы стартуем JVM (Виртуальную Машину Java) - это есть некая исполнительная (системная) программа - при этом для работы 
 *   такой системной программы выделяется определенный-стартовый размер памяти. Важно понимать, что эта выделяемая память для системной программы
 *   JVM является специальной-фиксированой областью памяти которая используется только для обеспечения работы системной программы JVM (но не для
 *   клиентских программ)
 * 
 * 
 * > Сортировка для интерфеса 'Collection' выполняется классом - 'Collections.sort()'
 * > Сортировка массивов выполняется классом - 'Arrays.sort()'
 * > Сортировка для интерфейса 'Map' (например: 'TreeMap') выполняется классом - 'Comparator' или 'Comparable'
 * >> Самосортирующие структуры (например: (Set) 'TreeSet') также выполняется классом - 'Comparator' или 'Comparable'
 * >> Чтобы преобразовать (конвертировать) 'массив элементов' в 'список элементов' нужно применяется функция - 'Arrays.asList()'
 * 
 * 
 * **********************************************************************[ JSP ]**********************************************************************
 * 
 * Как обрабатываются JSP страницы начиная от запроса к серверу заканчивая ответом пользователю:
 * 1. Запрос от пользователя
 * 2. Чтение .jsp страницы сервером
 * 3. Генерация java-класса на основе этой .jsp страницы
 * 4. Компиляция в class-файл
 * 5. Выполнения class-файла
 * 6. Отправка ответа пользователю в виде html-страницы
 * 
 * Какие скоупы переменных существуют в JSP?
 * Это переменные определенного скоупа которые доступны через выражения ${...}
 * В JSP предусмотрены следующие области действия переменных (объектов):
 * > page - область действия страницы (объект доступен только на той странице, где он определен);
 * > request - область действия запроса (объект будет доступен на текущей JSP странице 'jsp:forward', странице пересылки или на включаемой странице 'jsp:include');
 * > session - область действия сессии (объект будет помещен в сеанс пользователя - Бин будет доступен на всех JSP страницах и будет существовать пока существует сессия пользователя, или принудительно удален);
 * > application - область действия приложения (доступен для всех пользователей на всех JSP страницах и существует на протяжении всей работы приложения или пока не будет удален принудительно и контекста приложения);
 * > response
 * > out
 * > config
 * 
 * >> для JSP-старнички скоуп по-умолчанию - 'page'
 * 
 * Из каких груп тегов состоит библиотека JSTL:
 * 1. core - основные теги
 * 2. formatting - теги форматироавния
 * 3. sql - теги для работы с SQL
 * 4. xml - теги для работы с XML
 * 5. functions - функции-теги для обработки строк
 *
 * Фильтры - перехватывает запрос (несоздает запрос или ответ, а только) и модифицирует заголовок и содержимое запроса клиента
 * 
 * Интерфейсы:
 * 1. HttpServletResponse - для отправки данных клиенту
 * 2. HttpServletRequest - для получения параметров HTTP-запроса
 * 3. HttpServletContext - чтобы связать его с контейнером сервлета
 * 4. HttpServletConfig - параметры иннициализации сервлета
 * 
 * Методы сервлета (HttpServlet): GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE
 * >>doService()
 * > doGet()
 * > doPost()
 * > doPut()
 * > doDelete()
 * ...
 * 
 * 
		protected void doGet(HttpServletRequest arg0, HttpServletResponse arg1) throws ServletException, IOException {
		    
		 HttpSession session = arg0.getSession();
		 session.setAttribute("resultString", "Hello, JSP!");
		 RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/result.jsp");
		 dispatcher.forward(arg0, arg1);
		}
 *
        <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
		<BODY>
			<%= session.getValue("resultString") %>
			<% ${hello} %>
			<c:forEach items="${lala}" var="myvar">
			    ....
			</c:forEach>
		</BODY>

 *
 * (Вопросы на собеседование Junior Java Developer) http://jsehelper.blogspot.com/2016/01/jsp-servlets-jstl.html
 *                                                  http://jsehelper.blogspot.com/2016/01/blog-post_13.html
 * (Области видимости JSP переменных) http://javacore.ru/topic/79-jsp.htm
 * (coreer ** Category Archives: JSP) https://coreer.wordpress.com/category/jsp/
 * (coreer ** Category Archives: EL(jsp Expression Language)) https://coreer.wordpress.com/category/eljsp-expression-language/
 * (передача параметров в jsp) http://forum.vingrad.ru/forum/topic-126745.html
 * 
 *
 * **********************************************************************[ Spring ]**********************************************************************
 * 
 * Скоупы в Spring:
 * > singleton (default) — гарантирует единственный экземпляр бина в пределах одного класс-лоадера
 * > prototype — при каждом получении бина (через связывание или getBean), будет создан новый экземпляр класса
 * > request — привязка бина к HTTP запросу
 * > session — бин существует на время жизни сессии
 * > global-session — бин существет в рамках глобальной HTTP сессии (применяется в рамках механизма портлетов).
 * 
 * >> для bean-компонента @Scope по умолчанию (область действия) - 'singleton'
 * 
 * @Service
 * @Scope("prototype")
 * 
		@Service
		@Scope("prototype")
		public class ServiceA {
		    private Customer customer;
		    private ReloadType reloadType;
		
		    private ServiceB serviceB;
		
		    @Autowired
		    private ApplicationContext context;
		
		    public ServiceA(final Customer customer, final ReloadType reloadType) {
		        this.customer = customer;
		        this.reloadType = reloadType;
		    }
		
		    @PostConstruct
		    public void init(){
		        serviceB = (ServiceB) context.getBean("serviceB",customer, reloadType);
		    }
		
		    public void doSomethingInteresting(){
		        doSomthingWithCustomer(customer,reloadType);
		        serviceB.doSomethingBoring();
		    }
		
		    private void doSomthingWithCustomer(final Customer customer, final ReloadType reloadType) {
		
		    }
		}
 * 
		@Configuration
		public class AppContext {
			@Bean(initMethod = "setup", destroyMethod = "cleanup")
			@Scope("prototype")
			public Course course() {
				Course course = new Course();
				course.setModule(module());
				return course;
			}
			...
		}
 * 
 * (Spring bean custom scope) https://habrahabr.ru/post/225397/
 * (Управление bean-компонентами Spring при конфигурировании на основе Java) http://www.ibm.com/developerworks/ru/library/ws-springjava/
 * 
 * **********************************************************************[ Web Service с помощью JAX-WS ]**********************************************************************
 * 
 * 1. Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
				@WebService(name="EntityPortMyType", targetNamespace = "http://my.domain.com/ws/definitions")
				public interface EntityManager{
				    @WebMethod
				    long addEntity();
				
				    @WebMethod
				    long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );
				
				    @WebMethod
				    void removeEntity( @WebParam(name = "id")long id );
				}
 * 2. Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
 *      portName        - должен указывать на порт того типа, что прописан в интерфейсе
 *      targetNamespace - должен быть такой же, как и у интерфейса
 *      endpointInterface - точно указывать на полное имя реализуемого интерфейса
 *      wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
				@WebService(serviceName = "EntityManager",
				            portName="EntityPortMyType",
				            endpointInterface = "com.mydomain.webapp.domain.EntityManager",
				            targetNamespace = "http://my.domain.com/ws/definitions",
				            wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")
				
				public class EntityManagerImpl implements EntityManager{
				    public long addEntity(){
				        // method body
				        return 0;
				    }
				
				    public long findEntity(IdentityType i_type, String identity){
				        // method body
				        return 0;
				    }
				
				    public void removeEntity(long id){
				       // method body
				    }
				}
 * 3. В pom файле проекта необходимо совершить: 
 *    - вставить код для jaxws-maven плагина, 
 *    - обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть)
				<plugin>
				        <groupId>org.codehaus.mojo</groupId>
				        <artifactId>jaxws-maven-plugin</artifactId>
				        <executions>
				            <execution>
				                <goals>
				                    <goal>wsgen</goal>
				                </goals>
				            </execution>
				        </executions>
				        <configuration>
				            <resourceDestDir>${basedir}/src/main/webapp/WEB-INF/wsdl</resourceDestDir>
				            <sei>com.my.domain.webapp.domain.EntityManagerImpl</sei>
				            <genWsdl>true</genWsdl>
				            <keep>true</keep>
				            <packageName>com.my.domain.webapp.domain</packageName>
				        </configuration>
				</plugin>
				<dependency>
				     <groupId>com.sun.xml.ws</groupId>
				     <artifactId>jaxws-rt</artifactId>
				     <version>2.1.3</version>
				</dependency>
 * 4. Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
 *    - Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
 *    - Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener)
				 <listener>
				    <listener-class>
				        com.sun.xml.ws.transport.http.servlet.WSServletContextListener
				    </listener-class>
				</listener>
				
				<servlet id="ws-entities-servlet">
				    <servlet-name>EntityService</servlet-name>
				    <servlet-class>
				        com.sun.xml.ws.transport.http.servlet.WSServlet
				    </servlet-class>
				    <load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping id="ws-entities-servlet-mapping">
				    <servlet-name>EntityService</servlet-name>
				    <url-pattern>/app/entities</url-pattern>
				</servlet-mapping>
 * 5. Создать файл sun-jaxws.xml 
 *      Но что же сервлет будет делать с запросом, пришедшим на url-pattern?
 *      В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки:
				<?xml version="1.0" encoding="UTF-8"?>
				<endpoints
				        xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"
				        version="2.0">
				    <endpoint name="EntityManager"
				            implementation="com.my.domain.webapp.domain.EntityManagerImpl"
				            url-pattern="/app/entities"/>
				</endpoints>
 * 6. Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса
				http://localhost:8080/my-webapp/app/entities?wsdl
 * 
 * 
 ** (Как написать Web Service с помощью JAX-WS) http://anton.troshin.name/?p=1352
 * 
 * **********************************************************************[ Низкоуровневые/Высокоуровневые AJAX запросы ]**********************************************************************
 * 
		$("селектор").load(url,данные,функция)
 * 
		$(document).ready(function(){
		 
		   $("#but1").click(function(){
		      $("#par1").load("testfile.txt");
		   })
		
		});
 *  
 * Что нужно для AJAX-запроса:
 * - Указать url-адрес
 * - Указать метод-тип-запроса
 * - Указать данные для передачи на обработку
 * - Определить функцию для успешного получения данных
 * - Определить функцию которая будет вызвана в случае ошибки
 * - Можно указать функцию в случае любого завершения запроса А также функцию для выполнения синхронного запроса (обычно это асинхронные запросы)
 * 
 * Параметр dataType:
 * > "xml" — полученный xml-документ будет доступен в текстовом виде. С ним можно работать стандартными средствами jQuery (также как и с документом html).
 * > "html" — полученный html будет доступен в текстовом виде. Если он содержит скрипты в тегах <script>, то они будут автоматически выполнены, только когда html-текст будет помещен в DOM.
 * > "script" — полученные данные будут исполнены как javascript. Переменные, которые обычно содержат ответ от сервера будут содержать объект jqXHR.
 * > "json", "jsonp" — полученные данные будут предварительно преобразованы в javascript-объект. Если разбор окажется неудачным (что может случиться, если json содержит ошибки), то будет вызвано исключение ошибки разбора файла. Если сервер, к которому вы обращаетесь, находится на другом домене, то вместо json следует использовать jsonp. Узнать о json и jsonp можно на википедии.
 * > "text" — полученные данные окажутся доступными в виде обычного текста, без предварительной обработки.
 * 
 * > Если для совершения запроса к серверу необходимы данные аутентификации (логин/пароль), то их можно указать в настройках username и password ajax-запроса.
 * > На выполнение запроса к серверу отводится определенное время. Если в течении этого времени сервер не присылает ответ, то запрос завершается с ошибкой (статус "timeout")
 * > В большинстве случаев, ajax-запрос происходит асинхронно, однако в некоторых случаях может понадобиться последовательное выполнение запроса (когда дальнейшее выполнение скрипта невозможно, без получения ответа от сервера). Сделать запрос синхронным можно если отключить настройку 'async'
 * > Может так случиться, что кодировка хоста отличается от кодировки запрашиваемого в ajax-запросе javascript файла. В таких случаях необходимо указать кодировку последнего в настройке 'scriptCharset'
 * 
		$.ajax(); // на сервер будет отправлен GET-запрос на url-адрес текущей страницы и без указания каких-либо параметров
 * 
		$.ajax({
		  url: "some.php",
		  type: "GET",
		  data: "name=John&location=Boston",
		  success: function(msg){
		    $("#results").append(msg);
		  }
		});
 * или
 * 
		$.ajax({
		  url: "some.php",
		  type: "GET",
		  dataType: json,
		  data: {name: 'John', location: 'Boston'},
		  scriptCharset: ...
		  timeout: миллисекундах
		  beforeSend: {
		    // происходит непосредственно перед отправкой запроса на сервер
		  },
		  success: function(msg){
		    // происходит в случае удачного завершения запроса
		    $("#results").append(msg);
		  },
		  error: function(jqXHR, textStatus, errorThrown){
		    // происходит в случае неудачного выполнения запроса
		  },
		  complet: function(jqXHR, textStatus){
		    // происходит в случае любого завершения запроса
		  }
		});
 * или
		$.ajax({
		  type: "GET",
		  url: "test.js",
		  dataType: "script"
		});
 * 
 * 
 ** (Ajax-запрос | jQuery.ajax()) http://jquery.page2page.ru/index.php5/Ajax-запрос
 *                                http://www.wisdomweb.ru/AJAX/jquery.php
 * 
 * **********************************************************************[ Наследование/Полиморфизм/Инкапсуляция ]**********************************************************************
 * Наследование - это расширение функциональных возможностей в классе наследнике за счет родительского класса
 * Инкапсуляция - это скрытие сложного механизма вызовов множества разных методов класса через общий метод с открытым доступом
 * Полиморфизм - это изменение поведения методов в классе наследнике через переопределение
 * ****************
 * В ООП существует два правила для функций с одинаковыми именами:
 * 0. функции с одинаковыми именами могут иметь тлько один тип (то есть, в одном классе НЕможет быть несколько функций с одинаковыми именами но разными типами ДАЖЕ если это класс-наследник)
 * 1. переопределение - это изменение реализации для методов в классах-наследниках
 * 2. перегрузка - это изменения передаваемых параметров (как угодно) в методе, независимо в каком классе он находится
 *
 * Приведение типов - это автоматизированная процедура которая выполняется в двух случаях - либо явно; либо автоматически;
 *                    внутри каждого типа структуры есть методы со специальным названием
 * ****************
 * 0.1 Выполняется только для идентичных методов (для функций с одинаковыми именами и параметрами И типами...инначе ошибка компиляции)
 * 0.2 Класс должен являться наследником, который унаследовал все методы своего родителя (причем родитель у класса-наследника может быть только один)
 * 0.3 Итак при этих условиях, компилятор ищет одинаковые методы в классе исходного типа и подменяет эти методы в классе конечного типа...
 * ****************
 * > В любом случае, компилятор создаст объект тип которого будет соответствовать версии реализации...
 *   И будут использоваться все методы именно этого типа класса (по умолчанию)
 * > Но тип ссылочной переменной (тип интерфейса) будет (ниже по иерархии наследования) ограничивать видимость к функциям соответственно указаному типу класса - то есть, это есть интерфейсные функции
 * > При наследовании нужно жестко соблюдать два правила: переопределение и перегрузка (если одноименные функции будут иметь разный тип даже в классах наследниках - это ошибка на уровне компилятора)
 * > Модификаторы доступа ограничивают область видимости
 * ****************
 * >>> 1. Для одинаковых функций - если ф-я доступна в классе наследнике - тогда имеено ее реализация (ПЕРЕОПРЕДЕЛЕНИЕ) будет общая-перекрываться для всех-всех родительских класов-типа-интерфейса...
 * >>> 2. Для разных функций - если ф-я НЕдоступна в классе наследнике ограничена модификатором доступа (ПЕРЕГРУЗКА) тогда будем вызвана ф-я которая принадлежит конкретному класу-типа-интерфейса...
 * 
        Parent p = new Chield();
        p.test1(); // - метод с дефолтной областью видимости будет доступен и для классов наследников только в одном пакете
                   // А здесь происходит очень интересная вещь:
                   // - с одной стороны как-бы доступны только методы объявленного типа - родительского класса (несмотря что екземпляр класса имеет является - классом наследником)
                   // - но с другой стороны полиморфизм штука хитрая И точно такой-же метод будет искать сначала в классе наследнике (вопреки законам интерфейса)
//        p.test2(); // поскольку в родительском классе область видимости для этого метода запрещает доступ в классе наследнике, поэтому:
                     // - согласно закону интерфейса такого метода несуществует и поэтому здесь будет ошибка компиляции...на момент вызова
        p.test3(); // согласно законам JAVA можно расширять область видимости в классах наследниках НО сужать область видимости в классах наследниках нельзя
                   // - поэтому здесь будет ошибка компиляции...на момент переопределения
 * 
 * > Chield test-1
 * > Parent test-3
 * 
			class Parent {
			    void test1(){
			        System.out.println("Parent test-1");
			    }
			    private void test2(){
			        System.out.println("Parent test-2");
			    }
			    public void test3(){
			        System.out.println("Parent test-3");
			    }
			}
			
			class Chield extends Parent {
			    public void test1(){
			        System.out.println("Chield test-1");
			    }
			    public void test2(){
			        System.out.println("Chield test-2");
			    }
			//    protected void test3(){
			//        System.out.println("Chield test-3");
			//    }
			}
 * 
//          B4_2 x2 = new A4_2();   // ошибка компиляции
//          C4_7 c7_2 = (C4_7)a7_1; // компилятор пропустит такой код, а вот RunTime выкинет ClassCastException
 * 
 * 
 * то рассказываю: единственный прямой запрет, который существует для абстрактных класов - создание экземпляров этого класса. И это - все! 
 * Тут вся суть в том, что сам абстрактный класс может в своей логике обращатся к виртуальным методам и свойствам. Т.е. по сути абстрактный класс полностью и реализует всю логику, а за мелочами обращается к переопределенным методам.
 * 
 * > Отличие PowerMockiti от Mockito в том что PowerMockito может работать со статическими обектами
 * 
* {@link http://cybern.ru/java-polymorphism.html}
 * {@link http://www.javable.com/tutorials/fesunov/lesson8/#%3F%3F%3F%3F%3F%3F%3F%3F%3F%3F%3F}
 ** {@link http://crypto.pp.ua/2010/06/pereopredelenie-metodov-i-polimorfizm-java/}
 * Переопределение методов и полиморфизм java:
 * Способность Java делать выбор метода, исходя из типа объекта во время выполнения, называется поздним связыванием.
 * При вызове метода его поиск происходит сначала в данном классе, затем в суперклассе, пока метод не будет найден или не достигнут Object – суперкласс для всех классов.
 ** {@link http://www.ccfit.nsu.ru/~deviv/courses/oop/tij2nd/Chapter07.html}
 * Забывание типа объекта:
 * Почему кто-то должен намеренно забыть тип объекта?
 * А это происходит, когда, Вы производите приведение к базовому типу
 ** {@link http://java-course.ru/begin/polymorphism/}
 *
 */

public class JPAExample {
	
	@SuppressWarnings("unchecked")
	public static void main(String... argv) {
		EntityManagerFactory factory = null;
		EntityManager        manager = null;
		
		try {
			factory = Persistence.createEntityManagerFactory("TestStore");
			manager = factory.createEntityManager();
			
			//Add several blogPosts entities to database using EntityManager
			manager.getTransaction().begin();
			manager.persist( new BlogPost("BlogPost 1", "This is first blog post", new Date(), true) );
			manager.persist( new BlogPost("Just another blog post", "This is second blog post", new Date(), true) );
			manager.getTransaction().commit();
			
			//Read all entities from database using EntityManager
			Query query = manager.createQuery("SELECT obj FROM BlogPost AS obj ORDER BY obj.date DESC");
			List<BlogPost> list = (List<BlogPost>) query.getResultList();
			
			for (Iterator iterator = list.iterator(); iterator.hasNext();) {
				BlogPost blogPost = (BlogPost) iterator.next();
				System.out.println(blogPost.getId() + " :: '" + blogPost.getTitle() + "' >> " + blogPost.getBody() + " [" + blogPost.getDate() + "]");
			}
			
			
		} finally {
			if (manager!=null) manager.close();
			if (factory!=null) factory.close();
		}
		
		
	}
	
	

	
	
	/**
	 * (10 заметок о модификаторе Static в Java) http://info.javarush.ru/translation/2014/04/15/10-заметок-о-модификаторе-Static-в-Java.html
	 *          (Малоизвестные особенности Java) https://habrahabr.ru/post/133237/
	 * (Синхронизация потоков, блокировка объекта и блокировка класса) http://info.javarush.ru/translation/2014/10/27/Синхронизация-потоков-блокировка-объекта-и-блокировка-класса.html
	 *                                                                 http://www.javenue.info/post/87
	 * (Слово synchronized в Java "на пальцах") http://sandro-omsk.livejournal.com/6622.html 
	 */
	///////////////////////////////////////////////////////////////
	class DemoClass1 {
		public void myMethod11(){
			// @TODO 
		}
	}

	class DemoClass2 {
		public synchronized void myMethod21(){
			// @TODO
		}
		
		public void myMethod22(){
			synchronized(this){
				// @TODO
			}
		}
	}

//	class DemoClass3 {
//		public synchronized static void myMethod31(){
//			// @TODO
//		}
//		
//		public void myMethod32(){
//			synchronized(DemoClass3.class){
//				// @TODO
//			}
//		}
//		
//		private static final Object LOCK = new Object();
//		public void myMethod33(){
//			synchronized(LOCK){
//				// @TODO
//			}
//		}
//	}
	
	static class DemoClass4 { // можно декларировать статические классы + можно декларировать локальные стетические поля и методы
		public synchronized void myMethod41(){
			// @TODO 
		}
		
		public synchronized static void myMethod42(){
			// @TODO
		}
		
		static class DemoClass5 {
			public synchronized void myMethod51(){
				// @TODO
			}
			
			public synchronized static void myMethod52(){
				// @TODO
			}
//			public synchronized void myMethod52(){
//				// @TODO
//			}
		}
		
		class DemoClass52 extends DemoClass5 {
//			public synchronized void myMethod52(){
//				// @TODO
//			}
		}
	}
	
	public static void testMethod(){
//		DemoClass4.myMethod41();
		DemoClass4.myMethod42();
	}
}


class DemoClass3 {
	public synchronized static void myMethod31(){
		// @TODO
	}
	
	public void myMethod32(){
		synchronized(DemoClass3.class){
			// @TODO
		}
	}
	
	private static final Object LOCK = new Object();
	public void myMethod33(){
		synchronized(LOCK){
			// @TODO
		}
	}
}

//static class DemoClass4 {
//	
//}

class DemoClass11 {
	public void startMethod(){
		JPAExample.DemoClass4.myMethod42();
		JPAExample.DemoClass4 demoClass4 = new JPAExample.DemoClass4();
		demoClass4.myMethod41();
		
		JPAExample.DemoClass4.DemoClass5.myMethod52();
		JPAExample.DemoClass4.DemoClass5 demoClass5 = new JPAExample.DemoClass4.DemoClass5();
		demoClass5.myMethod51();
	}
}

