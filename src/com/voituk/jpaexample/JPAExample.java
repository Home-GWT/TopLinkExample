package com.voituk.jpaexample;

import java.util.Date;
import java.util.Iterator;
import java.util.List;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.Query;

/**
 * (java persistence api что это)
 * http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 * http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 * (jpa persistence стратегии)
 * http://habrahabr.ru/post/265061/
 * http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 * http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 * http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * http://habrahabr.ru/post/172239/
 * http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * 
 * *******************************************************
 * JDBC-интерфейс являеться стандартным способом при работе с базами данных.
 * Но JDBC-интерфейс имеет имеет недостатки:
 * - реализация клиентской стороны включая и драйвер коннекта к базе ложиться исключительно на плечи разработчика...
 * - драйвер коннекта к базе сильно зависит от Операционной Сиситемы и железа на стороне клиента где его используют...
 * - разработчику который использует этот JDBC-интерфейс приходиться самостоятельно реализовывать JAVA-класы (сущности) которые моделируют таблицы базы данных...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * JPA (Java Persistence API) - являеться ORM-фреймворком который решает эти задачи и упрощает жизнь разработчику:
 * - кросс-платфоорменная (независимая) реализация драйвера коннекта к базе!
 * - реализует работу с таблицами базы данных на уровне классов!
 * - и собстввенно все транзакции к базе выполняются под управлением исключительно ORM-фреймворка (так что разработчик НЕпариться над порядком построения транзакции и контролирование дедлоков)!
 * 
 * *******************************************************
 * Итак, есть база данных и есть клиенты...
 * Клиенты делают чтение и запись данных в базу...
 * Для выполнения (клиентских) транзакций к базе клиенту нужно подключиться к этой базе...
 * При подключение клиента к базе создается сессия в рамках которой выполняются все транзакций...
 * Каждая транзакция на изменение должна иметь подтверждение (как факт правильности инструкций и начало выполнения)...
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Итак:
 * - существует много клиентских коннектов к базе - сессий;
 * - существует активная инструкция (которая выполняется в текущий момент)...;
 * - и существуют другие инструкции (НЕактивные)...;
 * Дело в том что в базе данные являются общими, то есть, одновременно эти данные могут изменять много клиентов И при этом повредить данные которые еще НЕзафиксированы...
 * Чтобы избежать случаев когда несколько клиентов пытаются одновременно изменить одни и те-же данные И избежать ошибок - для этого и существуют "уровни изоляции":
 * 1. READ UNCOMMITTED  ( изоляция уровня чтения неподтвержденного )
 *    Указывает что другие транзакции могут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 2. READ COMMTITED  ( изоляция уровня чтения подтвержденного )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 * 3. REPEATABLE READ  ( изоляция уровня повторяемого чтения )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 * SNAPSHOT
 * 4. SERIALIZABLE  ( упорядоченная изоляция )
 *    Указывает что другие транзакции НЕмогут читать строки-данные которые были изменены этой-текущей транзакцией (инструкцией) но еще не были зафиксированы.
 *    И другие транзакции НЕмогут изменять строки-данные читаемые этой-текущей транзакцией до ее завершения.
 *    И другие транзакции НЕмогут вставлять новые строки-данные со значениями ключа которые входят в диапазон ключей ДЛЯ считываемых инструкциями этой-текущей транзакции до ее завершения.
 *    
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *                                                             (Spring Roo in Under Nine Minutes) https://www.youtube.com/watch?v=K78vL72XDqw
 * (По следам Spring Pet Clinic. Maven/ Spring Context/ Spring Test/ Spring ORM/ Spring Data JPA) http://habrahabr.ru/post/232381/
 * 
 *                   (java persistence api что это)
 *           (Introduction to Java Persistence API) http://voituk.kiev.ua/2008/01/30/introduction-to-java-persistence-api/
 *             (Java Persistence API (JPA): Основы) http://berkut.homelinux.com/download/pdf/jpa_basic_rus.pdf
 * (SET TRANSACTION ISOLATION LEVEL (Transact-SQL)) https://msdn.microsoft.com/ru-ru/library/ms173763%28v=sql.120%29.aspx
 * 
 *                                                            (jpa persistence стратегии)
 **                 (Шпаргалка Java программиста 1: JPA и Hibernate в вопросах и ответах) http://habrahabr.ru/post/265061/
 * (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Single-table стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-mapping-ierarhii-klassov-s-pomoshju.html
 *       (Alex Tretyakov Blog ** JPA-маппинг иерархии классов с помощью Joined стратегии) http://alextretyakov.blogspot.com/2013/11/jpa-joined-strategija.html
 * 
 * (Persistence.createEntityManagerFactory)
 *   (Начало работы с Java Persistence API) http://www.tune-it.ru/web/vnik/home/-/blogs/начало-работы-с-java-persistence-api
 * 
 *                               (уровни изоляции как работают)
 ** (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 *                          (MySQL: уровни изоляции транзакций) http://habrahabr.ru/post/135217/
 *                (Уровни изоляции транзакций в SQL. Шпаргалка) http://www.arbinada.com/main/ru/node/619
 * 
 *                                  (Введение в хеш-таблицы) https://bitsofmind.wordpress.com/2008/07/28/introduction_in_hash_tables/
 * (PowerMock (+Mockito): новый взгляд на unit-тестирование) http://habrahabr.ru/post/172239/
 *                      (Тестирование GWT с помощью Mockito) http://dmitrynikol.blogspot.com/2011/10/gwt-mockito.html
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *                                             (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php | https://books.google.com.ua/books?id=yqW0D1U0Q9IC&pg=PA343&lpg=PA343&dq=грязное+чтение+неповторяемое+чтение+чтение+фантомов&source=bl&ots=Hc3e5tQSpr&sig=c49sASAVEk_sh5xH1o2DoEaXusc&hl=ru&sa=X&ved=0ahUKEwj3nKO3r8zJAhXBFiwKHeh8CH8Q6AEIMjAE#v=onepage&q=грязное чтение неповторяемое чтение чтение фантомов&f=false
 *                                  (Уровни изоляции транзакции) https://www.youtube.com/watch?v=ovG4QXNpu7U
 *                (Уровень изоляции READ COMMITED SNAPSHOT в 1С) https://www.youtube.com/watch?v=D8PHwf5RHB4
 * (Уровень изоляции неповторяемое чтение, Неповторяемое чтение) https://www.youtube.com/watch?v=TWTDFWxSRYs
 *                          (Уровень изоляции Serializable в 1С) https://www.youtube.com/watch?v=TAGNnvCghlY
 *   (Технологии баз данных: SQL, T-SQL, PL/SQL, реляционные БД) http://datasql.ru/basesql/16.htm
 * 
 * Транзакции - защищают данные с которыми работает пользователь чтобы другой пользователь их неиспортил.
 * Но существуют ситуации когда данные ненужно защищать (потому-что они неявляются важными)...
 * Поэтому одни данные являются очень важными и их нужно защищать, а другие данные неявляются важными или имеют среднюю важность их можно выборочно защищать.
 * Уровень изоляции транзакции - это набор правил которые определяют насколько сильно нужно защищать данные (в транзакциях).
 * 
 * > В ходе выполнения транзакции результат выполнения может быть либо применен-зафиксирован либо отменен-откат.
 * Так вот, пока транзакция еще небыла зафиксирована - нет никакой гарантии что может быть откат - и все незафиксированные данные пропадут - это "Грязное чтение"
 * 
 * > В ходе выполнения транзакции читаем каждую строку (если их много) с какой-то последовательностью.
 * И пока читаем эту строку - она заблокирована от изменения, но как только закончили ее читать и перешли к другой, тогда другая транзакция может изменить освободившуюся строку.
 * То есть нет никаких гарантий что между чтением строки и фиксированием транзакции эта строка не будет снова изменена - это "Неповторяемое чтение".
 * 
 * > В ходе выполнения транзакции также читаем строки (если их много) с какой-то последовательностью...
 * И в этот момент другая транзакция вставляет новые строки между читаемыми строками уже после их прочтения (здесь нет блокировок на еще отсутствующие строки).
 * То есть нет никаких гарантий что после прочтения всех строк до момента фиксированием транзакции не будет добавления новых строк - это "Чтение фантомов".
 * 
 * 1. READ UNCOMMITTED (нет защиты, существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 * 2. READ COMMTITED   (решается проблема "Грязного чтения")
 * 3. REPEATABLE READ  (решается проблема "Неповторяемого чтения")
 * 4. SERIALIZABLE     (решается проблема "Чтения фантомов")
 * 
 * (Базы данных. Вводный курс) http://citforum.ck.ua/database/advanced_intro/80.shtml
 * (Уровни изоляции транзакций в SQL) http://www.osp.ru/pcworld/2009/07/9708191/
 * (Блокировки и уровни изоляции транзакций InnoDB в MySQL) http://habrahabr.ru/post/238513/
 * http://shurshun.ru/tranzaktsii-blokirovki-urovni-izoliovannosti-tranzaktsiy-v-mysql/
 * http://kek.ksu.ru/EOS/BD/SQL_transaction.html
 * http://www.sql.ru/forum/699859/izuchau-urovni-izolyacii-tranzakciy-v-sql-neponyatnoe-povedenie-read-committed
 * http://habrahabr.ru/post/135217/
 * http://www.arbinada.com/main/ru/node/619
 * (уровни изоляции транзакций hibernate)
 * + + + + + + + + + + + + + + + + + + + + + + + + + + + +
 *  (На пути к правильным SQL транзакциям (Часть 1)) http://habrahabr.ru/company/infopulse/blog/261097/
 ** (На пути к правильным SQL транзакциям (Часть 2)) http://habrahabr.ru/company/infopulse/blog/261101/
 *  (Типичные взаимные блокировки в MS SQL и способы борьбы с ними) http://habrahabr.ru/company/mindbox/blog/261661/
 *  (Уровни изоляции) http://professorweb.ru/my/sql-server/2012/level3/3_16.php  |  http://datasql.ru/basesql/16.htm
 *  
 * Сервер накладывает блокировки на данные (при использовании небольших транзакций) для повышение эффективности работы.
 * Блокировка - (временное) ограничение на выполнение некоторых операций обработки данных (может быть наложена на отдельную строку так и на всю базу).
 *  
 * Сессия - это канал связи между клиентом и сервером для обмена данными...
 * Транзакция - это защита данных, чтобы другая транзакция их неиспортила...
 * Уровни изоляции - это набор правил (блокировок) которые определяют степень защиты данных...
 * ...........................................................................................
 * Есть физические данные и абстрактные данные:
 * > физические данные - имеют (описываются) модульную структуру, которая позволяет исключить дублирование и сжимать информацию тем самым повысить скорость-производительность доступа к данным (лежат на медленном дисковом устройстве)
 * > абстрактные данные - являются частицей физических данных, эта временная рабочая/незафиксированая информация (может быть отменена)
 * Только после подстверждения данные попадают из абстрактной области в физическую область.
 *  
 * Блокировки в SQL - это такой себе строительный эелемент который позволяет моделировать разные способы защиты.
 * Условно блокировки можно разделить на 2-а вида: на запись; на чтение;
 * Дело в том элемент-блокировки прежде всего являеться логической компонентой которая описывается так:
 * - Разновидности блокировок по типу блокируемых ресурсов: на строку, на ключ, на страницу, на таблицу, на базу;
 * - Разновидности блокировок по режиму блокирования: Совмещаемая (Shared) блокировка - на чтение; Монопольная (Exclusive) блокировка - на запись; Блокировка обновления (Update)- на чтение/запись; Блокировки с намерением (Intent) - расширяет ресурс при множествености..; ...
 * 
 * (Используя блокировки - уровни изоляции моделируют разные ступени способов защиты на стороне сервера - с посощью уровней изоляции разработчик выбирает оптимальный вариант между скоростью и качеством выполнения запросов)
 * Уровни изоляции транзакции влияют на скорость работы системы поэтому важно правильно выбирать уровень изоляции в зависимости от задачи которую выполняет транзакция:
 * (чем выше уровень изоляции, тем меньше степень одновременного конкурентного доступа но гарантирует полную изоляцию параллельных конкурентных транзакций)
 * 1. READ UNCOMMITTED (нет защиты)
 *                     его следует применять только в тех случаях, когда точность данных не представляет важности или когда данные редко подвергаются изменениям
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (существуют все 3-и проблемы: "Грязное чтение","Неповторяемое чтение","Чтение фантомов")
 *                     если необходимо отображать real time статистику по постоянно изменяющимся данным для построение отчетов
 *                     
 * 2. READ COMMTITED   (выполнят проверку только на наличие монопольной блокировки для данной строки)
 *                     (здесь блокировки отменяются сразу-же после обработки данных (обычно все блокировки отменяются в конце транзакции))
 *                     улучшает параллельный/одновременный доступ к данным
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Грязного чтения")
 *                     (по умолчанию) обычно достаточно использовать для чтения данных, без какой либо транзакции
 *                     
 * 3. REPEATABLE READ  (устанавливает разделяемые блокировки на все считываемые данные и удерживает эти блокировки до тех пор, пока транзакция не будет подтверждена или отменена)
 *                     В этом случае многократное выполнение запроса внутри транзакции всегда будет возвращать один и тот же результат.
 *                     Недостатком этого уровня изоляции является дальнейшее ухудшение одновременного доступа поскольку период времени в течение которого другие транзакции не могут обновлять те же самые данные значительно дольше чем в случае уровня READ COMMITTED.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Неповторяемого чтения")
 *                     если вставка новых записей в параллельных транзакциях никак не может повлиять на результат текущей транзакции
 *                     части которых могут быть изменены во время чтения
 *                     
 * 4. SERIALIZABLE     (устанавливает блокировку на всю область данных, считываемых соответствующей транзакцией, поэтому предотвращает вставку новых строк другой транзакцией до тех пор пока первая транзакция не будет подтверждена или отменена)
 *                     Уровень изоляции SERIALIZABLE реализуется, используя метод блокировки диапазона ключа (устанавливает блокировку на всю область данных считываемых соответствующей транзакцией).
 *                     Не допускает возникновения всех четырех проблем параллельного одновременного конкурентного доступа, перечисленных ранее.
 *                     ------------------------------------------------------------------------------------------------------------------------------------------
 *                     (решается проблема "Чтения фантомов")
 *                     если транзакция изменяет данные в БД и при этом проверяет, чтобы эти данные не противоречили уже существующим записям в БД
 *                     части которых могут быть изменены во время чтения
 *                     
 * Существуют 3-и команды, которые используются для управления транзакциями:
 * 1) COMMIT – для сохранения изменений;
 * 2) ROLLBACK – для отмены изменений;
 * 3) SAVEPOINT – для установки особых точек возврата.
 * 
 * Транзакция определяется на уровне соединения с базой данных и при закрытии соединения автоматически закрывается (когда транзакция начинается все команды считаются телом одной транзакции пока не будет достигнут ее конец).
 * SQL Server предлагает множество средств управления поведением транзакций. Пользователи должны указывать только начало и конец транзакции используя SQL-команды или API:
 * 1) "автоматическое" (по умолчанию SQL Server работает в режиме автоматического начала транзакций, когда каждая команда рассматривается как отдельная транзакция - если команда выполнена успешно то фиксируются... инначе - откат);
 * 2) "подразумеваемое" (когда пользователю понадобится создать транзакцию, включающую несколько команд, он должен явно указать транзакцию);
 * 3) "явное" (SQL Server не может находиться в режиме исключительно явного определения транзакций, этот режим работает поверх двух других);
 * 
 * (Руководство по блокировке и управлению версиями строк транзакций SQL Server) https://msdn.microsoft.com/ru-ru/library/jj856598%28v=sql.120%29.aspx  |  https://msdn.microsoft.com/ru-ru/library/ms187373.aspx
 * (Транзакции и блокировки) http://reis.rtf.urfu.ru/portal/prime/po/sql/70.htm
 * 
 * :::::::::::::::::::::::::::::::::::::::::::::::::::::::
 * Различают 2-а вида блокировки:
 * 1) блокировка записи – транзакция блокирует строки так что запрос другой транзакции к этим строкам будет отменен;
 * 2) блокировка чтения – транзакция блокирует строки так что запрос со стороны другой транзакции на блокировку записи этих строк будет отвергнут, а на блокировку чтения – принят;
 * 
 * блокировки на логических уровнях...
 * 
 * уровни блокировок (по типу блокируемых ресурсов):
 * + на уровне строк;
 * - на уровне ключа;
 * - на уровне страницы; 
 * + на уровне таблиц;
 * + на уровне базы;
 * 
 * уровень 0 – запрещение "загрязнения" данных.
 * уровень 1 – запрещение "грязного" чтения.
 * уровень 2 – запрещение неповторяемого чтения.
 * уровень 3 – запрещение фантомов.
 * 
 * Блокировки в среде MS SQL Server, Управление блокировками
 */

public class JPAExample {
	
	@SuppressWarnings("unchecked")
	public static void main(String... argv) {
		EntityManagerFactory factory = null;
		EntityManager        manager = null;
		
		try {
			factory = Persistence.createEntityManagerFactory("TestStore");
			manager = factory.createEntityManager();
			
			//Add several blogPosts entities to database using EntityManager
			manager.getTransaction().begin();
			manager.persist( new BlogPost("BlogPost 1", "This is first blog post", new Date(), true) );
			manager.persist( new BlogPost("Just another blog post", "This is second blog post", new Date(), true) );
			manager.getTransaction().commit();
			
			//Read all entities from database using EntityManager
			Query query = manager.createQuery("SELECT obj FROM BlogPost AS obj ORDER BY obj.date DESC");
			List<BlogPost> list = (List<BlogPost>) query.getResultList();
			
			for (Iterator iterator = list.iterator(); iterator.hasNext();) {
				BlogPost blogPost = (BlogPost) iterator.next();
				System.out.println(blogPost.getId() + " :: '" + blogPost.getTitle() + "' >> " + blogPost.getBody() + " [" + blogPost.getDate() + "]");
			}
			
			
		} finally {
			if (manager!=null) manager.close();
			if (factory!=null) factory.close();
		}
		
		
	}

}
