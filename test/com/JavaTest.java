package com;

import org.junit.Test;

public class JavaTest {

    /**
     * Task #1
     * *******
     * Полиморфизм
     *
     * Здесь явный полиморфизм,
     * - сигнатура метода 'func()' позволяет расширять область видимости для этого метода
     * - и поскольку это полиморфизм, здесь будет вызываться метод 'func()' который из класса наследника 'B'
     * + ДЕЛО В ТОМ ЧТО 'ПОЛИМОРФИЗМ' ИННИЦИАЛИЗИРУЕТСЯ РАНЬШЕ ЧЕМ ПОЛЯ КЛАССА И ЧЕМ КОНСТРУКТОР, поэтому в классе наследнике 'B' переменная 'String str' БУДЕТ ЕЩЕ НЕопределена (по умолчанию = null)
     *   - первым будет выполнен конструктор родительского класса 'A'
     *   - но здесь в конструкторе родительского класса 'A' будет вызван метод 'func()' который из класса наследника 'B' (а в классе наследнике 'B' переменная 'String str' неопределена, по умолчанию = null)
     */
    class A {
        private String str;

        public A(){
            str = "a";
            func();
        }

        protected void func(){
            System.out.println("A: " + str);
        }
    }

    class B extends A {
        private String str = "b";

        public B() {
            super();
            str = "bla-bla-bla";
        }

        @Override public void func(){
            System.out.println("B: " + str);
        }
    }

    @Test
    public void test1() {
        new B(); // B: null
        A x = new B(); // B: null
    }

    /**
     * Task #2
     * *******
     * Передача параметров по ссылке и по значению
     *
     * тип-1: класс 'C' является объектом ссылочного типа
     * тип-2: переменная 'num' является примитивным типом
     * В качестве параметра тип-1 и тип-2 передаются в метод.
     * + в момент вызова метода в стэке-JVM создает отдельную подзадачу для этого метода, а тело этого метода загружается в кучу-JVM
     *   - JVM на время выполнения инструкций которые внутри этого метода переключается на стэк-JVM
     *   - а после завершения выполнения всех инструкций которые внутри этого метода, возвращает результат в точку ранего вызова И удаляет эту подзадачу из кучи-JVM и из стэка-JVM
     * + поэтому:
     *   - когда в метод передеается параметр по значению: все что будет происходить в теле метода - останется только внутри блока этого метода И в наружу эти изменеия НИКАК НЕпопадут
     *   + когда в метод передеается параметр по ссылке: все что будет происходить в теле метода - может изменить знчения полей для этого ссылочного типа (которые живут в куче-JVM)
     *     - И после завершения-удаления блока этого метода ранее переданная ссылка остается жить, потому-что она была созданна с наружи
     *   + НО когда внутри тела метода изменить только ссылку на этот объект:
     *     - тогда сами-же для поля этого ссылочного типа НЕбудут изменены И поэтому, после завершения-удаления блока этого метода, созданный с наружи объект ссылочного типа останется БЕЗ изменений
     *
     * @see https://github.com/Javer-com-ua/WIKI/wiki/Порядок-инициализации-объекта-в-Java
     *      https://ru.stackoverflow.com/questions/464028/Что-раньше-инициализируется-поля-класса-или-конструктор
     *      http://www.quizful.net/post/java-fields-initialization
     *      http://samolisov.blogspot.com/2007/11/java.html
     */

    int num;

    class C {
        public String name;
        public int num;
    }

    public void func(int num){
        num = 0;
    }

    public void func1(C c){
        c.num = 0; c.name = null;
    }
    public void func2(C c){
        c = null;
    }

    @Test
    public void test2() {
        num = 10;
        func(num);
        System.out.println(num); // 10

        C c = new C();
        c.num = 10; c.name = "abc";
        func1(c);
        System.out.println(c.num + " & " + c.name); // 0 & null

        c.num = 10; c.name = "abc";
        func2(c);
        System.out.println(c.num + " & " + c.name); // 10 & abc
    }

    /**
     * Task #2
     * *******
     * for (I=0; I<N; --I) ...
     *
     * Дело в том, что когда для любого 'Number' типа (в Java) достигаем минимального или максимального предела - после этого начинается отсчет с обратного конца (ПО КОЛЬЦУ)
     * Каждый 'Number' типа (в Java) имеет минимаотное и максимальное значение.
     * Например: достигнув максимального предела - отсчет сбрасывается к минимаотному пределу И продолжается дальше (ПО КОЛЬЦУ)... или наоборот в обратном порядке
     *
     * @see https://ru.wikibooks.org/wiki/Java/Типы_данных
     * @see http://javaway.info/kak-uznat-maksimalnoe-znachenie-int-kak-uznat-minimalnoe-znachenie-byte
     * https://docs.oracle.com/javase/tutorial/java/data/numberformat.html
     */
    @Test
    public void test5_1() {
        System.out.println("Integer.MIN_VALUE=" + Integer.MIN_VALUE + "; Integer.MAX_VALUE=" + Integer.MAX_VALUE + ";"); //Integer.MIN_VALUE=-2147483648; Integer.MAX_VALUE=2147483647;
        System.out.println("Byte.MIN_VALUE=" + Byte.MIN_VALUE + "; Byte.MAX_VALUE=" + Byte.MAX_VALUE + ";"); // Byte.MIN_VALUE=-128; Byte.MAX_VALUE=127;

        int I = -2147483638;

        for (int i=0; i<20; i++) { // такой цыкл будет работать пока выполняется условие 'i<20'
            System.out.format("%1$-2d : %2$-15d \n", i, (--I));
        }
    }
    @Test
    public void test5() {
        System.out.print("for (I=0; I<N; --I) такой цыкл будет работать пока выполняется условие 'I<N' ");
        byte i, n = 20;
        for (i=0; i<n; --i){ // такой цыкл будет работать пока выполняется условие 'I<N'
            System.out.print(i); // 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20 -21 -22 -23 -24 -25 -26 -27 -28 -29 -30 -31 -32 -33 -34 -35 -36 -37 -38 -39 -40 -41 -42 -43 -44 -45 -46 -47 -48 -49 -50 -51 -52 -53 -54 -55 -56 -57 -58 -59 -60 -61 -62 -63 -64 -65 -66 -67 -68 -69 -70 -71 -72 -73 -74 -75 -76 -77 -78 -79 -80 -81 -82 -83 -84 -85 -86 -87 -88 -89 -90 -91 -92 -93 -94 -95 -96 -97 -98 -99 -100 -101 -102 -103 -104 -105 -106 -107 -108 -109 -110 -111 -112 -113 -114 -115 -116 -117 -118 -119 -120 -121 -122 -123 -124 -125 -126 -127 -128
        }

        System.out.print("\nfor (I=0; -I<N; --I) ");
        int I, N=20;
        for (I=0; -I<N; --I){ // только 20 прохождений (I=0; -0<20; --0)
            System.out.print(I); // 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19
        }

        System.out.print("\nfor (I=0; I<N; --N) ");
        N=20;
        for (I=0; I<N; --N){ // только 20 прохождений (I=0; 0<20; --20)
            System.out.print(I); // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        }

        System.out.print("\n(I=0; I+N; --I) только 20 прохождений (C++) ");
        N=20;
//        for (I=0; I+N; --I){ // только 20 прохождений (C++)
        for (I=0; I+N!=0; --I){ // только 20 прохождений (альтернатива C++)
            System.out.print(I); // 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20
        }
    }
}
