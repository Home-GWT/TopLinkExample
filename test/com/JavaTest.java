package com;

import org.junit.Test;

public class JavaTest {

    /**
     * Task #1
     * *******
     * Полиморфизм
     *
     * Здесь явный полиморфизм,
     * - сигнатура метода 'func()' позволяет расширять область видимости для этого метода
     * - и поскольку это полиморфизм, здесь будет вызываться метод 'func()' который из класса наследника 'B'
     * + а в классе наследнике 'B' переменная 'String str' неопределена (по умолчанию = null), поэтому
     *   - первым будет выполнен конструктор родительского класса 'A'
     *   - но здесь в конструкторе родительского класса 'A' будет вызван метод 'func()' который из класса наследника 'B' (а в классе наследнике 'B' переменная 'String str' неопределена, по умолчанию = null)
     */
    class A {
        private String str;

        public A(){
            str = "a";
            func();
        }

        protected void func(){
            System.out.println("A: " + str);
        }
    }

    class B extends A {
        private String str;

        @Override public void func(){
            System.out.println("B: " + str);
        }
    }

    @Test
    public void test1() {
        new B(); // B: null
    }

    /**
     * Task #2
     * *******
     * Передача параметров по ссылке и по значению
     *
     * тип-1: класс 'C' является объектом ссылочного типа
     * тип-2: переменная 'num' является примитивным типом
     * В качестве параметра тип-1 и тип-2 передаются в метод.
     * + в момент вызова метода в стэке-JVM создает отдельную подзадачу для этого метода, а тело этого метода загружается в кучу-JVM
     *   - JVM на время выполнения инструкций которые внутри этого метода переключается на стэк-JVM
     *   - а после завершения выполнения всех инструкций которые внутри этого метода, возвращает результат в точку ранего вызова И удаляет эту подзадачу из кучи-JVM и из стэка-JVM
     * + поэтому:
     *   - когда в метод передеается параметр по значению: все что будет происходить в теле метода - останется только внутри блока этого метода И в наружу эти изменеия НИКАК НЕпопадут
     *   + когда в метод передеается параметр по ссылке: все что будет происходить в теле метода - может изменить знчения полей для этого ссылочного типа (которые живут в куче-JVM)
     *     - И после завершения-удаления блока этого метода ранее переданная ссылка остается жить, потому-что она была созданна с наружи
     *   + НО когда внутри тела метода изменить только ссылку на этот объект:
     *     - тогда сами-же для поля этого ссылочного типа НЕбудут изменены И поэтому, после завершения-удаления блока этого метода, созданный с наружи объект ссылочного типа останется БЕЗ изменений
     */

    int num;

    class C {
        public String name;
        public int num;
    }

    public void func(int num){
        num = 0;
    }

    public void func1(C c){
        c.num = 0; c.name = null;
    }
    public void func2(C c){
        c = null;
    }

    @Test
    public void test2() {
        num = 10;
        func(num);
        System.out.println(num); // 10

        C c = new C();
        c.num = 10; c.name = "abc";
        func1(c);
        System.out.println(c.num + " & " + c.name); // 0 & null

        c.num = 10; c.name = "abc";
        func2(c);
        System.out.println(c.num + " & " + c.name); // 10 & abc
    }

/**
 * Task #2
 * *******
 * for (I=0; I<N; --I) ...
 */
    @Test
    public void test5() {
//        int I, N=20;
//
//        System.out.print("for (I=0; I<N; --I) бесконечный цыкл");
////        for (I=0; I<N; --I){ // бесконечный-неограниченный цыкл (I=0; 0<20; --0)
////            System.out.print("*");
////        }
//
//        System.out.print("\nfor (I=0; I<N; --N) ");
//        for (I=0; I<N; --N){ // только 20 прохождений (I=0; 0<20; --20)
//            System.out.print("*"); // ********************
//        }
//
//        System.out.println("\nfor (I=0; -I<N; --I) ");
//        for (I=0; -I<N; --I){ // только 20 прохождений (I=0; -0<20; --0)
//            System.out.print("*"); // ********************
//        }
//
////        for (I=0; I+N; --I){ // только 20 прохождений (C++)
////            System.out.print("*");
////        }

        int I, N=20;

        System.out.print("for (I=0; I<N; --I) бесконечный цыкл");
//        for (I=0; I<N; --I){ // бесконечный цыкл (I=0; 0<20; --0)
//            System.out.print(I);
//        }

        System.out.print("\nfor (I=0; -I<N; --I) ");
        N=20;
        for (I=0; -I<N; --I){ // только 20 прохождений (I=0; -0<20; --0)
            System.out.print(I); // 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19
        }

        System.out.print("\nfor (I=0; I<N; --N) ");
        N=20;
        for (I=0; I<N; --N){ // только 20 прохождений (I=0; 0<20; --20)
            System.out.print(I); // 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
        }

        System.out.print("\n(I=0; I+N; --I) только 20 прохождений (C++) ");
        N=20;
//        for (I=0; I+N; --I){ // только 20 прохождений (C++)
        for (I=0; I+N!=0; --I){ // только 20 прохождений (альтернатива C++)
            System.out.print(I); // 0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16 -17 -18 -19 -20
        }
    }
}
